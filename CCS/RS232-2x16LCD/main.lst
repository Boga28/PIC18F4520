CCS PCH C Compiler, Version 5.015, 5967               17-Jul-23 09:37

               Filename:   C:\18F4520\CCS\RS232-2x16LCD\main.lst

               ROM used:   1922 bytes (6%)
                           Largest free fragment is 30656
               RAM used:   196 (13%) at main() level
                           207 (13%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   02AC
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
....................  
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir. 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  CLRF   FF7
009E:  ADDLW  B0
00A0:  MOVWF  FF6
00A2:  MOVLW  00
00A4:  ADDWFC FF7,F
00A6:  TBLRD*+
00A8:  MOVF   FF5,W
00AA:  BTFSC  0D.7
00AC:  BSF    FF2.7
00AE:  RETURN 0
00B0:  DATA 0C,4D
00B2:  DATA 45,56
00B4:  DATA 43,55
00B6:  DATA 54,20
00B8:  DATA 59,41
00BA:  DATA 5A,49
00BC:  DATA 3A,20
00BE:  DATA 00,00
00C0:  MOVFF  FF2,0D
00C4:  BCF    FF2.7
00C6:  CLRF   FF7
00C8:  ADDLW  DA
00CA:  MOVWF  FF6
00CC:  MOVLW  00
00CE:  ADDWFC FF7,F
00D0:  TBLRD*+
00D2:  MOVF   FF5,W
00D4:  BTFSC  0D.7
00D6:  BSF    FF2.7
00D8:  RETURN 0
00DA:  DATA 0D,4C
00DC:  DATA 75,74
00DE:  DATA 66,65
00E0:  DATA 6E,20
00E2:  DATA 62,69
00E4:  DATA 72,20
00E6:  DATA 79,61
00E8:  DATA 7A,69
00EA:  DATA 20,67
00EC:  DATA 69,72
00EE:  DATA 69,6E
00F0:  DATA 69,7A
00F2:  DATA 3A,20
00F4:  DATA 00,00
*
0202:  MOVFF  FF2,0D
0206:  BCF    FF2.7
0208:  CLRF   FF7
020A:  ADDLW  1C
020C:  MOVWF  FF6
020E:  MOVLW  02
0210:  ADDWFC FF7,F
0212:  TBLRD*+
0214:  MOVF   FF5,W
0216:  BTFSC  0D.7
0218:  BSF    FF2.7
021A:  RETURN 0
021C:  DATA 0D,4C
021E:  DATA 69,6D
0220:  DATA 69,74
0222:  DATA 20,41
0224:  DATA 73,69
0226:  DATA 6C,64
0228:  DATA 69,21
022A:  DATA 21,21
022C:  DATA 00,00
022E:  MOVFF  FF2,0D
0232:  BCF    FF2.7
0234:  CLRF   FF7
0236:  ADDLW  48
0238:  MOVWF  FF6
023A:  MOVLW  02
023C:  ADDWFC FF7,F
023E:  TBLRD*+
0240:  MOVF   FF5,W
0242:  BTFSC  0D.7
0244:  BSF    FF2.7
0246:  RETURN 0
0248:  DATA 49,4E
024A:  DATA 46,4F
024C:  DATA 52,4D
024E:  DATA 45,4C
0250:  DATA 45,4B
0252:  DATA 54,52
0254:  DATA 4F,4E
0256:  DATA 49,4B
0258:  DATA 41,52
025A:  DATA 2D,47
025C:  DATA 45,20
025E:  DATA 20,20
0260:  DATA 20,53
0262:  DATA 54,41
0264:  DATA 4A,59
0266:  DATA 45,52
0268:  DATA 00,00
026A:  CLRF   01
026C:  CLRF   02
026E:  CLRF   00
0270:  CLRF   03
0272:  MOVF   xCD,W
0274:  BNZ   027A
0276:  MOVF   xCC,W
0278:  BZ    02AA
027A:  MOVLW  10
027C:  MOVWF  xCE
027E:  BCF    FD8.0
0280:  RLCF   xCA,F
0282:  RLCF   xCB,F
0284:  RLCF   00,F
0286:  RLCF   03,F
0288:  MOVF   xCD,W
028A:  SUBWF  03,W
028C:  BNZ   0292
028E:  MOVF   xCC,W
0290:  SUBWF  00,W
0292:  BNC   02A2
0294:  MOVF   xCC,W
0296:  SUBWF  00,F
0298:  BTFSS  FD8.0
029A:  DECF   03,F
029C:  MOVF   xCD,W
029E:  SUBWF  03,F
02A0:  BSF    FD8.0
02A2:  RLCF   01,F
02A4:  RLCF   02,F
02A6:  DECFSZ xCE,F
02A8:  BRA    027E
02AA:  RETURN 0
*
05C4:  TSTFSZ 01
05C6:  BRA    05CE
05C8:  TSTFSZ 02
05CA:  BRA    05D0
05CC:  BRA    05DC
05CE:  INCF   02,F
05D0:  MOVFF  00,FEE
05D4:  DECFSZ 01,F
05D6:  BRA    05D0
05D8:  DECFSZ 02,F
05DA:  BRA    05D0
05DC:  RETURN 0
....................  
.................... #list 
....................  
....................    
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanýr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       Â· LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       Â· WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini saðlar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       Â· PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin içine yükleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       Â· PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       Â· BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       Â· INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       Â· NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */               
....................                                           
.................... #FUSES WDT, WDT1, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC  
.................... #use delay (internal=8000000) 
.................... #use rs232(baud=9600, xmit=PIN_C0,rcv=PIN_C1,bits=8) 
....................  
....................   
....................                                               
....................                                             
....................                                
.................... #include "definitions.h"                                                                                                       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "main.h"                                   
.................... #ifndef MAIN_H      
.................... #define MAIN_H                   
.................... #define DELAY 500  
....................      
.................... extern uint16_t iSayac;   
....................                      
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"     
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS 
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80                      
.................... #bit  PORTA_0=PORTA.0  
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81   
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C   
....................  
.................... #byte TRISC = 0x0F94   
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84 
....................  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................             
.................... #bit  TRISC_6=TRISC.6 
.................... #bit  TRISC_7=TRISC.7 
....................  
.................... #bit  PORTD_7=PORTD.7  
....................                           
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2 
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
.................... #byte ADCON1 = 0x0FC1     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit     
....................  
....................   
....................   
.................... //   #############WATCHDOG#######   
.................... #byte WDTCON   = 0x0FD1  
.................... #bit WDTCON_SWDTEN =WDTCON.0  
....................  
.................... #byte TABLAT =0x0FF5  
.................... #byte TBLPTRU=0x0FF8  
.................... #byte TBLPTRH=0x0FF7  
.................... #byte TBLPTRL=0x0FF6  
.................... #byte EECON2 = 0x0FA7  
....................  
.................... #byte EECON1 = 0x0FA6 
.................... #bit  EECON1_WR =EECON1.1 
.................... #bit  EECON1_WREN =EECON1.2  
.................... #bit  EECON1_FREE =EECON1.4                                             
.................... #bit  EECON1_CFGS = EECON1.6 
.................... #bit  EECON1_EEPGD = EECON1.7         
....................                                                                  
.................... //   ################   RS232/EUSART   #################  // 
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit  
....................                            
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h"                                       
.................... #ifndef INITS_H 
.................... #define INITS_H       
....................  
.................... extern uint16_t iSayac;                          
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _1ms    : 1;  //bit:0, 1ms  
....................       uint8_t _20ms   : 1;  //bit:2, 20ms  
....................       uint8_t _50ms   : 1;  //bit:3, 50ms  
....................       uint8_t _100ms  : 1;  //bit:4, 100ms     
....................       uint8_t _200ms  : 1;  //bit:5, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:6, 500ms  
....................       uint8_t _1000ms : 1;  //bit:7, 1000ms  
....................       uint8_t reserved     : 1; 
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t   tmr1_time;    
....................  
....................                                                 
.................... #endif //INIT_H                               
....................  
.................... #include "button.h" 
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS;  
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t); 
....................    
.................... #endif            
....................  
.................... #include "usart_rs232.h"   
.................... #ifndef USART_RS232_H                                                                                                
.................... #define USART_RS232_H    
....................   
.................... extern uchar_t rxData[32]; 
.................... extern uchar_t txData[32]; 
.................... extern uchar_t data_in; 
.................... extern uint8_t rxData_count; 
.................... extern uchar_t terminal_text1[15];  
.................... extern uchar_t terminal_text2[27];                               
.................... extern uchar_t terminal_text3[17];       
.................... extern uint8_t terminal_text1_Count,terminal_text2_Count,terminal_text3_Count,terminal_text4_Count; 
.................... extern uint8_t terminal_text1_size,terminal_text2_size ,terminal_text3_size,terminal_text4_size;  
.................... extern uint8_t noKbHit_count;   
.................... extern uint8_t switchTerminal_position;  
....................  
....................                                    
.................... typedef union{                  
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{  
....................       uint8_t noKbhit              : 1;  //bit:0, no data for 5 seconds   
....................       uint8_t enter_flag           : 1;  //bit:1, Text executed / Texts are cleared,                                     
....................       uint8_t recieve_exceed       : 1;  //bit:2, LCD- character exceed / 1-Exceed 
....................       uint8_t terminal_text1_flag  : 1;  //bit:3, Text 1 write / 1-DONE  //MEVCUT YAZI  
....................       uint8_t terminal_text2_flag  : 1;  //bit:4, Text 2 write / 1-DONE  //Lutfen bir yazi giriniz:             
....................       uint8_t terminal_text3_flag  : 1;  //bit:5, Text 3 write / 1-DONE  //Limit Asildi!!! 
....................       uint8_t terminal_text4_flag  : 1;  //bit:6, Text 4 write / 1-DONE  //LCD 
....................       uint8_t terminal_text_done   : 1;  //bit:6, Texts are DONE / 1-DONE      
....................    }stUSARTF;                                       
.................... }unUSARTF_t;    
.................... extern unUSARTF_t unUSARTF;     
....................  
.................... uchar_t USART_RxCharBuffer(); 
.................... void USART_TxCharBuffer(); 
.................... void USART_Init(); 
.................... void rs232t();     
....................                                                    
.................... #endif  //USART_RS232_H 
....................                   
....................  
....................  
....................                             
.................... #include "lcd.h"   
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "lcd.c"                         
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS 
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80                      
.................... #bit  PORTA_0=PORTA.0  
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81   
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C   
....................  
.................... #byte TRISC = 0x0F94   
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84 
....................  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................             
.................... #bit  TRISC_6=TRISC.6 
.................... #bit  TRISC_7=TRISC.7 
....................  
.................... #bit  PORTD_7=PORTD.7  
....................                           
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2 
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
.................... #byte ADCON1 = 0x0FC1     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit     
....................  
....................   
....................   
.................... //   #############WATCHDOG#######   
.................... #byte WDTCON   = 0x0FD1  
.................... #bit WDTCON_SWDTEN =WDTCON.0  
....................  
.................... #byte TABLAT =0x0FF5  
.................... #byte TBLPTRU=0x0FF8  
.................... #byte TBLPTRH=0x0FF7  
.................... #byte TBLPTRL=0x0FF6  
.................... #byte EECON2 = 0x0FA7  
....................  
.................... #byte EECON1 = 0x0FA6 
.................... #bit  EECON1_WR =EECON1.1 
.................... #bit  EECON1_WREN =EECON1.2  
.................... #bit  EECON1_FREE =EECON1.4                                             
.................... #bit  EECON1_CFGS = EECON1.6 
.................... #bit  EECON1_EEPGD = EECON1.7         
....................                                                                  
.................... //   ################   RS232/EUSART   #################  // 
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit  
....................                            
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "button.h" 
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS;  
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t); 
....................    
.................... #endif            
....................  
.................... #include "delayms.h"  
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................  
....................                
.................... /*Hex Code   LCD Ekran Karsiligi  
....................  Initialize Lcd in 4-bit mode               0x02 
.................... 1   Function Set: 8-bit, 1 Line, 5×7 Dots   0x30   48                                              
.................... 2   Function Set: 8-bit, 2 Line, 5×7 Dots   0x38   56                            
.................... 3   Function Set: 4-bit, 1 Line, 5×7 Dots   0x20   32 
.................... 4   Function Set: 4-bit, 2 Line, 5×7 Dots   0x28   40  
.................... 0F   LCD acik, Imlec acik 
.................... 01   Ekrani Temizle                                 
.................... 02   Satir Basina Dön            
.................... 04   Imleci Sola Kaydir 
.................... 06   Imleci Saga Kaydir 
.................... 05   Ekrani Saga Kaydir 
.................... 07   Ekrani Sola Kaydir 
.................... 0E   Ekran Acik, Imleç Yanip Sonuyor 
.................... 80   Imleci Ilk Satirin Basinda Konumlandir 
.................... C0   Imleci Ikinci Satirin Basinda Konumlandir         
.................... 3C   Ikinci Satiri Etkinlestir                                                     
.................... 08   Ekran Kapali, Imleç Kapali              
.................... OC   Ekran Acik, Imlec Kapali*/   
....................                                             
.................... uchar_t strLCD[32]; 
.................... uint8_t countLCDChar; 
....................                                          
.................... /*LCD (CHIP: HD44780), COMMAND MODE*/  
.................... void dis_cmd(uchar_t cmdout){  
....................    PORTD=cmdout;      //Send command to lcdport=PORTB 
*
0396:  MOVFF  C6,F8C
....................    PORTE_RS=0;                   
039A:  BCF    F84.0
....................    PORTE_E=1;                
039C:  BSF    F84.1
....................    delayUsFun(1); 
039E:  MOVLW  01
03A0:  MOVWF  xC8
03A2:  RCALL  0388
....................    PORTE_E=0;                               
03A4:  BCF    F84.1
03A6:  RETURN 0
.................... }                                   
....................  
....................  
....................  
.................... void lcdcmd(uchar_t cmd_value){          
....................    uchar_t cmd_value1;                              
....................    cmd_value1 = (cmd_value & 0xF0);      // Mask lower nibble because RB4-RB7 pins are being used    
03A8:  MOVF   xC4,W
03AA:  ANDLW  F0
03AC:  MOVWF  xC5
....................    dis_cmd(cmd_value1);                   // Send to LCD 
03AE:  MOVFF  C5,C6
03B2:  RCALL  0396
....................    cmd_value1 = ((cmd_value<<4) & 0xF0);  // Shift 4-bit and mask 
03B4:  SWAPF  xC4,W
03B6:  MOVWF  00
03B8:  MOVLW  F0
03BA:  ANDWF  00,F
03BC:  MOVF   00,W
03BE:  ANDLW  F0
03C0:  MOVWF  xC5
....................    dis_cmd(cmd_value1);                   // Send to LCD 
03C2:  MOVFF  C5,C6
03C6:  RCALL  0396
03C8:  RETURN 0
.................... } 
....................  // 2 lines are active.              
.................... void twoLinesBCDMode(){  
....................    lcdcmd(0x02); 
*
00F6:  MOVLW  02
00F8:  MOVWF  xC4
00FA:  RCALL  03A8
00FC:  GOTO   03FA (RETURN)
.................... } 
....................                         
.................... // 2 lines are active. BCD MODE 
.................... void LinesActive(){  
....................    lcdcmd(0x28);                
*
03CA:  MOVLW  28
03CC:  MOVWF  xC4
03CE:  RCALL  03A8
03D0:  GOTO   03FC (RETURN)
.................... }                          
.................... // LCD screen clear.                   
.................... void lcdClear(){ 
....................    lcdcmd(0x01);                   
*
03E8:  MOVLW  01
03EA:  MOVWF  xC4
03EC:  RCALL  03A8
03EE:  GOTO   0402 (RETURN)
.................... }                   
.................... // Go to first line. 
.................... void lcdGoToFirstLine(){  
....................    lcdcmd(0x80); 
*
04D0:  MOVLW  80
04D2:  MOVWF  xC4
04D4:  RCALL  03A8
04D6:  GOTO   0520 (RETURN)
.................... }                                  
.................... // Go to second line.                        
.................... void lcdGoToSecondLine(){ 
....................    lcdcmd(0xC0); 
04DA:  MOVLW  C0
04DC:  MOVWF  xC4
04DE:  RCALL  03A8
04E0:  GOTO   0528 (RETURN)
.................... }                        
.................... // Shift cursor to right. 
.................... void lcdShiftRight(){   
....................    lcdcmd(0x06);                                                     
*
03DE:  MOVLW  06
03E0:  MOVWF  xC4
03E2:  RCALL  03A8
03E4:  GOTO   0400 (RETURN)
.................... }                                           
.................... // Display on, Cursor on              
.................... void lcdCursorOn(){                  
....................    lcdcmd(0x0E); 
.................... }                                      
.................... //Display off, Cursor off 
.................... void lcdCursorOff(){                                             
....................    lcdcmd(0x0C);                             
*
03D4:  MOVLW  0C
03D6:  MOVWF  xC4
03D8:  RCALL  03A8
03DA:  GOTO   03FE (RETURN)
.................... }                              
....................   
.................... void dis_data(uchar_t dataout) {  
....................    PORTD=dataout;   //Send data to lcdport=PORTB 
*
04E4:  MOVFF  C7,F8C
....................    PORTE_RS=1;                   
04E8:  BSF    F84.0
....................    PORTE_E=1;                          
04EA:  BSF    F84.1
....................    delayUsFun(1); 
04EC:  MOVLW  01
04EE:  MOVWF  xC8
04F0:  RCALL  0388
....................    PORTE_E=0;   
04F2:  BCF    F84.1
04F4:  RETURN 0
....................    //PORTD=0x00; 
....................    //while(test_bit(PORTD,7));           
.................... }   
.................... /*DATA MODE*/   
.................... void lcddata(uchar_t text){  
....................    uchar_t data;                                                                 
....................    data=(text & 0xF0);         
04F6:  MOVF   xC5,W
04F8:  ANDLW  F0
04FA:  MOVWF  xC6
....................    dis_data(data);     
04FC:  MOVFF  C6,C7
0500:  RCALL  04E4
....................    data=((text<<4)&0xF0);      
0502:  SWAPF  xC5,W
0504:  MOVWF  00
0506:  MOVLW  F0
0508:  ANDWF  00,F
050A:  MOVF   00,W
050C:  ANDLW  F0
050E:  MOVWF  xC6
....................    dis_data(data);                  
0510:  MOVFF  C6,C7
0514:  RCALL  04E4
0516:  GOTO   0546 (RETURN)
.................... }                                
.................... void LCD_String(){  
....................    if(countLCDChar==0)  
051A:  MOVF   xC3,F
051C:  BNZ   0520
....................       lcdGoToFirstLine(); 
051E:  BRA    04D0
....................    if(countLCDChar==16)   
0520:  MOVF   xC3,W
0522:  SUBLW  10
0524:  BNZ   0528
....................       lcdGoToSecondLine();    
0526:  BRA    04DA
....................    if(countLCDChar<=31){  
0528:  MOVF   xC3,W
052A:  SUBLW  1F
052C:  BNC   054A
....................       lcddata(strLCD[countLCDChar]); 
052E:  CLRF   03
0530:  MOVF   xC3,W
0532:  ADDLW  A3
0534:  MOVWF  FE9
0536:  MOVLW  00
0538:  ADDWFC 03,W
053A:  MOVWF  FEA
053C:  MOVFF  FEF,C4
0540:  MOVFF  C4,C5
0544:  BRA    04F6
....................       countLCDChar++;   
0546:  INCF   xC3,F
....................    }else{ 
0548:  BRA    054C
....................       countLCDChar=0; 
054A:  CLRF   xC3
....................    }                  
054C:  GOTO   012E (RETURN)
.................... }  
....................  
....................  
.................... void LCD_Custom_Char(uchar_t loc, uchar_t *msg){ 
....................     uchar_t i; 
....................     if(loc<8) 
....................     { 
....................      lcdcmd(0x40 + (loc*8));    /* Command 0x40 and onwards forces the device to point CGRAM address */ 
....................      for(i=0;i<8;i++)          /* Write 8 byte for generation of 1 character */ 
....................         lcddata(msg[i]);       
....................     }                        
.................... } 
....................  
....................                                           
....................  
....................       
....................  
.................... #include "button.c"           
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "button.h" 
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS;  
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t); 
....................    
.................... #endif            
....................  
.................... uint8_t BUTTON_PRESSED_RELEASED; 
.................... uint8_t STATUS=0;             
....................  
.................... uint8_t test_bit(uint8_t valueOfInput, uint8_t bits){  
....................    return ((valueOfInput & (1<<bits)) != 0); 
0550:  MOVLW  01
0552:  MOVWF  00
0554:  MOVF   xC7,W
0556:  MOVWF  01
0558:  BZ    0562
055A:  BCF    FD8.0
055C:  RLCF   00,F
055E:  DECFSZ 01,F
0560:  BRA    055A
0562:  MOVF   00,W
0564:  ANDWF  xC6,W
0566:  BNZ   056C
0568:  MOVLW  00
056A:  BRA    056E
056C:  MOVLW  01
056E:  MOVWF  01
0570:  GOTO   057E (RETURN)
.................... }                             
....................   
.................... uint8_t button_debounce(uint8_t valueOfInput, uint8_t bit){ 
....................    if(!test_bit(valueOfInput,bit)){ 
0574:  MOVFF  C4,C6
0578:  MOVFF  C5,C7
057C:  BRA    0550
057E:  MOVF   01,F
0580:  BNZ   0588
....................       BUTTON_PRESSED_RELEASED<<=1; 
0582:  BCF    FD8.0
0584:  RLCF   19,F
....................    }else{                        
0586:  BRA    058E
....................       BUTTON_PRESSED_RELEASED<<=1;                        
0588:  BCF    FD8.0
058A:  RLCF   19,F
....................       BUTTON_PRESSED_RELEASED|=1;           
058C:  BSF    19.0
....................    }   
....................    if((BUTTON_PRESSED_RELEASED & 0x07)==0x07){  
058E:  MOVF   19,W
0590:  ANDLW  07
0592:  SUBLW  07
0594:  BNZ   05A0
....................       STATUS = 1; 
0596:  MOVLW  01
0598:  MOVWF  1A
....................       return true;   
059A:  MOVWF  01
059C:  BRA    05B4
....................    }else if((BUTTON_PRESSED_RELEASED  & 0x07)==0x00){  
059E:  BRA    05B4
05A0:  MOVF   19,W
05A2:  ANDLW  07
05A4:  BNZ   05B0
....................       STATUS = 0; 
05A6:  CLRF   1A
....................       return false; 
05A8:  MOVLW  00
05AA:  MOVWF  01
05AC:  BRA    05B4
....................    }else{  
05AE:  BRA    05B4
....................       return STATUS; 
05B0:  MOVFF  1A,01
....................    } 
05B4:  GOTO   013C (RETURN)
.................... }         
....................  
....................  
.................... #include "delayms.c" 
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs)  // Delay function - generates a delay of specified msecs 
.................... {   uint16_t i,j;  
....................     for(i=0;i<=msecs;i++){               
....................       for(j=0;j<197;j++); 
....................     }                                
.................... }  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
*
0388:  CLRF   xC9
038A:  MOVF   xC9,W
038C:  SUBWF  xC8,W
038E:  BNC   0394
0390:  INCF   xC9,F
0392:  BRA    038A
....................     }                                
0394:  RETURN 0
.................... }   
....................  
....................  
.................... #include "usart_rs232.c"      
.................... #include "ucregisters.h"                                                                                              
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS 
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80                      
.................... #bit  PORTA_0=PORTA.0  
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81   
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C   
....................  
.................... #byte TRISC = 0x0F94   
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84 
....................  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................             
.................... #bit  TRISC_6=TRISC.6 
.................... #bit  TRISC_7=TRISC.7 
....................  
.................... #bit  PORTD_7=PORTD.7  
....................                           
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2 
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
.................... #byte ADCON1 = 0x0FC1     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit     
....................  
....................   
....................   
.................... //   #############WATCHDOG#######   
.................... #byte WDTCON   = 0x0FD1  
.................... #bit WDTCON_SWDTEN =WDTCON.0  
....................  
.................... #byte TABLAT =0x0FF5  
.................... #byte TBLPTRU=0x0FF8  
.................... #byte TBLPTRH=0x0FF7  
.................... #byte TBLPTRL=0x0FF6  
.................... #byte EECON2 = 0x0FA7  
....................  
.................... #byte EECON1 = 0x0FA6 
.................... #bit  EECON1_WR =EECON1.1 
.................... #bit  EECON1_WREN =EECON1.2  
.................... #bit  EECON1_FREE =EECON1.4                                             
.................... #bit  EECON1_CFGS = EECON1.6 
.................... #bit  EECON1_EEPGD = EECON1.7         
....................                                                                  
.................... //   ################   RS232/EUSART   #################  // 
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit  
....................                            
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "usart_rs232.h" 
.................... #ifndef USART_RS232_H                                                                                                
.................... #define USART_RS232_H    
....................   
.................... extern uchar_t rxData[32]; 
.................... extern uchar_t txData[32]; 
.................... extern uchar_t data_in; 
.................... extern uint8_t rxData_count; 
.................... extern uchar_t terminal_text1[15];  
.................... extern uchar_t terminal_text2[27];                               
.................... extern uchar_t terminal_text3[17];       
.................... extern uint8_t terminal_text1_Count,terminal_text2_Count,terminal_text3_Count,terminal_text4_Count; 
.................... extern uint8_t terminal_text1_size,terminal_text2_size ,terminal_text3_size,terminal_text4_size;  
.................... extern uint8_t noKbHit_count;   
.................... extern uint8_t switchTerminal_position;  
....................  
....................                                    
.................... typedef union{                  
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{  
....................       uint8_t noKbhit              : 1;  //bit:0, no data for 5 seconds   
....................       uint8_t enter_flag           : 1;  //bit:1, Text executed / Texts are cleared,                                     
....................       uint8_t recieve_exceed       : 1;  //bit:2, LCD- character exceed / 1-Exceed 
....................       uint8_t terminal_text1_flag  : 1;  //bit:3, Text 1 write / 1-DONE  //MEVCUT YAZI  
....................       uint8_t terminal_text2_flag  : 1;  //bit:4, Text 2 write / 1-DONE  //Lutfen bir yazi giriniz:             
....................       uint8_t terminal_text3_flag  : 1;  //bit:5, Text 3 write / 1-DONE  //Limit Asildi!!! 
....................       uint8_t terminal_text4_flag  : 1;  //bit:6, Text 4 write / 1-DONE  //LCD 
....................       uint8_t terminal_text_done   : 1;  //bit:6, Texts are DONE / 1-DONE      
....................    }stUSARTF;                                       
.................... }unUSARTF_t;    
.................... extern unUSARTF_t unUSARTF;     
....................  
.................... uchar_t USART_RxCharBuffer(); 
.................... void USART_TxCharBuffer(); 
.................... void USART_Init(); 
.................... void rs232t();     
....................                                                    
.................... #endif  //USART_RS232_H 
....................                   
....................  
....................  
.................... uchar_t rxData[32]; 
.................... uchar_t txData[32]; 
.................... uchar_t data_in; 
.................... uint8_t rxData_count;  
.................... unUSARTF_t unUSARTF;        
.................... uchar_t terminal_text1[15];  
.................... uchar_t terminal_text2[27];                               
.................... uchar_t terminal_text3[17];    
.................... uint8_t terminal_text1_Count,terminal_text2_Count ,terminal_text3_Count,terminal_text4_Count;  
.................... uint8_t terminal_text1_size,terminal_text2_size ,terminal_text3_size,terminal_text4_size;  
.................... uint8_t noKbHit_count;     
.................... uint8_t switchTerminal_position;  
....................  
....................   
....................                
.................... void USART_Init(){                                                                   
....................    TRISC_6=0;        // Make Tx pin as output    
*
042E:  BCF    F94.6
....................    TRISC_7=1;        // Make Rx pin as input                                                                   
0430:  BSF    F94.7
....................    // Baud rate=9600, SPBRG = (F_CPU /(64*9600))-1         
....................    SPBRG = 0x0C;                       
0432:  MOVLW  0C
0434:  MOVWF  FAF
....................    TXSTA = 0x20;     // Enable Transmit(TX)   
0436:  MOVLW  20
0438:  MOVWF  FAC
....................    RCSTA = 0x90;     // Enable Receive(RX) & Serial 
043A:  MOVLW  90
043C:  MOVWF  FAB
....................             
....................    terminal_text1_size=sizeof(terminal_text1)/sizeof(terminal_text1[0]); 
043E:  MOVLW  0F
0440:  MOVWF  x9C
....................    terminal_text2_size=sizeof(terminal_text2)/sizeof(terminal_text2[0]);   
0442:  MOVLW  1B
0444:  MOVWF  x9D
....................    terminal_text3_size=sizeof(terminal_text3)/sizeof(terminal_text3[0]); 
0446:  MOVLW  11
0448:  MOVWF  x9E
....................    terminal_text4_size=32;                             
044A:  MOVLW  20
044C:  MOVWF  x9F
....................    memcpy(terminal_text1,"\fMEVCUT YAZI: ",terminal_text1_size);   
044E:  CLRF   FEA
0450:  MOVLW  5D
0452:  MOVWF  FE9
0454:  MOVFF  FF2,C4
0458:  BCF    FF2.7
045A:  MOVF   x9C,W
045C:  MOVWF  01
045E:  BZ    0476
0460:  CLRF   FF7
0462:  MOVLW  00
0464:  RCALL  0096
0466:  TBLRD*-
0468:  TBLRD*+
046A:  MOVFF  FF5,FEE
046E:  DECFSZ 01,F
0470:  BRA    0468
0472:  BTFSC  xC4.7
0474:  BSF    FF2.7
....................    memcpy(terminal_text2,"\rLutfen bir yazi giriniz: ",terminal_text2_size);   
0476:  CLRF   FEA
0478:  MOVLW  6C
047A:  MOVWF  FE9
047C:  MOVFF  FF2,C4
0480:  BCF    FF2.7
0482:  MOVF   x9D,W
0484:  MOVWF  01
0486:  BZ    049E
0488:  CLRF   FF7
048A:  MOVLW  00
048C:  RCALL  00C0
048E:  TBLRD*-
0490:  TBLRD*+
0492:  MOVFF  FF5,FEE
0496:  DECFSZ 01,F
0498:  BRA    0490
049A:  BTFSC  xC4.7
049C:  BSF    FF2.7
....................    memcpy(terminal_text3,"\rLimit Asildi!!!",terminal_text3_size);   
049E:  CLRF   FEA
04A0:  MOVLW  87
04A2:  MOVWF  FE9
04A4:  MOVFF  FF2,C4
04A8:  BCF    FF2.7
04AA:  MOVF   x9E,W
04AC:  MOVWF  01
04AE:  BZ    04C6
04B0:  CLRF   FF7
04B2:  MOVLW  00
04B4:  RCALL  0202
04B6:  TBLRD*-
04B8:  TBLRD*+
04BA:  MOVFF  FF5,FEE
04BE:  DECFSZ 01,F
04C0:  BRA    04B8
04C2:  BTFSC  xC4.7
04C4:  BSF    FF2.7
04C6:  GOTO   0124 (RETURN)
.................... }       
....................      
....................  
.................... uchar_t USART_RxCharBuffer(){ 
....................     if(RCIF_PIR1==1){         //wait for receive interrupt flag    
*
05B8:  BTFSS  F9E.5
05BA:  BRA    05C0
....................     return(RCREG);           //received in RCREG register and return to main program  
05BC:  MOVFF  FAE,01
....................     } 
05C0:  GOTO   05E4 (RETURN)
.................... }                           
....................                                            
.................... void USART_TxCharBuffer(uint8_t textIndex_charIndex){                 
....................    if(OERR_RCSTA){               
*
0670:  BTFSS  FAB.1
0672:  BRA    067A
....................       CREN_RCSTA = 0;         
0674:  BCF    FAB.4
....................       #ASM NOP #ENDASM 
0676:  NOP   
....................       CREN_RCSTA=1; 
0678:  BSF    FAB.4
....................    }                                    
....................    TXREG = txData[textIndex_charIndex];             //Write char data to transmit register 
067A:  CLRF   03
067C:  MOVF   xC6,W
067E:  ADDLW  3B
0680:  MOVWF  FE9
0682:  MOVLW  00
0684:  ADDWFC 03,W
0686:  MOVWF  FEA
0688:  MOVFF  FEF,FAD
....................    TXIF_PIR1=0; 
068C:  BCF    F9E.4
068E:  GOTO   072A (RETURN)
.................... }                    
....................                                                          
.................... void rs232t_txText(uint8_t text_index, uint8_t textIndex_charIndex){ 
....................     if(text_index==0&&textIndex_charIndex==0){                                    
0692:  MOVF   xC4,F
0694:  BNZ   06B6
0696:  MOVF   xC5,F
0698:  BNZ   06B6
....................       memcpy(txData, terminal_text1, terminal_text1_size);   
069A:  CLRF   FEA
069C:  MOVLW  3B
069E:  MOVWF  FE9
06A0:  CLRF   FE2
06A2:  MOVLW  5D
06A4:  MOVWF  FE1
06A6:  MOVF   x9C,W
06A8:  MOVWF  01
06AA:  BZ    06B4
06AC:  MOVFF  FE6,FEE
06B0:  DECFSZ 01,F
06B2:  BRA    06AC
....................     }else if(text_index==1&&textIndex_charIndex==0){ 
06B4:  BRA    0724
06B6:  DECFSZ xC4,W
06B8:  BRA    06DA
06BA:  MOVF   xC5,F
06BC:  BNZ   06DA
....................       memcpy(txData, terminal_text2, terminal_text2_size);    
06BE:  CLRF   FEA
06C0:  MOVLW  3B
06C2:  MOVWF  FE9
06C4:  CLRF   FE2
06C6:  MOVLW  6C
06C8:  MOVWF  FE1
06CA:  MOVF   x9D,W
06CC:  MOVWF  01
06CE:  BZ    06D8
06D0:  MOVFF  FE6,FEE
06D4:  DECFSZ 01,F
06D6:  BRA    06D0
....................     }else if(text_index==2&&textIndex_charIndex==0){             
06D8:  BRA    0724
06DA:  MOVF   xC4,W
06DC:  SUBLW  02
06DE:  BNZ   0700
06E0:  MOVF   xC5,F
06E2:  BNZ   0700
....................       memcpy(txData, terminal_text3, terminal_text3_size);   
06E4:  CLRF   FEA
06E6:  MOVLW  3B
06E8:  MOVWF  FE9
06EA:  CLRF   FE2
06EC:  MOVLW  87
06EE:  MOVWF  FE1
06F0:  MOVF   x9E,W
06F2:  MOVWF  01
06F4:  BZ    06FE
06F6:  MOVFF  FE6,FEE
06FA:  DECFSZ 01,F
06FC:  BRA    06F6
....................     }else if(text_index==3&&textIndex_charIndex==0){              
06FE:  BRA    0724
0700:  MOVF   xC4,W
0702:  SUBLW  03
0704:  BNZ   0724
0706:  MOVF   xC5,F
0708:  BNZ   0724
....................       memcpy(txData, strLCD, terminal_text4_size);    
070A:  CLRF   FEA
070C:  MOVLW  3B
070E:  MOVWF  FE9
0710:  CLRF   FE2
0712:  MOVLW  A3
0714:  MOVWF  FE1
0716:  MOVF   x9F,W
0718:  MOVWF  01
071A:  BZ    0724
071C:  MOVFF  FE6,FEE
0720:  DECFSZ 01,F
0722:  BRA    071C
....................     }                                        
....................     USART_TxCharBuffer(textIndex_charIndex);   
0724:  MOVFF  C5,C6
0728:  BRA    0670
072A:  RETURN 0
....................                                                                                                                   
.................... }                                                
....................                                  
.................... void rs232t(){   
....................       unUSARTF.stUSARTF.noKbhit=0; 
*
05DE:  BCF    xA2.0
....................       noKbHit_count=0;                        
05E0:  CLRF   xA0
....................       data_in=USART_RxCharBuffer();                  
05E2:  BRA    05B8
05E4:  MOVFF  01,5B
....................       if(data_in==8 && rxData_count>0){                                                  
05E8:  MOVF   5B,W
05EA:  SUBLW  08
05EC:  BNZ   0606
05EE:  MOVF   5C,F
05F0:  BZ    0606
....................          rxData_count--;                                                           
05F2:  DECF   5C,F
....................          rxData[rxData_count]=0;                                                           
05F4:  CLRF   03
05F6:  MOVF   5C,W
05F8:  ADDLW  1B
05FA:  MOVWF  FE9
05FC:  MOVLW  00
05FE:  ADDWFC 03,W
0600:  MOVWF  FEA
0602:  CLRF   FEF
....................       }else if(data_in==13){ 
0604:  BRA    066C
0606:  MOVF   5B,W
0608:  SUBLW  0D
060A:  BNZ   0646
....................           
....................          unUSARTF.all=0;      
060C:  CLRF   xA2
....................          unUSARTF.stUSARTF.enter_flag=1;  
060E:  BSF    xA2.1
....................          terminal_text1_Count=0,terminal_text2_Count=0,terminal_text3_Count=0,terminal_text4_Count=0;  
0610:  CLRF   x98
0612:  CLRF   x99
0614:  CLRF   x9A
0616:  CLRF   x9B
....................          memcpy(strLCD, rxData, 32); 
0618:  CLRF   FEA
061A:  MOVLW  A3
061C:  MOVWF  FE9
061E:  CLRF   FE2
0620:  MOVLW  1B
0622:  MOVWF  FE1
0624:  MOVLW  20
0626:  MOVWF  01
0628:  MOVFF  FE6,FEE
062C:  DECFSZ 01,F
062E:  BRA    0628
....................          memset(rxData, 0, sizeof(rxData));                        
0630:  CLRF   FEA
0632:  MOVLW  1B
0634:  MOVWF  FE9
0636:  CLRF   00
0638:  CLRF   02
063A:  MOVLW  20
063C:  MOVWF  01
063E:  RCALL  05C4
....................          rxData_count=0;     
0640:  CLRF   5C
....................          switchTerminal_position=0;  
0642:  CLRF   xA1
....................       }else if(rxData_count>31){  
0644:  BRA    066C
0646:  MOVF   5C,W
0648:  SUBLW  1F
064A:  BC    0658
....................          switchTerminal_position=4; 
064C:  MOVLW  04
064E:  MOVWF  xA1
....................          unUSARTF.stUSARTF.recieve_exceed=1; 
0650:  BSF    xA2.2
....................          unUSARTF.stUSARTF.terminal_text3_flag=0; 
0652:  BCF    xA2.5
....................          terminal_text3_Count=0;   
0654:  CLRF   x9A
....................       }else {                         
0656:  BRA    066C
....................          rxData[rxData_count] = data_in;  
0658:  CLRF   03
065A:  MOVF   5C,W
065C:  ADDLW  1B
065E:  MOVWF  FE9
0660:  MOVLW  00
0662:  ADDWFC 03,W
0664:  MOVWF  FEA
0666:  MOVFF  5B,FEF
....................          rxData_count++;             
066A:  INCF   5C,F
....................       }   
066C:  GOTO   0732 (RETURN)
.................... }                                               
....................  
....................  
.................... // "init.h" TIMER1 INTERRUPT                       
.................... uint16_t iSayac;  
.................... tmr1_time_t tmr1_time;    
....................                             
.................... /*void setupWDT(void){                    
....................    WDTCON_SWDTEN = 1;                    
....................    //LOAD_TBL_PTR(0x300003);   
....................    EECON1_EEPGD = 1;   // Point to flash program memory 
....................    EECON1_CFGS  = 0;    // Access flash memory 
....................    EECON1_WREN  = 1;    // Enable write to memory 
....................    EECON1_FREE  = 1;    // Enable Erase operation            
....................    EECON2 = 0x55;                                                  
....................    EECON2 = 0xAA;  
....................    EECON1_WR = 1;      // Clear the flash                                    
.................... } */                       
....................                          
....................  
.................... void setup(void){  
....................  
....................    //Setup Osilator 
....................    IRCF2 = 1; 
*
0344:  BSF    FD3.6
....................    IRCF1 = 1; 
0346:  BSF    FD3.5
....................    IRCF0 = 1;   
0348:  BSF    FD3.4
....................     
....................    //A0 cikis olarak ayarlandi 
....................    TRISA = 0x01; 
034A:  MOVLW  01
034C:  MOVWF  F92
....................    PORTA_0 =0;                        
034E:  BCF    F80.0
....................    //D ve P portlari cikis olarak ayarlanip sifirlandi. 
....................    TRISB = 0x01;                  
0350:  MOVWF  F93
....................    TRISD = 0x00; 
0352:  CLRF   F95
....................    TRISE = 0x00; 
0354:  CLRF   F96
....................    PORTB = 0x00;                                                       
0356:  CLRF   F81
....................    PORTD = 0x00; 
0358:  CLRF   F8C
....................    PORTE = 0x00;  
035A:  CLRF   F84
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
035C:  CLRF   18
....................  
....................    // Kesmelere izin verildi 
....................    ADCON1= 0x00; 
035E:  CLRF   FC1
....................    RCON_IPEN = 1;                                               
0360:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 1; 
0362:  BSF    FF2.7
....................    INTCON_PEIE = 1; 
0364:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
0366:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
0368:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
036A:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit 
036C:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
036E:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
0370:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
0372:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
0374:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
0376:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
0378:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
037A:  MOVLW  F8
037C:  MOVWF  FCF
....................    TMR1L = 0x30; // |||65436 decimal sayisina esit. 
037E:  MOVLW  30
0380:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit                                            
0382:  BSF    FCD.0
0384:  GOTO   0120 (RETURN)
.................... }                                         
....................                                                       
....................                                                                                                                   
.................... void printOn2x16(){  
....................    delayUsFun(40);                                                                             
*
03F2:  MOVLW  28
03F4:  MOVWF  xC8
03F6:  RCALL  0388
....................    twoLinesBCDMode(); 
03F8:  BRA    00F6
....................    LinesActive();   
03FA:  BRA    03CA
....................    lcdCursorOff(); 
03FC:  BRA    03D4
....................    lcdShiftRight();                
03FE:  BRA    03DE
....................    lcdClear();       
0400:  BRA    03E8
....................    memcpy(strLCD, "INFORMELEKTRONIKAR-GE    STAJYER", 32); 
0402:  CLRF   FEA
0404:  MOVLW  A3
0406:  MOVWF  FE9
0408:  MOVFF  FF2,C4
040C:  BCF    FF2.7
040E:  MOVLW  20
0410:  MOVWF  01
0412:  CLRF   FF7
0414:  MOVLW  00
0416:  RCALL  022E
0418:  TBLRD*-
041A:  TBLRD*+
041C:  MOVFF  FF5,FEE
0420:  DECFSZ 01,F
0422:  BRA    041A
0424:  BTFSC  xC4.7
0426:  BSF    FF2.7
....................    countLCDChar=0;  
0428:  CLRF   xC3
042A:  GOTO   0122 (RETURN)
....................    // LCD_Custom_CHAR(7, legrandLCDCharacter); 
....................    //LCD_Custom_CHAR(6, stickManLCDCharacter);                                
.................... }                
....................  
.................... void WDTreset(void){          
....................    #asm                 
*
04CA:  CLRWDT
....................    CLRWDT 
....................    #endasm                                  
04CC:  GOTO   0126 (RETURN)
.................... }                 
....................                                                                                              
....................                                                                      
.................... void rs232Case(){ 
....................    if(RCIF_PIR1)  
*
072C:  BTFSS  F9E.5
072E:  BRA    0732
....................       rs232t();                                                         
0730:  BRA    05DE
....................    if(noKbHit_count>=1)    
0732:  MOVF   xA0,W
0734:  SUBLW  00
0736:  BC    073A
....................       unUSARTF.stUSARTF.noKbhit=1;    
0738:  BSF    xA2.0
....................                                                                             
....................    switch (switchTerminal_position){   
073A:  MOVF   xA1,W
073C:  BZ    0750
073E:  XORLW  01
0740:  BZ    075E
0742:  XORLW  03
0744:  BZ    0792
0746:  XORLW  01
0748:  BZ    07C8
074A:  XORLW  07
074C:  BZ    07FE
074E:  BRA    083A
....................       case 0: //              
....................       if(unUSARTF.stUSARTF.enter_flag && unUSARTF.stUSARTF.noKbhit){  
0750:  BTFSS  xA2.1
0752:  BRA    075C
0754:  BTFSS  xA2.0
0756:  BRA    075C
....................          switchTerminal_position=1;                                                               
0758:  MOVLW  01
075A:  MOVWF  xA1
....................       }    
....................       break;                                   
075C:  BRA    083C
....................       case 1: // MEVCUT METIN:                                                      
....................       if(TXIF_PIR1 && unUSARTF.stUSARTF.terminal_text1_flag==0){  
075E:  BTFSS  F9E.4
0760:  BRA    0790
0762:  BTFSC  xA2.3
0764:  BRA    0790
....................          rs232t_txText(0,terminal_text1_Count);                                        
0766:  CLRF   xC4
0768:  MOVFF  98,C5
076C:  RCALL  0692
....................          if(terminal_text1_Count>=terminal_text1_size-1){ 
076E:  MOVLW  01
0770:  SUBWF  x9C,W
0772:  SUBWF  x98,W
0774:  BNC   078E
....................             unUSARTF.stUSARTF.terminal_text1_flag=1; 
0776:  BSF    xA2.3
....................             switchTerminal_position=2; 
0778:  MOVLW  02
077A:  MOVWF  xA1
....................             memset(txData, 0, sizeof(txData));  
077C:  CLRF   FEA
077E:  MOVLW  3B
0780:  MOVWF  FE9
0782:  CLRF   00
0784:  CLRF   02
0786:  MOVLW  20
0788:  MOVWF  01
078A:  RCALL  05C4
....................          }else{    
078C:  BRA    0790
....................            terminal_text1_Count++;           
078E:  INCF   x98,F
....................          }  
....................       }                                 
....................       break; 
0790:  BRA    083C
....................       case 2: // Lutfen bir yazi giriniz                                          
....................       if(TXIF_PIR1 && unUSARTF.stUSARTF.terminal_text4_flag==0){  
0792:  BTFSS  F9E.4
0794:  BRA    07C6
0796:  BTFSC  xA2.6
0798:  BRA    07C6
....................          rs232t_txText(3,terminal_text4_Count);                                        
079A:  MOVLW  03
079C:  MOVWF  xC4
079E:  MOVFF  9B,C5
07A2:  RCALL  0692
....................          if(terminal_text4_Count>=terminal_text4_size-1){ 
07A4:  MOVLW  01
07A6:  SUBWF  x9F,W
07A8:  SUBWF  x9B,W
07AA:  BNC   07C4
....................             unUSARTF.stUSARTF.terminal_text4_flag=1; 
07AC:  BSF    xA2.6
....................             switchTerminal_position=3; 
07AE:  MOVLW  03
07B0:  MOVWF  xA1
....................             memset(txData, 0, sizeof(txData)); 
07B2:  CLRF   FEA
07B4:  MOVLW  3B
07B6:  MOVWF  FE9
07B8:  CLRF   00
07BA:  CLRF   02
07BC:  MOVLW  20
07BE:  MOVWF  01
07C0:  RCALL  05C4
....................          }else{    
07C2:  BRA    07C6
....................             terminal_text4_Count++;               
07C4:  INCF   x9B,F
....................          }                
....................       }  
....................       break;           
07C6:  BRA    083C
....................       case 3: // LCD TEXT   
....................       if(TXIF_PIR1 && unUSARTF.stUSARTF.terminal_text2_flag==0){  
07C8:  BTFSS  F9E.4
07CA:  BRA    07FC
07CC:  BTFSC  xA2.4
07CE:  BRA    07FC
....................          rs232t_txText(1,terminal_text2_Count);                                        
07D0:  MOVLW  01
07D2:  MOVWF  xC4
07D4:  MOVFF  99,C5
07D8:  RCALL  0692
....................          if(terminal_text2_Count>=terminal_text2_size-1){ 
07DA:  MOVLW  01
07DC:  SUBWF  x9D,W
07DE:  SUBWF  x99,W
07E0:  BNC   07FA
....................             unUSARTF.stUSARTF.terminal_text2_flag=1; 
07E2:  BSF    xA2.4
....................             switchTerminal_position=0;    
07E4:  CLRF   xA1
....................             unUSARTF.stUSARTF.enter_flag=0;           
07E6:  BCF    xA2.1
....................             memset(txData, 0, sizeof(txData));     
07E8:  CLRF   FEA
07EA:  MOVLW  3B
07EC:  MOVWF  FE9
07EE:  CLRF   00
07F0:  CLRF   02
07F2:  MOVLW  20
07F4:  MOVWF  01
07F6:  RCALL  05C4
....................          }else{  
07F8:  BRA    07FC
....................             terminal_text2_Count++;  
07FA:  INCF   x99,F
....................          }                                             
....................       }                                                
....................       break;    
07FC:  BRA    083C
....................                                                                 
....................       case 4: // Limit Asildi                 
....................       if(TXIF_PIR1 && unUSARTF.stUSARTF.terminal_text3_flag==0 && unUSARTF.stUSARTF.recieve_exceed){  
07FE:  BTFSS  F9E.4
0800:  BRA    0838
0802:  BTFSC  xA2.5
0804:  BRA    0838
0806:  BTFSS  xA2.2
0808:  BRA    0838
....................          rs232t_txText(2,terminal_text3_Count);                                        
080A:  MOVLW  02
080C:  MOVWF  xC4
080E:  MOVFF  9A,C5
0812:  RCALL  0692
....................          if(terminal_text3_Count>=terminal_text3_size-1){       
0814:  MOVLW  01
0816:  SUBWF  x9E,W
0818:  SUBWF  x9A,W
081A:  BNC   0836
....................             unUSARTF.stUSARTF.terminal_text3_flag=1; 
081C:  BSF    xA2.5
....................             unUSARTF.stUSARTF.recieve_exceed=0;       
081E:  BCF    xA2.2
....................             memset(txData, 0, sizeof(txData));                                                                                         
0820:  CLRF   FEA
0822:  MOVLW  3B
0824:  MOVWF  FE9
0826:  CLRF   00
0828:  CLRF   02
082A:  MOVLW  20
082C:  MOVWF  01
082E:  RCALL  05C4
....................             terminal_text3_Count=0;  
0830:  CLRF   x9A
....................             switchTerminal_position=0;                  
0832:  CLRF   xA1
....................          }else{    
0834:  BRA    0838
....................             terminal_text3_Count++; 
0836:  INCF   x9A,F
....................          }  
....................       }    
....................       break;                                                
0838:  BRA    083C
....................     
....................       default:           
....................       switchTerminal_position=0; 
083A:  CLRF   xA1
....................    } 
083C:  GOTO   0144 (RETURN)
.................... }                                  
....................  
.................... #INT_TIMER1                                                            
.................... void interrupt(){  
....................  
....................    TMR1H = 0xF8; //Tasma saayci| 
*
02AC:  MOVLW  F8
02AE:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.  
02B0:  MOVLW  30
02B2:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor. 
02B4:  BCF    F9E.0
....................    iSayac++; 
02B6:  INCF   16,F
02B8:  BTFSC  FD8.2
02BA:  INCF   17,F
....................    if (iSayac % 20 == 0) //20ms 
02BC:  MOVFF  17,CB
02C0:  MOVFF  16,CA
02C4:  CLRF   xCD
02C6:  MOVLW  14
02C8:  MOVWF  xCC
02CA:  RCALL  026A
02CC:  MOVFF  00,CA
02D0:  MOVFF  03,CB
02D4:  MOVF   xCA,F
02D6:  BNZ   02DE
02D8:  MOVF   xCB,F
02DA:  BNZ   02DE
....................       tmr1_time.tmr1_flags._20ms = true;              
02DC:  BSF    18.1
....................    if(iSayac % 50 == 0) //50ms  
02DE:  MOVFF  17,CB
02E2:  MOVFF  16,CA
02E6:  CLRF   xCD
02E8:  MOVLW  32
02EA:  MOVWF  xCC
02EC:  RCALL  026A
02EE:  MOVFF  00,CA
02F2:  MOVFF  03,CB
02F6:  MOVF   xCA,F
02F8:  BNZ   0300
02FA:  MOVF   xCB,F
02FC:  BNZ   0300
....................       tmr1_time.tmr1_flags._50ms = true; 
02FE:  BSF    18.2
....................    if(iSayac % 200 == 0) //200ms                 
0300:  MOVFF  17,CB
0304:  MOVFF  16,CA
0308:  CLRF   xCD
030A:  MOVLW  C8
030C:  MOVWF  xCC
030E:  RCALL  026A
0310:  MOVFF  00,CA
0314:  MOVFF  03,CB
0318:  MOVF   xCA,F
031A:  BNZ   0322
031C:  MOVF   xCB,F
031E:  BNZ   0322
....................       tmr1_time.tmr1_flags._200ms = true;  
0320:  BSF    18.4
....................    if(iSayac > 1000&&STATUS){   // 1 Saniye  
0322:  MOVF   17,W
0324:  SUBLW  02
0326:  BC    033E
0328:  XORLW  FF
032A:  BNZ   0332
032C:  MOVF   16,W
032E:  SUBLW  E8
0330:  BC    033E
0332:  MOVF   1A,F
0334:  BZ    033E
....................       tmr1_time.tmr1_flags._1000ms = true;   
0336:  BSF    18.6
....................       iSayac = 0;    
0338:  CLRF   17
033A:  CLRF   16
....................       noKbHit_count++;   
033C:  INCF   xA0,F
....................    }    
.................... }    
....................                      
033E:  BCF    F9E.0
0340:  GOTO   0054
.................... #ORG 0x0100,0x0200                                                                     
.................... void main(){                                  
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  MOVLW  70
0108:  MOVWF  FD3
010A:  MOVF   FD3,W
010C:  BCF    F94.0
010E:  BSF    F8B.0
0110:  CLRF   1A
0112:  MOVF   FC1,W
0114:  ANDLW  C0
0116:  IORLW  0F
0118:  MOVWF  FC1
011A:  MOVLW  07
011C:  MOVWF  FB4
....................    setup ();                                     
011E:  BRA    0344
....................    printOn2x16();                              
0120:  BRA    03F2
....................    USART_Init(); 
0122:  BRA    042E
....................      while (TRUE){         
....................       WDTreset();                                          
0124:  BRA    04CA
....................       if(tmr1_time.tmr1_flags._200ms){               
0126:  BTFSS  18.4
0128:  BRA    012E
....................          tmr1_time.tmr1_flags._200ms = false;  
012A:  BCF    18.4
....................          LCD_String();   
012C:  BRA    051A
....................       }                   
....................       if(tmr1_time.tmr1_flags._50ms){ 
012E:  BTFSS  18.2
0130:  BRA    013C
....................          tmr1_time.tmr1_flags._50ms = false; 
0132:  BCF    18.2
....................          button_debounce (PORTB, 0);  
0134:  MOVFF  F81,C4
0138:  CLRF   xC5
013A:  BRA    0574
....................       }   
....................       if(tmr1_time.tmr1_flags._20ms){ 
013C:  BTFSS  18.1
013E:  BRA    0142
....................          tmr1_time.tmr1_flags._20ms = false; 
0140:  BCF    18.1
....................           
....................       }  
....................       rs232Case();    
0142:  BRA    072C
0144:  BRA    0124
....................    }                                                         
.................... }  
....................                     
0146:  SLEEP 

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 011E   PUT BROWNOUT BORV21 WDT WDT1
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
