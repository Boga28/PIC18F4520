CCS PCH C Compiler, Version 5.015, 5967               31-Jul-23 16:15

               Filename:   C:\18F4520\CCS\1-Wire-DS1990-f5+Akbil-LCD.pdsprj\main.lst

               ROM used:   3810 bytes (12%)
                           Largest free fragment is 28326
               RAM used:   161 (10%) at main() level
                           189 (12%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   060A
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir. 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0096:  CLRF   01
0098:  CLRF   02
009A:  CLRF   00
009C:  CLRF   03
009E:  MOVF   xBB,W
00A0:  BNZ   00A6
00A2:  MOVF   xBA,W
00A4:  BZ    00D6
00A6:  MOVLW  10
00A8:  MOVWF  xBC
00AA:  BCF    FD8.0
00AC:  RLCF   xB8,F
00AE:  RLCF   xB9,F
00B0:  RLCF   00,F
00B2:  RLCF   03,F
00B4:  MOVF   xBB,W
00B6:  SUBWF  03,W
00B8:  BNZ   00BE
00BA:  MOVF   xBA,W
00BC:  SUBWF  00,W
00BE:  BNC   00CE
00C0:  MOVF   xBA,W
00C2:  SUBWF  00,F
00C4:  BTFSS  FD8.0
00C6:  DECF   03,F
00C8:  MOVF   xBB,W
00CA:  SUBWF  03,F
00CC:  BSF    FD8.0
00CE:  RLCF   01,F
00D0:  RLCF   02,F
00D2:  DECFSZ xBC,F
00D4:  BRA    00AA
00D6:  GOTO   063C (RETURN)
*
0402:  MOVFF  FF2,0D
0406:  BCF    FF2.7
0408:  CLRF   FF7
040A:  ADDLW  1C
040C:  MOVWF  FF6
040E:  MOVLW  04
0410:  ADDWFC FF7,F
0412:  TBLRD*+
0414:  MOVF   FF5,W
0416:  BTFSC  0D.7
0418:  BSF    FF2.7
041A:  RETURN 0
041C:  DATA 00,5E
041E:  DATA BC,E2
0420:  DATA 61,3F
0422:  DATA DD,83
0424:  DATA C2,9C
0426:  DATA 7E,20
0428:  DATA A3,FD
042A:  DATA 1F,41
042C:  DATA 9D,C3
042E:  DATA 21,7F
0430:  DATA FC,A2
0432:  DATA 40,1E
0434:  DATA 5F,01
0436:  DATA E3,BD
0438:  DATA 3E,60
043A:  DATA 82,DC
043C:  DATA 23,7D
043E:  DATA 9F,C1
0440:  DATA 42,1C
0442:  DATA FE,A0
0444:  DATA E1,BF
0446:  DATA 5D,03
0448:  DATA 80,DE
044A:  DATA 3C,62
044C:  DATA BE,E0
044E:  DATA 02,5C
0450:  DATA DF,81
0452:  DATA 63,3D
0454:  DATA 7C,22
0456:  DATA C0,9E
0458:  DATA 1D,43
045A:  DATA A1,FF
045C:  DATA 46,18
045E:  DATA FA,A4
0460:  DATA 27,79
0462:  DATA 9B,C5
0464:  DATA 84,DA
0466:  DATA 38,66
0468:  DATA E5,BB
046A:  DATA 59,07
046C:  DATA DB,85
046E:  DATA 67,39
0470:  DATA BA,E4
0472:  DATA 06,58
0474:  DATA 19,47
0476:  DATA A5,FB
0478:  DATA 78,26
047A:  DATA C4,9A
047C:  DATA 65,3B
047E:  DATA D9,87
0480:  DATA 04,5A
0482:  DATA B8,E6
0484:  DATA A7,F9
0486:  DATA 1B,45
0488:  DATA C6,98
048A:  DATA 7A,24
048C:  DATA F8,A6
048E:  DATA 44,1A
0490:  DATA 99,C7
0492:  DATA 25,7B
0494:  DATA 3A,64
0496:  DATA 86,D8
0498:  DATA 5B,05
049A:  DATA E7,B9
049C:  DATA 8C,D2
049E:  DATA 30,6E
04A0:  DATA ED,B3
04A2:  DATA 51,0F
04A4:  DATA 4E,10
04A6:  DATA F2,AC
04A8:  DATA 2F,71
04AA:  DATA 93,CD
04AC:  DATA 11,4F
04AE:  DATA AD,F3
04B0:  DATA 70,2E
04B2:  DATA CC,92
04B4:  DATA D3,8D
04B6:  DATA 6F,31
04B8:  DATA B2,EC
04BA:  DATA 0E,50
04BC:  DATA AF,F1
04BE:  DATA 13,4D
04C0:  DATA CE,90
04C2:  DATA 72,2C
04C4:  DATA 6D,33
04C6:  DATA D1,8F
04C8:  DATA 0C,52
04CA:  DATA B0,EE
04CC:  DATA 32,6C
04CE:  DATA 8E,D0
04D0:  DATA 53,0D
04D2:  DATA EF,B1
04D4:  DATA F0,AE
04D6:  DATA 4C,12
04D8:  DATA 91,CF
04DA:  DATA 2D,73
04DC:  DATA CA,94
04DE:  DATA 76,28
04E0:  DATA AB,F5
04E2:  DATA 17,49
04E4:  DATA 08,56
04E6:  DATA B4,EA
04E8:  DATA 69,37
04EA:  DATA D5,8B
04EC:  DATA 57,09
04EE:  DATA EB,B5
04F0:  DATA 36,68
04F2:  DATA 8A,D4
04F4:  DATA 95,CB
04F6:  DATA 29,77
04F8:  DATA F4,AA
04FA:  DATA 48,16
04FC:  DATA E9,B7
04FE:  DATA 55,0B
0500:  DATA 88,D6
0502:  DATA 34,6A
0504:  DATA 2B,75
0506:  DATA 97,C9
0508:  DATA 4A,14
050A:  DATA F6,A8
050C:  DATA 74,2A
050E:  DATA C8,96
0510:  DATA 15,4B
0512:  DATA A9,F7
0514:  DATA B6,E8
0516:  DATA 0A,54
0518:  DATA D7,89
051A:  DATA 6B,35
051C:  MOVFF  FF2,0D
0520:  BCF    FF2.7
0522:  CLRF   FF7
0524:  ADDLW  36
0526:  MOVWF  FF6
0528:  MOVLW  05
052A:  ADDWFC FF7,F
052C:  TBLRD*+
052E:  MOVF   FF5,W
0530:  BTFSC  0D.7
0532:  BSF    FF2.7
0534:  RETURN 0
0536:  DATA 44,45
0538:  DATA 56,49
053A:  DATA 43,45
053C:  DATA 20,55
053E:  DATA 4E,44
0540:  DATA 45,46
0542:  DATA 49,4E
0544:  DATA 45,44
0546:  DATA 00,00
0548:  MOVFF  FF2,0D
054C:  BCF    FF2.7
054E:  CLRF   FF7
0550:  ADDLW  62
0552:  MOVWF  FF6
0554:  MOVLW  05
0556:  ADDWFC FF7,F
0558:  TBLRD*+
055A:  MOVF   FF5,W
055C:  BTFSC  0D.7
055E:  BSF    FF2.7
0560:  RETURN 0
0562:  DATA 20,44
0564:  DATA 45,56
0566:  DATA 49,43
0568:  DATA 45,20
056A:  DATA 44,45
056C:  DATA 46,49
056E:  DATA 4E,45
0570:  DATA 44,20
0572:  DATA 00,00
0574:  MOVFF  FF2,0D
0578:  BCF    FF2.7
057A:  CLRF   FF7
057C:  ADDLW  8E
057E:  MOVWF  FF6
0580:  MOVLW  05
0582:  ADDWFC FF7,F
0584:  TBLRD*+
0586:  MOVF   FF5,W
0588:  BTFSC  0D.7
058A:  BSF    FF2.7
058C:  RETURN 0
058E:  DATA 49,4E
0590:  DATA 46,4F
0592:  DATA 52,4D
0594:  DATA 45,4C
0596:  DATA 45,4B
0598:  DATA 54,52
059A:  DATA 4F,4E
059C:  DATA 49,4B
059E:  DATA 41,52
05A0:  DATA 2D,47
05A2:  DATA 45,20
05A4:  DATA 20,20
05A6:  DATA 20,53
05A8:  DATA 54,41
05AA:  DATA 4A,59
05AC:  DATA 45,52
05AE:  DATA 00,00
05B0:  DATA 52,4F
05B2:  DATA 4D,25
05B4:  DATA 64,3A
05B6:  DATA 20,25
05B8:  DATA 30,32
05BA:  DATA 58,20
05BC:  DATA 25,30
05BE:  DATA 32,58
05C0:  DATA 20,25
05C2:  DATA 30,32
05C4:  DATA 58,20
05C6:  DATA 20,25
05C8:  DATA 30,32
05CA:  DATA 58,20
05CC:  DATA 20,25
05CE:  DATA 30,32
05D0:  DATA 58,20
05D2:  DATA 20,25
05D4:  DATA 30,32
05D6:  DATA 58,20
05D8:  DATA 20,25
05DA:  DATA 30,32
05DC:  DATA 58,20
05DE:  DATA 20,25
05E0:  DATA 30,32
05E2:  DATA 58,0D
05E4:  DATA 00,00
05E6:  DATA 4E,6F
05E8:  DATA 20,64
05EA:  DATA 65,76
05EC:  DATA 69,63
05EE:  DATA 65,73
05F0:  DATA 20,66
05F2:  DATA 6F,75
05F4:  DATA 6E,64
05F6:  DATA 0D,00
05F8:  DATA 4E,6F
05FA:  DATA 20,64
05FC:  DATA 65,76
05FE:  DATA 69,63
0600:  DATA 65,73
0602:  DATA 20,66
0604:  DATA 6F,75
0606:  DATA 6E,64
0608:  DATA 00,00
*
0A12:  TSTFSZ 01
0A14:  BRA    0A1C
0A16:  TSTFSZ 02
0A18:  BRA    0A1E
0A1A:  BRA    0A2A
0A1C:  INCF   02,F
0A1E:  MOVFF  00,FEE
0A22:  DECFSZ 01,F
0A24:  BRA    0A1E
0A26:  DECFSZ 02,F
0A28:  BRA    0A1E
0A2A:  RETURN 0
*
0A34:  TBLRD*+
0A36:  MOVFF  FF6,B0
0A3A:  MOVFF  FF7,B1
0A3E:  MOVF   FF5,W
0A40:  BTFSS  F9E.4
0A42:  BRA    0A40
0A44:  MOVWF  FAD
0A46:  MOVFF  B0,FF6
0A4A:  MOVFF  B1,FF7
0A4E:  DECFSZ xAF,F
0A50:  BRA    0A34
0A52:  GOTO   0DF0 (RETURN)
0A56:  MOVF   xB6,W
0A58:  CLRF   01
0A5A:  SUBWF  xB5,W
0A5C:  BC    0A64
0A5E:  MOVFF  B5,00
0A62:  BRA    0A7C
0A64:  CLRF   00
0A66:  MOVLW  08
0A68:  MOVWF  xB7
0A6A:  RLCF   xB5,F
0A6C:  RLCF   00,F
0A6E:  MOVF   xB6,W
0A70:  SUBWF  00,W
0A72:  BTFSC  FD8.0
0A74:  MOVWF  00
0A76:  RLCF   01,F
0A78:  DECFSZ xB7,F
0A7A:  BRA    0A6A
0A7C:  RETURN 0
0A7E:  MOVLW  20
0A80:  BTFSS  xB0.4
0A82:  MOVLW  30
0A84:  MOVWF  xB1
0A86:  MOVFF  AF,00
0A8A:  BTFSS  xAF.7
0A8C:  BRA    0A9E
0A8E:  COMF   00,F
0A90:  INCF   00,F
0A92:  MOVFF  00,AF
0A96:  MOVLW  2D
0A98:  MOVWF  xB1
0A9A:  BSF    xB0.7
0A9C:  BSF    xB0.0
0A9E:  MOVF   01,W
0AA0:  MOVFF  AF,B5
0AA4:  MOVLW  64
0AA6:  MOVWF  xB6
0AA8:  RCALL  0A56
0AAA:  MOVFF  00,AF
0AAE:  MOVLW  30
0AB0:  ADDWF  01,W
0AB2:  MOVWF  xB2
0AB4:  MOVFF  AF,B5
0AB8:  MOVLW  0A
0ABA:  MOVWF  xB6
0ABC:  RCALL  0A56
0ABE:  MOVLW  30
0AC0:  ADDWF  00,W
0AC2:  MOVWF  xB4
0AC4:  MOVLW  30
0AC6:  ADDWF  01,W
0AC8:  MOVWF  xB3
0ACA:  MOVFF  B1,00
0ACE:  MOVLW  30
0AD0:  SUBWF  xB2,W
0AD2:  BZ    0ADC
0AD4:  BSF    xB0.1
0AD6:  BTFSC  xB0.7
0AD8:  BSF    xB0.2
0ADA:  BRA    0B00
0ADC:  MOVFF  B1,B2
0AE0:  MOVLW  20
0AE2:  MOVWF  xB1
0AE4:  MOVLW  30
0AE6:  SUBWF  xB3,W
0AE8:  BZ    0AF2
0AEA:  BSF    xB0.0
0AEC:  BTFSC  xB0.7
0AEE:  BSF    xB0.1
0AF0:  BRA    0B00
0AF2:  BTFSS  FD8.2
0AF4:  BSF    xB0.0
0AF6:  BNZ   0B00
0AF8:  MOVFF  B2,B3
0AFC:  MOVLW  20
0AFE:  MOVWF  xB2
0B00:  BTFSC  xB0.2
0B02:  BRA    0B0E
0B04:  BTFSC  xB0.1
0B06:  BRA    0B16
0B08:  BTFSC  xB0.0
0B0A:  BRA    0B1E
0B0C:  BRA    0B26
0B0E:  MOVF   xB1,W
0B10:  BTFSS  F9E.4
0B12:  BRA    0B10
0B14:  MOVWF  FAD
0B16:  MOVF   xB2,W
0B18:  BTFSS  F9E.4
0B1A:  BRA    0B18
0B1C:  MOVWF  FAD
0B1E:  MOVF   xB3,W
0B20:  BTFSS  F9E.4
0B22:  BRA    0B20
0B24:  MOVWF  FAD
0B26:  MOVF   xB4,W
0B28:  BTFSS  F9E.4
0B2A:  BRA    0B28
0B2C:  MOVWF  FAD
0B2E:  GOTO   0DFA (RETURN)
0B32:  BTFSC  xB0.7
0B34:  BRA    0B56
0B36:  MOVLW  0F
0B38:  MOVWF  00
0B3A:  SWAPF  xAF,W
0B3C:  ANDWF  00,F
0B3E:  MOVLW  0A
0B40:  SUBWF  00,W
0B42:  BC    0B4A
0B44:  MOVLW  30
0B46:  ADDWF  00,F
0B48:  BRA    0B4E
0B4A:  MOVF   xB0,W
0B4C:  ADDWF  00,F
0B4E:  MOVF   00,W
0B50:  BTFSS  F9E.4
0B52:  BRA    0B50
0B54:  MOVWF  FAD
0B56:  MOVLW  0F
0B58:  ANDWF  xAF,F
0B5A:  MOVLW  0A
0B5C:  SUBWF  xAF,W
0B5E:  BC    0B64
0B60:  MOVLW  30
0B62:  BRA    0B68
0B64:  BCF    xB0.7
0B66:  MOVF   xB0,W
0B68:  ADDWF  xAF,F
0B6A:  MOVF   xAF,W
0B6C:  BTFSS  F9E.4
0B6E:  BRA    0B6C
0B70:  MOVWF  FAD
0B72:  RETURN 0
0B74:  TBLRD*+
0B76:  MOVF   FF5,F
0B78:  BZ    0B94
0B7A:  MOVFF  FF6,A5
0B7E:  MOVFF  FF7,A6
0B82:  MOVF   FF5,W
0B84:  BTFSS  F9E.4
0B86:  BRA    0B84
0B88:  MOVWF  FAD
0B8A:  MOVFF  A5,FF6
0B8E:  MOVFF  A6,FF7
0B92:  BRA    0B74
0B94:  GOTO   0EDA (RETURN)
*
103E:  MOVFF  9F,FEA
1042:  MOVFF  9E,FE9
1046:  MOVFF  A7,FEF
104A:  INCF   FE9,F
104C:  BTFSC  FD8.2
104E:  INCF   FEA,F
1050:  CLRF   FEF
1052:  INCF   x9E,F
1054:  BTFSC  FD8.2
1056:  INCF   x9F,F
1058:  GOTO   1070 (RETURN)
105C:  TBLRD*+
105E:  MOVF   FF5,F
1060:  BZ    107A
1062:  MOVFF  FF6,A5
1066:  MOVFF  FF7,A6
106A:  MOVFF  FF5,A7
106E:  BRA    103E
1070:  MOVFF  A5,FF6
1074:  MOVFF  A6,FF7
1078:  BRA    105C
107A:  GOTO   1114 (RETURN)
....................  
.................... #list 
....................  
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanýr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       Â· LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       Â· WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini saðlar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       Â· PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin içine yükleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       Â· PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       Â· BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       Â· INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       Â· NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */                                
....................                                                          
.................... #FUSES NOWDT, WDT8, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC  
.................... #use delay (internal=8MHz)                     
*
07C2:  MOVLW  09
07C4:  SUBWF  xAF,F
07C6:  BNC   07DE
07C8:  CLRF   FEA
07CA:  MOVLW  AF
07CC:  MOVWF  FE9
07CE:  BCF    FD8.0
07D0:  RRCF   FEF,F
07D2:  MOVF   FEF,W
07D4:  BZ    07DE
07D6:  BRA    07DA
07D8:  NOP   
07DA:  DECFSZ FEF,F
07DC:  BRA    07D8
07DE:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7) 
.................... //#use i2c(Master, Fast=100000, sda=PIN_C4, scl=PIN_C3, SMBUS)             
....................                                                                       
.................... #include "definitions.h"     
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "main.h"                                                
.................... #ifndef MAIN_H      
.................... #define MAIN_H  
.................... #define DELAY 500  
....................  
.................... void WDTreset(void);   
....................                      
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"    
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1           
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0   
.................... #bit  PORTB_7=PORTB.7   
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................  
.................... //   ################   D18B20/D1990A One-Wire Connection  #################  //                            
.................... #byte LATC    = 0x0F8B   
.................... #bit  LATC_0  = LATC.0   
.................... #bit  TRISC_0 = TRISC.0        
.................... #bit  PORTC_0 = PORTC.0     
....................  
....................  
....................  
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h"                                                                                          
.................... #ifndef INIT_H 
.................... #define INIT_H       
....................  
.................... extern uint16_t iSayac;  
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _2ms    : 1;  //bit:0, 2ms  
....................       uint8_t _20ms   : 1;  //bit:1, 20ms  
....................       uint8_t _50ms   : 1;  //bit:2, 50ms  
....................       uint8_t _100ms  : 1;  //bit:3, 100ms     
....................       uint8_t _200ms  : 1;  //bit:4, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:5, 500ms  
....................       uint8_t _1000ms : 1;  //bit:6, 1000ms  
....................       uint8_t _500us  : 1;  //bit:7, 500us 
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t tmr1_time;     
....................  
....................  
....................  
....................  
....................                                                 
.................... #endif //INIT_H                               
....................  
.................... #include "lcd.h"  
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
....................  
....................                                                              
.................... #include "lcd.c"                                  
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1           
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0   
.................... #bit  PORTB_7=PORTB.7   
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................  
.................... //   ################   D18B20/D1990A One-Wire Connection  #################  //                            
.................... #byte LATC    = 0x0F8B   
.................... #bit  LATC_0  = LATC.0   
.................... #bit  TRISC_0 = TRISC.0        
.................... #bit  PORTC_0 = PORTC.0     
....................  
....................  
....................  
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "delayms.h"  
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................                  
....................                
.................... /*Hex Code   LCD Ekran Karsiligi  
....................  Initialize Lcd in 4-bit mode               0x02 
.................... 1   Function Set: 8-bit, 1 Line, 5×7 Dots   0x30   48                                              
.................... 2   Function Set: 8-bit, 2 Line, 5×7 Dots   0x38   56                            
.................... 3   Function Set: 4-bit, 1 Line, 5×7 Dots   0x20   32 
.................... 4   Function Set: 4-bit, 2 Line, 5×7 Dots   0x28   40  
.................... 0F   LCD acik, Imlec acik 
.................... 01   Ekrani Temizle                                 
.................... 02   Satir Basina Dön            
.................... 04   Imleci Sola Kaydir 
.................... 06   Imleci Saga Kaydir 
.................... 05   Ekrani Saga Kaydir 
.................... 07   Ekrani Sola Kaydir 
.................... 0E   Ekran Acik, Imleç Yanip Sonuyor 
.................... 80   Imleci Ilk Satirin Basinda Konumlandir 
.................... C0   Imleci Ikinci Satirin Basinda Konumlandir         
.................... 3C   Ikinci Satiri Etkinlestir                                                     
.................... 08   Ekran Kapali, Imleç Kapali              
.................... OC   Ekran Acik, Imlec Kapali*/   
....................                                             
.................... uchar_t strLCD[32]; 
.................... uint8_t countLCDChar; 
.................... uchar_t LCDW1SecFlag; 
....................                                          
.................... /*LCD (CHIP: HD44780), COMMAND MODE*/  
.................... void dis_cmd(uchar_t cmdout){  
....................    PORTD=cmdout;      //Send command to lcdport=PORTB 
*
00E8:  MOVFF  A3,F8C
....................    PORTE_RS=0;                   
00EC:  BCF    F84.0
....................    PORTE_E=1;                
00EE:  BSF    F84.1
....................    delayUsFun(1); 
00F0:  MOVLW  01
00F2:  MOVWF  xA5
00F4:  RCALL  00DA
....................    PORTE_E=0;                               
00F6:  BCF    F84.1
00F8:  RETURN 0
.................... }                                   
....................  
....................  
....................  
.................... void lcdcmd(uchar_t cmd_value){          
....................    uchar_t cmd_value1;                              
....................    cmd_value1 = (cmd_value & 0xF0);      // Mask lower nibble because RB4-RB7 pins are being used    
*
06A6:  MOVF   xA1,W
06A8:  ANDLW  F0
06AA:  MOVWF  xA2
....................    dis_cmd(cmd_value1);                   // Send to LCD 
06AC:  MOVFF  A2,A3
06B0:  RCALL  00E8
....................    cmd_value1 = ((cmd_value<<4) & 0xF0);  // Shift 4-bit and mask 
06B2:  SWAPF  xA1,W
06B4:  MOVWF  00
06B6:  MOVLW  F0
06B8:  ANDWF  00,F
06BA:  MOVF   00,W
06BC:  ANDLW  F0
06BE:  MOVWF  xA2
....................    dis_cmd(cmd_value1);                   // Send to LCD 
06C0:  MOVFF  A2,A3
06C4:  RCALL  00E8
06C6:  RETURN 0
.................... } 
....................  // 2 lines are active.              
.................... void twoLinesBCDMode(){  
....................    lcdcmd(0x02); 
06C8:  MOVLW  02
06CA:  MOVWF  xA1
06CC:  RCALL  06A6
06CE:  GOTO   0702 (RETURN)
.................... } 
....................                         
.................... // 2 lines are active. BCD MODE 
.................... void LinesActive(){  
....................    lcdcmd(0x28);                
06D2:  MOVLW  28
06D4:  MOVWF  xA1
06D6:  RCALL  06A6
06D8:  GOTO   0704 (RETURN)
.................... }                          
.................... // LCD screen clear.                   
.................... void lcdClear(){ 
....................    lcdcmd(0x01);                   
*
06F0:  MOVLW  01
06F2:  MOVWF  xA1
06F4:  RCALL  06A6
06F6:  GOTO   070A (RETURN)
.................... }                   
.................... // Go to first line. 
.................... void lcdGoToFirstLine(){  
....................    lcdcmd(0x80); 
*
073A:  MOVLW  80
073C:  MOVWF  xA1
073E:  RCALL  06A6
0740:  GOTO   078A (RETURN)
.................... }                                  
.................... // Go to second line.                        
.................... void lcdGoToSecondLine(){ 
....................    lcdcmd(0xC0); 
0744:  MOVLW  C0
0746:  MOVWF  xA1
0748:  RCALL  06A6
074A:  GOTO   0792 (RETURN)
.................... }                        
.................... // Shift cursor to right. 
.................... void lcdShiftRight(){   
....................    lcdcmd(0x06);                                                     
*
06E6:  MOVLW  06
06E8:  MOVWF  xA1
06EA:  RCALL  06A6
06EC:  GOTO   0708 (RETURN)
.................... }                                           
.................... // Display on, Cursor on              
.................... void lcdCursorOn(){                  
....................    lcdcmd(0x0E); 
.................... }                                      
.................... //Display off, Cursor off 
.................... void lcdCursorOff(){                                             
....................    lcdcmd(0x0C);                             
*
06DC:  MOVLW  0C
06DE:  MOVWF  xA1
06E0:  RCALL  06A6
06E2:  GOTO   0706 (RETURN)
.................... }                              
....................   
.................... void dis_data(uchar_t dataout) {  
....................    PORTD=dataout;   //Send data to lcdport=PORTB 
*
074E:  MOVFF  A4,F8C
....................    PORTE_RS=1;                   
0752:  BSF    F84.0
....................    PORTE_E=1;                          
0754:  BSF    F84.1
....................    delayUsFun(1); 
0756:  MOVLW  01
0758:  MOVWF  xA5
075A:  RCALL  00DA
....................    PORTE_E=0;   
075C:  BCF    F84.1
075E:  RETURN 0
....................    //PORTD=0x00; 
....................    //while(test_bit(PORTD,7));           
.................... }   
.................... /*DATA MODE*/   
.................... void lcddata(uchar_t text){  
....................    uchar_t data;                                                                 
....................    data=(text & 0xF0);         
0760:  MOVF   xA2,W
0762:  ANDLW  F0
0764:  MOVWF  xA3
....................    dis_data(data);     
0766:  MOVFF  A3,A4
076A:  RCALL  074E
....................    data=((text<<4)&0xF0);      
076C:  SWAPF  xA2,W
076E:  MOVWF  00
0770:  MOVLW  F0
0772:  ANDWF  00,F
0774:  MOVF   00,W
0776:  ANDLW  F0
0778:  MOVWF  xA3
....................    dis_data(data);                  
077A:  MOVFF  A3,A4
077E:  RCALL  074E
0780:  GOTO   07B0 (RETURN)
.................... }                                
.................... void LCD_String(){  
....................    if(countLCDChar==0)  
0784:  MOVF   39,F
0786:  BNZ   078A
....................       lcdGoToFirstLine(); 
0788:  BRA    073A
....................    if(countLCDChar==16)   
078A:  MOVF   39,W
078C:  SUBLW  10
078E:  BNZ   0792
....................       lcdGoToSecondLine();    
0790:  BRA    0744
....................    if(countLCDChar<=31){  
0792:  MOVF   39,W
0794:  SUBLW  1F
0796:  BNC   07B4
....................       lcddata(strLCD[countLCDChar]); 
0798:  CLRF   03
079A:  MOVF   39,W
079C:  ADDLW  19
079E:  MOVWF  FE9
07A0:  MOVLW  00
07A2:  ADDWFC 03,W
07A4:  MOVWF  FEA
07A6:  MOVFF  FEF,A1
07AA:  MOVFF  A1,A2
07AE:  BRA    0760
....................       countLCDChar++;   
07B0:  INCF   39,F
....................    }else{    
07B2:  BRA    07B8
....................       LCDW1SecFlag=0; 
07B4:  CLRF   3A
....................       countLCDChar=0; 
07B6:  CLRF   39
....................    }                  
07B8:  GOTO   0144 (RETURN)
.................... }  
....................  
....................  
.................... void LCD_Custom_Char(uchar_t loc, uchar_t *msg){ 
....................     uchar_t i; 
....................     if(loc<8) 
....................     { 
....................      lcdcmd(0x40 + (loc*8));    /* Command 0x40 and onwards forces the device to point CGRAM address */ 
....................      for(i=0;i<8;i++)          /* Write 8 byte for generation of 1 character */ 
....................         lcddata(msg[i]);       
....................     }                        
.................... } 
....................  
....................                                           
....................  
....................       
....................  
.................... #include "delayms.c" 
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs){  // Delay function - generates a delay of specified msecs 
....................    uint16_t i; 
....................    uint8_t j;  
....................    for(i=0;i<=msecs;i++) 
....................    for(j=0;j<205;j++); /*This count Provide delay of 1 ms for 8MHz Frequency */                              
.................... }        
....................  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
*
00DA:  CLRF   xA6
00DC:  MOVF   xA6,W
00DE:  SUBWF  xA5,W
00E0:  BNC   00E6
00E2:  INCF   xA6,F
00E4:  BRA    00DC
....................     }                                
00E6:  RETURN 0
.................... }   
....................  
....................  
.................... #include "1wire.c" 
.................... #include "1wire.h"      
.................... #ifndef ONE_WIRE_H                                  
.................... #define ONE_WIRE_H   
....................                                                                          
....................       
.................... void onewire_reset();   
.................... void onewire_write(uchar_t);  
.................... uint8_t onewire_read();                              
.................... void OneWireLow();           
.................... void OneWireRelease();  
....................                                                 
.................... // SEARCH ROOM 
.................... const uchar_t dscrc_table[] = { //static 
.................... 0, 94,188,226, 97, 63,221,131,194,156,126, 32,163,253, 31, 65, 
.................... 157,195, 33,127,252,162, 64, 30, 95, 1,227,189, 62, 96,130,220, 
.................... 35,125,159,193, 66, 28,254,160,225,191, 93, 3,128,222, 60, 98, 
.................... 190,224, 2, 92,223,129, 99, 61,124, 34,192,158, 29, 67,161,255, 
.................... 70, 24,250,164, 39,121,155,197,132,218, 56,102,229,187, 89, 7, 
.................... 219,133,103, 57,186,228, 6, 88, 25, 71,165,251,120, 38,196,154, 
.................... 101, 59,217,135, 4, 90,184,230,167,249, 27, 69,198,152,122, 36, 
.................... 248,166, 68, 26,153,199, 37,123, 58,100,134,216, 91, 5,231,185, 
.................... 140,210, 48,110,237,179, 81, 15, 78, 16,242,172, 47,113,147,205, 
.................... 17, 79,173,243,112, 46,204,146,211,141,111, 49,178,236, 14, 80, 
.................... 175,241, 19, 77,206,144,114, 44,109, 51,209,143, 12, 82,176,238, 
.................... 50,108,142,208, 83, 13,239,177,240,174, 76, 18,145,207, 45,115, 
.................... 202,148,118, 40,171,245, 23, 73, 8, 86,180,234,105, 55,213,139, 
.................... 87, 9,235,181, 54,104,138,212,149,203, 41,119,244,170, 72, 22, 
.................... 233,183, 85, 11,136,214, 52,106, 43,117,151,201, 74, 20,246,168, 
.................... 116, 42,200,150, 21, 75,169,247,182,232, 10, 84,215,137,107, 53}; 
....................  
....................  
.................... extern uchar_t i;     
....................  
.................... // global search state 
.................... extern uchar_t ROM_NO[8];                              
.................... extern uint8_t LastDiscrepancy; 
.................... extern uint8_t LastFamilyDiscrepancy; 
.................... extern uint8_t LastDeviceFlag; 
.................... extern uchar_t crc8;    
....................  
.................... uchar_t docrc8(uchar_t );   
....................  
.................... unsigned short Ow_Read_Bit(); 
.................... void Ow_Write_One();    
.................... void Ow_Write_Zero(); 
....................  
.................... uint8_t Ow_Reset(); 
....................  
.................... uint8_t Ow_Search();      
.................... uint8_t Ow_First();                
.................... uint8_t Ow_Next(); 
.................... void Ow_Target_Setup(uchar_t ); 
.................... void Ow_Family_Skip_Setup(); 
....................  
....................  
.................... #endif ONE_WIRE_H 
....................  
.................... #ifndef ONE_WIRE_C 
.................... #define ONE_WIRE_C  
....................      
....................  
.................... #define ONE_WIRE_PIN PIN_C0 
....................                                  
....................  
.................... uchar_t i;                  
....................  
....................                        
.................... // global search state 
.................... uchar_t ROM_NO[8];                                   
.................... uint8_t LastDiscrepancy; 
.................... uint8_t LastFamilyDiscrepancy; 
.................... uint8_t LastDeviceFlag; 
.................... uchar_t crc8;                            
....................                                                                                                                                                                         
.................... /*     
....................  * onewire_reset() 
....................  * Description: Initiates the one wire bus.         
....................  */ 
.................... // OK if just using a single permanently connected device                
....................                                            
.................... void onewire_reset() {  
....................    OneWireLow();  
....................    delay_us(500); 
....................    OneWireRelease();            
....................    delay_us(500);  
.................... }                                          
....................           
.................... /*                                
....................  * onewire_write(int8 data) 
....................  * Arguments: a byte of data. 
....................  * Description: writes a byte of data to the device. 
....................  */ 
.................... void onewire_write(uchar_t data) {  
....................    int8 count; 
....................     for(count = 0; count < 8; ++count) { 
*
0850:  CLRF   xAE
0852:  MOVF   xAE,W
0854:  SUBLW  07
0856:  BNC   087E
....................         OneWireLow(); 
0858:  RCALL  07BC
....................         delay_us(2);                // pull 1-wire low to initiate write time-slot. 
085A:  BRA    085C
085C:  BRA    085E
....................         if(data & 0x01)                 
085E:  BTFSS  xAD.0
0860:  BRA    0864
....................           OneWireRelease();   
0862:  RCALL  07E0
....................         delay_us(65);               // wait until end of write slot. 
0864:  MOVLW  2A
0866:  MOVWF  00
0868:  DECFSZ 00,F
086A:  BRA    0868
086C:  BRA    086E
086E:  NOP   
....................         OneWireRelease(); // set 1-wire high again, 
0870:  RCALL  07E0
....................         delay_us(2);                // for more than 1us minimum.  
0872:  BRA    0874
0874:  BRA    0876
....................         data = (data >> 1);  
0876:  BCF    FD8.0
0878:  RRCF   xAD,F
087A:  INCF   xAE,F
087C:  BRA    0852
....................     } 
087E:  GOTO   0906 (RETURN)
.................... }                                                                  
....................                                         
.................... /* 
....................  * onewire_read()         
....................  * Description: reads and returns a byte of data from the device.                                                                  
....................  */                                   
.................... uint8_t onewire_read() {  
....................     uint8_t count, data=0;                      
....................     for(count = 0; count < 8; ++count) { 
....................         OneWireLow(); 
....................         delay_us(2);                // pull 1-wire low to initiate read time-slot. 
....................         OneWireRelease();              // now let 1-wire float high, 
....................         delay_us(4);                // let device state stabilise,  
....................         if(PORTC_0)                 //ZATEN RELEASE KONUMUNA TEKRAR BIR AYARLAMAYA GEREK YOK          
....................            bit_set(data,count);    
....................         delay_us(120);              // wait until end of read slot. 
....................     }                          
....................     return data;     
.................... }     
.................... unsigned short Ow_Read_Bit(){ 
....................    unsigned short BitValue;    // Bit to be returned 
....................    OneWireLow();               // Set pin 2 in PORT E as output 
*
07E6:  RCALL  07BC
....................                                // Drive bus low   LATE.B2;   for PIC18 
....................    delay_us(2);                // Wait 2 usecs 
07E8:  BRA    07EA
07EA:  BRA    07EC
....................    OneWireRelease();                 // Release the bus 
07EC:  RCALL  07E0
....................    delay_us(5);                // Wait 5 usecs 
07EE:  MOVLW  02
07F0:  MOVWF  00
07F2:  DECFSZ 00,F
07F4:  BRA    07F2
07F6:  BRA    07F8
07F8:  NOP   
....................    BitValue = PORTC_0;         // Read bit value on pin 0 on PORT C 
07FA:  BCF    xAE.0
07FC:  BTFSC  F82.0
07FE:  BSF    xAE.0
....................    delay_us(120);               // Wait 120 usecs 
0800:  MOVLW  4F
0802:  MOVWF  00
0804:  DECFSZ 00,F
0806:  BRA    0804
0808:  BRA    080A
....................    return BitValue;            // Return bit read 
080A:  MOVLW  00
080C:  BTFSC  xAE.0
080E:  MOVLW  01
0810:  MOVWF  01
0812:  RETURN 0
.................... } 
....................                                      
.................... // Sends a '1' bit to the I/O pin  See application note 126 
.................... void Ow_Write_One(){    
....................    OneWireLow();      // Set pin 2 in PORT E as output 
*
0882:  RCALL  07BC
....................    delay_us(2);        // Drive bus low 
0884:  BRA    0886
0886:  BRA    0888
....................    OneWireRelease();   
0888:  RCALL  07E0
....................    delay_us(65);       // Wait 6 usecs        (6*4)*0.25 us 
088A:  MOVLW  2A
088C:  MOVWF  00
088E:  DECFSZ 00,F
0890:  BRA    088E
0892:  BRA    0894
0894:  NOP   
....................    OneWireRelease();  // Release the bus 
0896:  RCALL  07E0
....................    delay_us(2);      // Wait 64 usecs        (64*4)*0.25 us 
0898:  BRA    089A
089A:  BRA    089C
089C:  GOTO   09A8 (RETURN)
.................... }    
....................                   
....................                
.................... void OneWireRelease(){  
....................     PORTC_0 = 1; // Set as output  BUSDIR      
*
07E0:  BSF    F82.0
....................     TRISC_0 = 1; // Set high       BUSOUT else{      
07E2:  BSF    F94.0
07E4:  RETURN 0
.................... }  
....................  
.................... void OneWireLow(){                 
....................    PORTC_0 = 0; // Set as output  BUSDIR 
*
07BC:  BCF    F82.0
....................    TRISC_0 = 0; // Set low        BUSOUT 
07BE:  BCF    F94.0
07C0:  RETURN 0
.................... }        
....................                                                                                
....................                               
.................... uchar_t docrc8(uchar_t value){ 
....................    crc8 = dscrc_table[crc8 ^ value];    // Xor operation 
*
08BE:  MOVF   47,W
08C0:  XORWF  xAE,W
08C2:  CLRF   03
08C4:  MOVFF  FF2,AF
08C8:  BCF    FF2.7
08CA:  RCALL  0402
08CC:  BTFSC  xAF.7
08CE:  BSF    FF2.7
08D0:  MOVWF  47
....................    return crc8; 
08D2:  MOVFF  47,01
08D6:  GOTO   09CA (RETURN)
.................... }   
....................               
.................... uint8_t Ow_Reset(){ 
*
0814:  CLRF   xAD
....................    uint8_t OW=0;  
....................    OneWireLow();                             
0816:  RCALL  07BC
....................    delay_us(500); 
0818:  MOVLW  02
081A:  MOVWF  xAE
081C:  MOVLW  F8
081E:  MOVWF  xAF
0820:  RCALL  07C2
0822:  DECFSZ xAE,F
0824:  BRA    081C
....................    OneWireRelease();  
0826:  RCALL  07E0
....................    delay_us(70);        
0828:  MOVLW  2E
082A:  MOVWF  00
082C:  DECFSZ 00,F
082E:  BRA    082C
0830:  NOP   
....................    OW = Ow_Read_Bit();                 
0832:  RCALL  07E6
0834:  MOVFF  01,AD
....................    delay_us(430); 
0838:  MOVLW  02
083A:  MOVWF  xAE
083C:  MOVLW  D5
083E:  MOVWF  xAF
0840:  RCALL  07C2
0842:  DECFSZ xAE,F
0844:  BRA    083C
....................    OneWireRelease();  
0846:  RCALL  07E0
....................    return OW;  
0848:  MOVFF  AD,01
084C:  GOTO   08F0 (RETURN)
.................... }   
....................  
....................  
....................                        
.................... // Sends a '0' bit to the I/O pin   See application note 126 
.................... void Ow_Write_Zero(){    
....................    OneWireLow();     // Set pin 2 in PORT E as output 
*
08A0:  RCALL  07BC
....................                      // Drive bus low 
....................    delay_us(65);     // Wait 60 usecs 
08A2:  MOVLW  2A
08A4:  MOVWF  00
08A6:  DECFSZ 00,F
08A8:  BRA    08A6
08AA:  BRA    08AC
08AC:  NOP   
....................    OneWireRelease(); // Release the bus 
08AE:  RCALL  07E0
....................    delay_us(10);     // Wait 10 usecs 
08B0:  MOVLW  06
08B2:  MOVWF  00
08B4:  DECFSZ 00,F
08B6:  BRA    08B4
08B8:  NOP   
08BA:  GOTO   09A8 (RETURN)
.................... } 
....................     
.................... uint8_t Ow_Search(){ 
....................    uint8_t id_bit_number; 
....................    uint8_t last_zero, rom_byte_number, search_result; 
....................    uint8_t id_bit, cmp_id_bit; 
....................    uchar_t rom_byte_mask, search_direction; 
....................  
....................    // initialize for search 
....................    id_bit_number = 1; 
*
08DA:  MOVLW  01
08DC:  MOVWF  xA5
....................    last_zero = 0; 
08DE:  CLRF   xA6
....................    rom_byte_number = 0;      
08E0:  CLRF   xA7
....................    rom_byte_mask = 1; 
08E2:  MOVWF  xAB
....................    search_result = 0; 
08E4:  CLRF   xA8
....................    crc8 = 0;         
08E6:  CLRF   47
....................     
....................         // if the last call was not the last one 
....................    if (!LastDeviceFlag){  
08E8:  MOVF   46,F
08EA:  BTFSS  FD8.2
08EC:  BRA    09F0
....................       // check if there are 1-Wire device (s) 0 if the device(s) responded, 1 if no devices did 
....................       if (Ow_Reset()){  
08EE:  BRA    0814
08F0:  MOVF   01,F
08F2:  BZ    0900
....................          // reset the search 
....................          LastDiscrepancy = 0; 
08F4:  CLRF   44
....................          LastDeviceFlag = 0; 
08F6:  CLRF   46
....................          LastFamilyDiscrepancy = 0; 
08F8:  CLRF   45
....................          return 0;  
08FA:  MOVLW  00
08FC:  MOVWF  01
08FE:  BRA    0A04
....................       } 
....................         // Issue command Search_ROM 
....................         onewire_write(0xF0); 
0900:  MOVLW  F0
0902:  MOVWF  xAD
0904:  BRA    0850
....................         // loop to do the search 
....................         do{// read a bit and its complement 
....................            id_bit = OW_Read_Bit(); 
0906:  RCALL  07E6
0908:  MOVFF  01,A9
....................            cmp_id_bit = OW_Read_Bit(); 
090C:  RCALL  07E6
090E:  MOVFF  01,AA
....................            // 11 no devices on the 1-wire 
....................            // check for no devices on 1-wire 
....................            if((id_bit == 1) && (cmp_id_bit == 1)) 
0912:  DECFSZ xA9,W
0914:  BRA    091E
0916:  DECFSZ xAA,W
0918:  BRA    091E
....................               break; 
091A:  BRA    09D6
091C:  BRA    09D0
....................            else{ 
....................               // all devices coupled have 0 or 1 
....................               if(id_bit != cmp_id_bit) 
091E:  MOVF   xAA,W
0920:  SUBWF  xA9,W
0922:  BZ    092A
....................                  search_direction = id_bit; // bit write value for search 
0924:  MOVFF  A9,AC
0928:  BRA    096E
....................               else{ 
....................                  // if this discrepancy is before the Last Discrepancy 
....................                  // on a previous next then pick the same as last time 
....................                  if (id_bit_number < LastDiscrepancy)         
092A:  MOVF   44,W
092C:  SUBWF  xA5,W
092E:  BC    094E
....................                     search_direction = ((ROM_NO[rom_byte_number] &  rom_byte_mask) > 0); 
0930:  CLRF   03
0932:  MOVF   xA7,W
0934:  ADDLW  3C
0936:  MOVWF  FE9
0938:  MOVLW  00
093A:  ADDWFC 03,W
093C:  MOVWF  FEA
093E:  MOVF   FEF,W
0940:  ANDWF  xAB,W
0942:  BNZ   0948
0944:  MOVLW  00
0946:  BRA    094A
0948:  MOVLW  01
094A:  MOVWF  xAC
094C:  BRA    095C
....................                  else 
....................                     // if equal to last pick 1, if not then pick 0 
....................                     search_direction = (id_bit_number == LastDiscrepancy); 
094E:  MOVF   44,W
0950:  SUBWF  xA5,W
0952:  BZ    0958
0954:  MOVLW  00
0956:  BRA    095A
0958:  MOVLW  01
095A:  MOVWF  xAC
....................                     // if 0 was picked then record its position in LastZero 
....................                     if (search_direction == 0){  
095C:  MOVF   xAC,F
095E:  BNZ   096E
....................                        last_zero = id_bit_number; 
0960:  MOVFF  A5,A6
....................                        // check for Last discrepancy in family 
....................                        if (last_zero < 9)  
0964:  MOVF   xA6,W
0966:  SUBLW  08
0968:  BNC   096E
....................                            LastFamilyDiscrepancy = last_zero; 
096A:  MOVFF  A6,45
....................                     } 
....................                } 
....................                // set or clear the bit in the ROM byte rom_byte_number 
....................                // with mask rom_byte_mask 
....................                if (search_direction == 1) 
096E:  DECFSZ xAC,W
0970:  BRA    0988
....................                   ROM_NO[rom_byte_number] |= rom_byte_mask; 
0972:  CLRF   03
0974:  MOVF   xA7,W
0976:  ADDLW  3C
0978:  MOVWF  FE9
097A:  MOVLW  00
097C:  ADDWFC 03,W
097E:  MOVWF  FEA
0980:  MOVF   FEF,W
0982:  IORWF  xAB,W
0984:  MOVWF  FEF
0986:  BRA    099E
....................                else 
....................                   ROM_NO[rom_byte_number] &= ~rom_byte_mask; 
0988:  CLRF   03
098A:  MOVF   xA7,W
098C:  ADDLW  3C
098E:  MOVWF  FE9
0990:  MOVLW  00
0992:  ADDWFC 03,W
0994:  MOVWF  FEA
0996:  MOVF   xAB,W
0998:  XORLW  FF
099A:  ANDWF  FEF,W
099C:  MOVWF  FEF
....................                // serial number search direction write bit 
....................                if (search_direction) 
099E:  MOVF   xAC,F
09A0:  BZ    09A6
....................                   Ow_Write_One(); 
09A2:  BRA    0882
09A4:  BRA    09A8
....................                else 
....................                   Ow_Write_Zero(); 
09A6:  BRA    08A0
....................                // increment the byte counter id_bit_number 
....................                // and shift the mask rom_byte_mask 
....................  
....................                id_bit_number++; 
09A8:  INCF   xA5,F
....................                rom_byte_mask <<= 1; 
09AA:  BCF    FD8.0
09AC:  RLCF   xAB,F
....................  
....................                // if the mask is 0 then go to new SerialNum byte rom_byte_number 
....................                //and reset mask 
....................                if (rom_byte_mask == 0){ 
09AE:  MOVF   xAB,F
09B0:  BNZ   09D0
....................                   docrc8(ROM_NO[rom_byte_number]); // accumulate the CRC 
09B2:  CLRF   03
09B4:  MOVF   xA7,W
09B6:  ADDLW  3C
09B8:  MOVWF  FE9
09BA:  MOVLW  00
09BC:  ADDWFC 03,W
09BE:  MOVWF  FEA
09C0:  MOVFF  FEF,AD
09C4:  MOVFF  AD,AE
09C8:  BRA    08BE
....................                   rom_byte_number++; 
09CA:  INCF   xA7,F
....................                   rom_byte_mask = 1; 
09CC:  MOVLW  01
09CE:  MOVWF  xAB
....................                } 
....................            }                               
....................         }   // End of search loop                  
....................         while(rom_byte_number < 8); // loop until through all ROM bytes 0-7 
09D0:  MOVF   xA7,W
09D2:  SUBLW  07
09D4:  BC    0906
....................         // if the search was successful then 
....................         if (!((id_bit_number < 65) || (crc8 != 0))){ 
09D6:  MOVF   xA5,W
09D8:  SUBLW  40
09DA:  BC    09F0
09DC:  MOVF   47,F
09DE:  BNZ   09F0
....................            // search successful so set LastDiscrepancy,LastDeviceFlag,search_result 
....................            LastDiscrepancy = last_zero; 
09E0:  MOVFF  A6,44
....................            // check for last device 
....................            if (LastDiscrepancy == 0) 
09E4:  MOVF   44,F
09E6:  BNZ   09EC
....................               LastDeviceFlag = 1; 
09E8:  MOVLW  01
09EA:  MOVWF  46
....................            search_result = 1; 
09EC:  MOVLW  01
09EE:  MOVWF  xA8
....................         } 
....................    } 
....................    // if no device found then reset counters so next 'search' will be 
....................    // like a first                    
....................    if (!search_result || !ROM_NO[0]){ 
09F0:  MOVF   xA8,F
09F2:  BZ    09F8
09F4:  MOVF   3C,F
09F6:  BNZ   0A00
....................             LastDiscrepancy = 0;  
09F8:  CLRF   44
....................             LastDeviceFlag = 0; 
09FA:  CLRF   46
....................             LastFamilyDiscrepancy = 0; 
09FC:  CLRF   45
....................             search_result = 0;    
09FE:  CLRF   xA8
....................    } 
....................    return search_result; 
0A00:  MOVFF  A8,01
0A04:  RETURN 0
.................... }   // End of Ow-Search function 
....................  
.................... // Finds the first device 
.................... uint8_t Ow_First(){ 
....................    LastDiscrepancy = 0; 
0A06:  CLRF   44
....................    LastDeviceFlag = 0; 
0A08:  CLRF   46
....................    LastFamilyDiscrepancy = 0;  
0A0A:  CLRF   45
....................    return Ow_Search();  
0A0C:  RCALL  08DA
0A0E:  MOVF   01,W
0A10:  RETURN 0
.................... } 
....................  
....................  
.................... // Finds any other devices after the first one 
.................... uint8_t Ow_Next(){ 
....................    return Ow_Search(); 
*
0A2C:  RCALL  08DA
0A2E:  MOVF   01,W
0A30:  GOTO   0C40 (RETURN)
.................... }  
....................  
.................... // Set up search to look for a certain device family code 
.................... void Ow_Target_Setup(uchar_t family_code){ 
....................    uint8_t i; 
....................    // set the search state to find SearchFamily type devices 
....................    ROM_NO[0] = family_code; 
....................    for (i = 1; i < 8; i++) 
....................    ROM_NO[i] = 0; 
....................    LastDiscrepancy = 64; 
....................    LastFamilyDiscrepancy = 0; 
....................    LastDeviceFlag = 0; 
.................... } 
....................                                                     
.................... void Ow_Family_Skip_Setup(){ 
....................    // set the Last discrepancy to last family discrepancy 
....................    LastDiscrepancy = LastFamilyDiscrepancy; 
....................    LastFamilyDiscrepancy = 0; 
....................    // check for end of list 
....................    if (LastDiscrepancy == 0) 
....................       LastDeviceFlag = 1; 
.................... } 
....................                      
.................... #endif /*ONE_WIRE_C*/ 
....................  
.................... #include "ds1990a.c"     
.................... #include "ds1990a.h" 
.................... #include "1wire.h"     
.................... #ifndef ONE_WIRE_H                                  
.................... #define ONE_WIRE_H   
....................                                                                          
....................       
.................... void onewire_reset();   
.................... void onewire_write(uchar_t);  
.................... uint8_t onewire_read();                              
.................... void OneWireLow();           
.................... void OneWireRelease();  
....................                                                 
.................... // SEARCH ROOM 
.................... const uchar_t dscrc_table[] = { //static 
.................... 0, 94,188,226, 97, 63,221,131,194,156,126, 32,163,253, 31, 65, 
.................... 157,195, 33,127,252,162, 64, 30, 95, 1,227,189, 62, 96,130,220, 
.................... 35,125,159,193, 66, 28,254,160,225,191, 93, 3,128,222, 60, 98, 
.................... 190,224, 2, 92,223,129, 99, 61,124, 34,192,158, 29, 67,161,255, 
.................... 70, 24,250,164, 39,121,155,197,132,218, 56,102,229,187, 89, 7, 
.................... 219,133,103, 57,186,228, 6, 88, 25, 71,165,251,120, 38,196,154, 
.................... 101, 59,217,135, 4, 90,184,230,167,249, 27, 69,198,152,122, 36, 
.................... 248,166, 68, 26,153,199, 37,123, 58,100,134,216, 91, 5,231,185, 
.................... 140,210, 48,110,237,179, 81, 15, 78, 16,242,172, 47,113,147,205, 
.................... 17, 79,173,243,112, 46,204,146,211,141,111, 49,178,236, 14, 80, 
.................... 175,241, 19, 77,206,144,114, 44,109, 51,209,143, 12, 82,176,238, 
.................... 50,108,142,208, 83, 13,239,177,240,174, 76, 18,145,207, 45,115, 
.................... 202,148,118, 40,171,245, 23, 73, 8, 86,180,234,105, 55,213,139, 
.................... 87, 9,235,181, 54,104,138,212,149,203, 41,119,244,170, 72, 22, 
.................... 233,183, 85, 11,136,214, 52,106, 43,117,151,201, 74, 20,246,168, 
.................... 116, 42,200,150, 21, 75,169,247,182,232, 10, 84,215,137,107, 53}; 
....................  
....................  
.................... extern uchar_t i;     
....................  
.................... // global search state 
.................... extern uchar_t ROM_NO[8];                              
.................... extern uint8_t LastDiscrepancy; 
.................... extern uint8_t LastFamilyDiscrepancy; 
.................... extern uint8_t LastDeviceFlag; 
.................... extern uchar_t crc8;    
....................  
.................... uchar_t docrc8(uchar_t );   
....................  
.................... unsigned short Ow_Read_Bit(); 
.................... void Ow_Write_One();    
.................... void Ow_Write_Zero(); 
....................  
.................... uint8_t Ow_Reset(); 
....................  
.................... uint8_t Ow_Search();      
.................... uint8_t Ow_First();                
.................... uint8_t Ow_Next(); 
.................... void Ow_Target_Setup(uchar_t ); 
.................... void Ow_Family_Skip_Setup(); 
....................  
....................  
.................... #endif ONE_WIRE_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "ucregisters.h"      
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1           
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0   
.................... #bit  PORTB_7=PORTB.7   
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................  
.................... //   ################   D18B20/D1990A One-Wire Connection  #################  //                            
.................... #byte LATC    = 0x0F8B   
.................... #bit  LATC_0  = LATC.0   
.................... #bit  TRISC_0 = TRISC.0        
.................... #bit  PORTC_0 = PORTC.0     
....................  
....................  
....................  
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "1wire.c"   
.................... #include "1wire.h"      
.................... #ifndef ONE_WIRE_H                                  
.................... #define ONE_WIRE_H   
....................                                                                          
....................       
.................... void onewire_reset();   
.................... void onewire_write(uchar_t);  
.................... uint8_t onewire_read();                              
.................... void OneWireLow();           
.................... void OneWireRelease();  
....................                                                 
.................... // SEARCH ROOM 
.................... const uchar_t dscrc_table[] = { //static 
.................... 0, 94,188,226, 97, 63,221,131,194,156,126, 32,163,253, 31, 65, 
.................... 157,195, 33,127,252,162, 64, 30, 95, 1,227,189, 62, 96,130,220, 
.................... 35,125,159,193, 66, 28,254,160,225,191, 93, 3,128,222, 60, 98, 
.................... 190,224, 2, 92,223,129, 99, 61,124, 34,192,158, 29, 67,161,255, 
.................... 70, 24,250,164, 39,121,155,197,132,218, 56,102,229,187, 89, 7, 
.................... 219,133,103, 57,186,228, 6, 88, 25, 71,165,251,120, 38,196,154, 
.................... 101, 59,217,135, 4, 90,184,230,167,249, 27, 69,198,152,122, 36, 
.................... 248,166, 68, 26,153,199, 37,123, 58,100,134,216, 91, 5,231,185, 
.................... 140,210, 48,110,237,179, 81, 15, 78, 16,242,172, 47,113,147,205, 
.................... 17, 79,173,243,112, 46,204,146,211,141,111, 49,178,236, 14, 80, 
.................... 175,241, 19, 77,206,144,114, 44,109, 51,209,143, 12, 82,176,238, 
.................... 50,108,142,208, 83, 13,239,177,240,174, 76, 18,145,207, 45,115, 
.................... 202,148,118, 40,171,245, 23, 73, 8, 86,180,234,105, 55,213,139, 
.................... 87, 9,235,181, 54,104,138,212,149,203, 41,119,244,170, 72, 22, 
.................... 233,183, 85, 11,136,214, 52,106, 43,117,151,201, 74, 20,246,168, 
.................... 116, 42,200,150, 21, 75,169,247,182,232, 10, 84,215,137,107, 53}; 
....................  
....................  
.................... extern uchar_t i;     
....................  
.................... // global search state 
.................... extern uchar_t ROM_NO[8];                              
.................... extern uint8_t LastDiscrepancy; 
.................... extern uint8_t LastFamilyDiscrepancy; 
.................... extern uint8_t LastDeviceFlag; 
.................... extern uchar_t crc8;    
....................  
.................... uchar_t docrc8(uchar_t );   
....................  
.................... unsigned short Ow_Read_Bit(); 
.................... void Ow_Write_One();    
.................... void Ow_Write_Zero(); 
....................  
.................... uint8_t Ow_Reset(); 
....................  
.................... uint8_t Ow_Search();      
.................... uint8_t Ow_First();                
.................... uint8_t Ow_Next(); 
.................... void Ow_Target_Setup(uchar_t ); 
.................... void Ow_Family_Skip_Setup(); 
....................  
....................  
.................... #endif ONE_WIRE_H 
....................  
.................... #ifndef ONE_WIRE_C 
.................... #define ONE_WIRE_C  
....................      
....................  
.................... #define ONE_WIRE_PIN PIN_C0 
....................                                  
....................  
.................... uchar_t i;                  
....................  
....................                        
.................... // global search state 
.................... uchar_t ROM_NO[8];                                   
.................... uint8_t LastDiscrepancy; 
.................... uint8_t LastFamilyDiscrepancy; 
.................... uint8_t LastDeviceFlag; 
.................... uchar_t crc8;                            
....................                                                                                                                                                                         
.................... /*     
....................  * onewire_reset() 
....................  * Description: Initiates the one wire bus.         
....................  */ 
.................... // OK if just using a single permanently connected device                
....................                                            
.................... void onewire_reset() {  
....................    OneWireLow();  
....................    delay_us(500); 
....................    OneWireRelease();            
....................    delay_us(500);  
.................... }                                          
....................           
.................... /*                                
....................  * onewire_write(int8 data) 
....................  * Arguments: a byte of data. 
....................  * Description: writes a byte of data to the device. 
....................  */ 
.................... void onewire_write(uchar_t data) {  
....................    int8 count; 
....................     for(count = 0; count < 8; ++count) { 
....................         OneWireLow(); 
....................         delay_us(2);                // pull 1-wire low to initiate write time-slot. 
....................         if(data & 0x01)                 
....................           OneWireRelease();   
....................         delay_us(65);               // wait until end of write slot. 
....................         OneWireRelease(); // set 1-wire high again, 
....................         delay_us(2);                // for more than 1us minimum.  
....................         data = (data >> 1);  
....................     } 
.................... }                                                                  
....................                                         
.................... /* 
....................  * onewire_read()         
....................  * Description: reads and returns a byte of data from the device.                                                                  
....................  */                                   
.................... uint8_t onewire_read() {  
....................     uint8_t count, data=0;                      
....................     for(count = 0; count < 8; ++count) { 
....................         OneWireLow(); 
....................         delay_us(2);                // pull 1-wire low to initiate read time-slot. 
....................         OneWireRelease();              // now let 1-wire float high, 
....................         delay_us(4);                // let device state stabilise,  
....................         if(PORTC_0)                 //ZATEN RELEASE KONUMUNA TEKRAR BIR AYARLAMAYA GEREK YOK          
....................            bit_set(data,count);    
....................         delay_us(120);              // wait until end of read slot. 
....................     }                          
....................     return data;     
.................... }     
.................... unsigned short Ow_Read_Bit(){ 
....................    unsigned short BitValue;    // Bit to be returned 
....................    OneWireLow();               // Set pin 2 in PORT E as output 
....................                                // Drive bus low   LATE.B2;   for PIC18 
....................    delay_us(2);                // Wait 2 usecs 
....................    OneWireRelease();                 // Release the bus 
....................    delay_us(5);                // Wait 5 usecs 
....................    BitValue = PORTC_0;         // Read bit value on pin 0 on PORT C 
....................    delay_us(120);               // Wait 120 usecs 
....................    return BitValue;            // Return bit read 
.................... } 
....................                                      
.................... // Sends a '1' bit to the I/O pin  See application note 126 
.................... void Ow_Write_One(){    
....................    OneWireLow();      // Set pin 2 in PORT E as output 
....................    delay_us(2);        // Drive bus low 
....................    OneWireRelease();   
....................    delay_us(65);       // Wait 6 usecs        (6*4)*0.25 us 
....................    OneWireRelease();  // Release the bus 
....................    delay_us(2);      // Wait 64 usecs        (64*4)*0.25 us 
.................... }    
....................                   
....................                
.................... void OneWireRelease(){  
....................     PORTC_0 = 1; // Set as output  BUSDIR      
....................     TRISC_0 = 1; // Set high       BUSOUT else{      
.................... }  
....................  
.................... void OneWireLow(){                 
....................    PORTC_0 = 0; // Set as output  BUSDIR 
....................    TRISC_0 = 0; // Set low        BUSOUT 
.................... }        
....................                                                                                
....................                               
.................... uchar_t docrc8(uchar_t value){ 
....................    crc8 = dscrc_table[crc8 ^ value];    // Xor operation 
....................    return crc8; 
.................... }   
....................               
.................... uint8_t Ow_Reset(){ 
....................    uint8_t OW=0;  
....................    OneWireLow();                             
....................    delay_us(500); 
....................    OneWireRelease();  
....................    delay_us(70);        
....................    OW = Ow_Read_Bit();                 
....................    delay_us(430); 
....................    OneWireRelease();  
....................    return OW;  
.................... }   
....................  
....................  
....................                        
.................... // Sends a '0' bit to the I/O pin   See application note 126 
.................... void Ow_Write_Zero(){    
....................    OneWireLow();     // Set pin 2 in PORT E as output 
....................                      // Drive bus low 
....................    delay_us(65);     // Wait 60 usecs 
....................    OneWireRelease(); // Release the bus 
....................    delay_us(10);     // Wait 10 usecs 
.................... } 
....................     
.................... uint8_t Ow_Search(){ 
....................    uint8_t id_bit_number; 
....................    uint8_t last_zero, rom_byte_number, search_result; 
....................    uint8_t id_bit, cmp_id_bit; 
....................    uchar_t rom_byte_mask, search_direction; 
....................  
....................    // initialize for search 
....................    id_bit_number = 1; 
....................    last_zero = 0; 
....................    rom_byte_number = 0;      
....................    rom_byte_mask = 1; 
....................    search_result = 0; 
....................    crc8 = 0;         
....................     
....................         // if the last call was not the last one 
....................    if (!LastDeviceFlag){  
....................       // check if there are 1-Wire device (s) 0 if the device(s) responded, 1 if no devices did 
....................       if (Ow_Reset()){  
....................          // reset the search 
....................          LastDiscrepancy = 0; 
....................          LastDeviceFlag = 0; 
....................          LastFamilyDiscrepancy = 0; 
....................          return 0;  
....................       } 
....................         // Issue command Search_ROM 
....................         onewire_write(0xF0); 
....................         // loop to do the search 
....................         do{// read a bit and its complement 
....................            id_bit = OW_Read_Bit(); 
....................            cmp_id_bit = OW_Read_Bit(); 
....................            // 11 no devices on the 1-wire 
....................            // check for no devices on 1-wire 
....................            if((id_bit == 1) && (cmp_id_bit == 1)) 
....................               break; 
....................            else{ 
....................               // all devices coupled have 0 or 1 
....................               if(id_bit != cmp_id_bit) 
....................                  search_direction = id_bit; // bit write value for search 
....................               else{ 
....................                  // if this discrepancy is before the Last Discrepancy 
....................                  // on a previous next then pick the same as last time 
....................                  if (id_bit_number < LastDiscrepancy)         
....................                     search_direction = ((ROM_NO[rom_byte_number] &  rom_byte_mask) > 0); 
....................                  else 
....................                     // if equal to last pick 1, if not then pick 0 
....................                     search_direction = (id_bit_number == LastDiscrepancy); 
....................                     // if 0 was picked then record its position in LastZero 
....................                     if (search_direction == 0){  
....................                        last_zero = id_bit_number; 
....................                        // check for Last discrepancy in family 
....................                        if (last_zero < 9)  
....................                            LastFamilyDiscrepancy = last_zero; 
....................                     } 
....................                } 
....................                // set or clear the bit in the ROM byte rom_byte_number 
....................                // with mask rom_byte_mask 
....................                if (search_direction == 1) 
....................                   ROM_NO[rom_byte_number] |= rom_byte_mask; 
....................                else 
....................                   ROM_NO[rom_byte_number] &= ~rom_byte_mask; 
....................                // serial number search direction write bit 
....................                if (search_direction) 
....................                   Ow_Write_One(); 
....................                else 
....................                   Ow_Write_Zero(); 
....................                // increment the byte counter id_bit_number 
....................                // and shift the mask rom_byte_mask 
....................  
....................                id_bit_number++; 
....................                rom_byte_mask <<= 1; 
....................  
....................                // if the mask is 0 then go to new SerialNum byte rom_byte_number 
....................                //and reset mask 
....................                if (rom_byte_mask == 0){ 
....................                   docrc8(ROM_NO[rom_byte_number]); // accumulate the CRC 
....................                   rom_byte_number++; 
....................                   rom_byte_mask = 1; 
....................                } 
....................            }                               
....................         }   // End of search loop                  
....................         while(rom_byte_number < 8); // loop until through all ROM bytes 0-7 
....................         // if the search was successful then 
....................         if (!((id_bit_number < 65) || (crc8 != 0))){ 
....................            // search successful so set LastDiscrepancy,LastDeviceFlag,search_result 
....................            LastDiscrepancy = last_zero; 
....................            // check for last device 
....................            if (LastDiscrepancy == 0) 
....................               LastDeviceFlag = 1; 
....................            search_result = 1; 
....................         } 
....................    } 
....................    // if no device found then reset counters so next 'search' will be 
....................    // like a first                    
....................    if (!search_result || !ROM_NO[0]){ 
....................             LastDiscrepancy = 0;  
....................             LastDeviceFlag = 0; 
....................             LastFamilyDiscrepancy = 0; 
....................             search_result = 0;    
....................    } 
....................    return search_result; 
.................... }   // End of Ow-Search function 
....................  
.................... // Finds the first device 
.................... uint8_t Ow_First(){ 
....................    LastDiscrepancy = 0; 
....................    LastDeviceFlag = 0; 
....................    LastFamilyDiscrepancy = 0;  
....................    return Ow_Search();  
.................... } 
....................  
....................  
.................... // Finds any other devices after the first one 
.................... uint8_t Ow_Next(){ 
....................    return Ow_Search(); 
.................... }  
....................  
.................... // Set up search to look for a certain device family code 
.................... void Ow_Target_Setup(uchar_t family_code){ 
....................    uint8_t i; 
....................    // set the search state to find SearchFamily type devices 
....................    ROM_NO[0] = family_code; 
....................    for (i = 1; i < 8; i++) 
....................    ROM_NO[i] = 0; 
....................    LastDiscrepancy = 64; 
....................    LastFamilyDiscrepancy = 0; 
....................    LastDeviceFlag = 0; 
.................... } 
....................                                                     
.................... void Ow_Family_Skip_Setup(){ 
....................    // set the Last discrepancy to last family discrepancy 
....................    LastDiscrepancy = LastFamilyDiscrepancy; 
....................    LastFamilyDiscrepancy = 0; 
....................    // check for end of list 
....................    if (LastDiscrepancy == 0) 
....................       LastDeviceFlag = 1; 
.................... } 
....................                      
.................... #endif /*ONE_WIRE_C*/ 
....................  
....................  
.................... #ifndef DS1990A_H 
.................... #define DS1990A_H  
....................  
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t SEARCH_DONE : 1;  //bit:0,             
....................       uint8_t MATCH_DONE  : 1;  //bit:0, 
....................       uint8_t reserved    : 6;  //bit:1,      
....................       
....................    }X;                     
.................... }DS1990A_t;                                                                                     
.................... extern DS1990A_t DS1990A;   
....................  
.................... extern uchar_t TEMPBF[32]; 
....................  
.................... //DEVICES ROM BUFFER  //  REGISTERED DEVICES 
.................... extern uchar_t SlaveROM[5][8];  
.................... //READ ROM BUFFER          
.................... extern uchar_t ReadROM[8];  
....................  
....................  
.................... // SEARCH ROOM  
.................... extern uchar_t DevicesFound; // Number of devices found  
.................... extern uchar_t RegisteredDevice;      
.................... extern uchar_t queue;   
....................  
.................... // SEARCH ROOM FUNCTION  
.................... void ds1990SearchRom(uchar_t * , uchar_t , uchar_t );  
....................  
.................... // MATCH ROOM 
.................... void ds1990ReadAndMatch(uchar_t * ,uchar_t, uchar_t);   
.................... void compareROM(); 
....................                      
....................  
.................... #endif // DS1990A_H                                
....................  
.................... #include <string.h>                        
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
0F06:  MOVF   xAB,F
0F08:  BNZ   0F0E
0F0A:  MOVF   xAC,F
0F0C:  BZ    0F92
....................       if (*s1 != *s2) 
0F0E:  MOVFF  A7,FE9
0F12:  MOVFF  A8,FEA
0F16:  MOVFF  FEF,AD
0F1A:  MOVFF  AA,03
0F1E:  MOVFF  A9,FE9
0F22:  MOVFF  AA,FEA
0F26:  MOVF   FEF,W
0F28:  SUBWF  xAD,W
0F2A:  BZ    0F5A
....................          return((*s1 <*s2) ? -1: 1); 
0F2C:  MOVFF  A8,03
0F30:  MOVFF  A7,FE9
0F34:  MOVFF  03,FEA
0F38:  MOVFF  FEF,AD
0F3C:  MOVFF  AA,03
0F40:  MOVFF  A9,FE9
0F44:  MOVFF  AA,FEA
0F48:  MOVF   FEF,W
0F4A:  SUBWF  xAD,W
0F4C:  BC    0F52
0F4E:  MOVLW  FF
0F50:  BRA    0F54
0F52:  MOVLW  01
0F54:  MOVWF  01
0F56:  BRA    0F96
0F58:  BRA    0F70
....................       else if (*s1 == '\0') 
0F5A:  MOVFF  A8,03
0F5E:  MOVFF  A7,FE9
0F62:  MOVFF  A8,FEA
0F66:  MOVF   FEF,F
0F68:  BNZ   0F70
....................          return(0); 
0F6A:  MOVLW  00
0F6C:  MOVWF  01
0F6E:  BRA    0F96
0F70:  MOVFF  A8,03
0F74:  MOVF   xA7,W
0F76:  INCF   xA7,F
0F78:  BTFSC  FD8.2
0F7A:  INCF   xA8,F
0F7C:  MOVFF  AA,03
0F80:  MOVF   xA9,W
0F82:  INCF   xA9,F
0F84:  BTFSC  FD8.2
0F86:  INCF   xAA,F
0F88:  MOVF   xAB,W
0F8A:  BTFSC  FD8.2
0F8C:  DECF   xAC,F
0F8E:  DECF   xAB,F
0F90:  BRA    0F06
....................    return(0); 
0F92:  MOVLW  00
0F94:  MOVWF  01
0F96:  GOTO   1008 (RETURN)
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef DS1990A_C   
.................... #define DS1990A_C  
....................   
.................... //LCD TEXT BUFFER 
.................... uchar_t TEMPBF[32];    
....................  
.................... //DEVICES ROM BUFFER  
.................... uchar_t SlaveROM[5][8];  
.................... //READ ROM BUFFER   
.................... uchar_t ReadROM[8]; 
....................  
....................  
.................... // SEARCH ROOM   
.................... uchar_t DevicesFound; // Number of devices found  
.................... uchar_t RegisteredDevice;      
.................... uchar_t queue;  
.................... DS1990A_t DS1990A;  
....................  
.................... void ds1990SearchRom(uchar_t * interruptAddress, uchar_t interruptControlBit, uchar_t isInterruptAvailable){ 
....................    DS1990A.X.MATCH_DONE=0;  
*
0B98:  BCF    48.1
....................    if(isInterruptAvailable)        
0B9A:  MOVF   xA4,F
0B9C:  BZ    0BC4
....................      *interruptAddress &= ~(1<<interruptControlBit);        
0B9E:  MOVFF  A2,03
0BA2:  MOVFF  A1,FE9
0BA6:  MOVFF  A2,FEA
0BAA:  MOVLW  01
0BAC:  MOVWF  00
0BAE:  MOVF   xA3,W
0BB0:  MOVWF  01
0BB2:  BZ    0BBC
0BB4:  BCF    FD8.0
0BB6:  RLCF   00,F
0BB8:  DECFSZ 01,F
0BBA:  BRA    0BB4
0BBC:  MOVF   00,W
0BBE:  XORLW  FF
0BC0:  ANDWF  FEF,W
0BC2:  MOVWF  FEF
....................    switch(queue){  
0BC4:  MOVF   x9B,W
0BC6:  BZ    0BCE
0BC8:  XORLW  01
0BCA:  BZ    0C3E
0BCC:  BRA    0EC6
....................    case 0:                                                                                  
....................         DevicesFound = 0;  // Reset device counter     
0BCE:  CLRF   x99
....................         if(Ow_First()){    // Check for the first device  
0BD0:  RCALL  0A06
0BD2:  MOVF   01,F
0BD4:  BZ    0C3A
....................           for(i=0; i<8; i++){     
0BD6:  CLRF   3B
0BD8:  MOVF   3B,W
0BDA:  SUBLW  07
0BDC:  BNC   0C24
....................               SlaveROM[DevicesFound][i]=ROM_NO[i];   
0BDE:  MOVF   x99,W
0BE0:  MULLW  08
0BE2:  MOVF   FF3,W
0BE4:  CLRF   xA6
0BE6:  MOVWF  xA5
0BE8:  CLRF   03
0BEA:  MOVF   3B,W
0BEC:  ADDWF  xA5,W
0BEE:  MOVWF  01
0BF0:  MOVF   xA6,W
0BF2:  ADDWFC 03,F
0BF4:  MOVF   01,W
0BF6:  ADDLW  69
0BF8:  MOVWF  01
0BFA:  MOVLW  00
0BFC:  ADDWFC 03,F
0BFE:  MOVFF  03,A6
0C02:  CLRF   03
0C04:  MOVF   3B,W
0C06:  ADDLW  3C
0C08:  MOVWF  FE9
0C0A:  MOVLW  00
0C0C:  ADDWFC 03,W
0C0E:  MOVWF  FEA
0C10:  MOVFF  FEF,A7
0C14:  MOVFF  A6,FEA
0C18:  MOVFF  01,FE9
0C1C:  MOVFF  A7,FEF
0C20:  INCF   3B,F
0C22:  BRA    0BD8
....................           }                  
....................           DevicesFound++;  // Increment the device found counter 
0C24:  INCF   x99,F
....................           memset(ROM_NO,0,8);  
0C26:  CLRF   FEA
0C28:  MOVLW  3C
0C2A:  MOVWF  FE9
0C2C:  CLRF   00
0C2E:  CLRF   02
0C30:  MOVLW  08
0C32:  MOVWF  01
0C34:  RCALL  0A12
....................           queue++; 
0C36:  INCF   x9B,F
....................           }else 
0C38:  BRA    0C3C
....................              queue=0;   
0C3A:  CLRF   x9B
....................    break;                                                    
0C3C:  BRA    0EC6
....................     
....................    case 1:                                                 
....................         if(Ow_Next()){    // Check for the next device  
0C3E:  BRA    0A2C
0C40:  MOVF   01,F
0C42:  BZ    0CAA
....................           for(i=0; i<8; i++){     
0C44:  CLRF   3B
0C46:  MOVF   3B,W
0C48:  SUBLW  07
0C4A:  BNC   0C92
....................              SlaveROM[DevicesFound][i]=ROM_NO[i];   
0C4C:  MOVF   x99,W
0C4E:  MULLW  08
0C50:  MOVF   FF3,W
0C52:  CLRF   xA6
0C54:  MOVWF  xA5
0C56:  CLRF   03
0C58:  MOVF   3B,W
0C5A:  ADDWF  xA5,W
0C5C:  MOVWF  01
0C5E:  MOVF   xA6,W
0C60:  ADDWFC 03,F
0C62:  MOVF   01,W
0C64:  ADDLW  69
0C66:  MOVWF  01
0C68:  MOVLW  00
0C6A:  ADDWFC 03,F
0C6C:  MOVFF  03,A6
0C70:  CLRF   03
0C72:  MOVF   3B,W
0C74:  ADDLW  3C
0C76:  MOVWF  FE9
0C78:  MOVLW  00
0C7A:  ADDWFC 03,W
0C7C:  MOVWF  FEA
0C7E:  MOVFF  FEF,A7
0C82:  MOVFF  A6,FEA
0C86:  MOVFF  01,FE9
0C8A:  MOVFF  A7,FEF
0C8E:  INCF   3B,F
0C90:  BRA    0C46
....................           } 
....................           DevicesFound++;  // Increment the device found counter 
0C92:  INCF   x99,F
....................           memset(ROM_NO,0,8);  
0C94:  CLRF   FEA
0C96:  MOVLW  3C
0C98:  MOVWF  FE9
0C9A:  CLRF   00
0C9C:  CLRF   02
0C9E:  MOVLW  08
0CA0:  MOVWF  01
0CA2:  RCALL  0A12
....................           queue=1;                         
0CA4:  MOVLW  01
0CA6:  MOVWF  x9B
....................         }else{ 
0CA8:  BRA    0EC6
....................            DS1990A.X.SEARCH_DONE=1; 
0CAA:  BSF    48.0
....................            DS1990A.X.MATCH_DONE=1;     
0CAC:  BSF    48.1
....................            RegisteredDevice= DevicesFound; 
0CAE:  MOVFF  99,9A
....................            queue=0; 
0CB2:  CLRF   x9B
....................            for(i=0;i<DevicesFound;i++){ 
0CB4:  CLRF   3B
0CB6:  MOVF   x99,W
0CB8:  SUBWF  3B,W
0CBA:  BTFSC  FD8.0
0CBC:  BRA    0EC6
....................               printf("ROM%d: %02X %02X %02X  %02X  %02X  %02X  %02X  %02X\r",i,SlaveROM[i][0],SlaveROM[i][1],SlaveROM[i][2],SlaveROM[i][3],SlaveROM[i][4],SlaveROM[i][5],SlaveROM[i][6],SlaveROM[i][7]); 
0CBE:  MOVF   3B,W
0CC0:  MULLW  08
0CC2:  MOVF   FF3,W
0CC4:  CLRF   xA6
0CC6:  MOVWF  xA5
0CC8:  MOVLW  69
0CCA:  ADDWF  xA5,W
0CCC:  MOVWF  FE9
0CCE:  MOVLW  00
0CD0:  ADDWFC xA6,W
0CD2:  MOVWF  FEA
0CD4:  MOVFF  FEF,A7
0CD8:  MOVF   3B,W
0CDA:  MULLW  08
0CDC:  MOVF   FF3,W
0CDE:  CLRF   xA9
0CE0:  MOVWF  xA8
0CE2:  MOVLW  01
0CE4:  ADDWF  xA8,W
0CE6:  MOVWF  01
0CE8:  MOVLW  00
0CEA:  ADDWFC xA9,W
0CEC:  MOVWF  03
0CEE:  MOVF   01,W
0CF0:  ADDLW  69
0CF2:  MOVWF  FE9
0CF4:  MOVLW  00
0CF6:  ADDWFC 03,W
0CF8:  MOVWF  FEA
0CFA:  MOVFF  FEF,A8
0CFE:  MOVF   3B,W
0D00:  MULLW  08
0D02:  MOVF   FF3,W
0D04:  CLRF   xAA
0D06:  MOVWF  xA9
0D08:  MOVLW  02
0D0A:  ADDWF  xA9,W
0D0C:  MOVWF  01
0D0E:  MOVLW  00
0D10:  ADDWFC xAA,W
0D12:  MOVWF  03
0D14:  MOVF   01,W
0D16:  ADDLW  69
0D18:  MOVWF  FE9
0D1A:  MOVLW  00
0D1C:  ADDWFC 03,W
0D1E:  MOVWF  FEA
0D20:  MOVFF  FEF,A9
0D24:  MOVF   3B,W
0D26:  MULLW  08
0D28:  MOVF   FF3,W
0D2A:  CLRF   xAB
0D2C:  MOVWF  xAA
0D2E:  MOVLW  03
0D30:  ADDWF  xAA,W
0D32:  MOVWF  01
0D34:  MOVLW  00
0D36:  ADDWFC xAB,W
0D38:  MOVWF  03
0D3A:  MOVF   01,W
0D3C:  ADDLW  69
0D3E:  MOVWF  FE9
0D40:  MOVLW  00
0D42:  ADDWFC 03,W
0D44:  MOVWF  FEA
0D46:  MOVFF  FEF,AA
0D4A:  MOVF   3B,W
0D4C:  MULLW  08
0D4E:  MOVF   FF3,W
0D50:  CLRF   xAC
0D52:  MOVWF  xAB
0D54:  MOVLW  04
0D56:  ADDWF  xAB,W
0D58:  MOVWF  01
0D5A:  MOVLW  00
0D5C:  ADDWFC xAC,W
0D5E:  MOVWF  03
0D60:  MOVF   01,W
0D62:  ADDLW  69
0D64:  MOVWF  FE9
0D66:  MOVLW  00
0D68:  ADDWFC 03,W
0D6A:  MOVWF  FEA
0D6C:  MOVFF  FEF,AB
0D70:  MOVF   3B,W
0D72:  MULLW  08
0D74:  MOVF   FF3,W
0D76:  CLRF   xAD
0D78:  MOVWF  xAC
0D7A:  MOVLW  05
0D7C:  ADDWF  xAC,W
0D7E:  MOVWF  01
0D80:  MOVLW  00
0D82:  ADDWFC xAD,W
0D84:  MOVWF  03
0D86:  MOVF   01,W
0D88:  ADDLW  69
0D8A:  MOVWF  FE9
0D8C:  MOVLW  00
0D8E:  ADDWFC 03,W
0D90:  MOVWF  FEA
0D92:  MOVFF  FEF,AC
0D96:  MOVF   3B,W
0D98:  MULLW  08
0D9A:  MOVF   FF3,W
0D9C:  CLRF   xAE
0D9E:  MOVWF  xAD
0DA0:  MOVLW  06
0DA2:  ADDWF  xAD,W
0DA4:  MOVWF  01
0DA6:  MOVLW  00
0DA8:  ADDWFC xAE,W
0DAA:  MOVWF  03
0DAC:  MOVF   01,W
0DAE:  ADDLW  69
0DB0:  MOVWF  FE9
0DB2:  MOVLW  00
0DB4:  ADDWFC 03,W
0DB6:  MOVWF  FEA
0DB8:  MOVFF  FEF,AD
0DBC:  MOVF   3B,W
0DBE:  MULLW  08
0DC0:  MOVF   FF3,W
0DC2:  CLRF   xAF
0DC4:  MOVWF  xAE
0DC6:  MOVLW  07
0DC8:  ADDWF  xAE,W
0DCA:  MOVWF  01
0DCC:  MOVLW  00
0DCE:  ADDWFC xAF,W
0DD0:  MOVWF  03
0DD2:  MOVF   01,W
0DD4:  ADDLW  69
0DD6:  MOVWF  FE9
0DD8:  MOVLW  00
0DDA:  ADDWFC 03,W
0DDC:  MOVWF  FEA
0DDE:  MOVFF  FEF,AE
0DE2:  MOVLW  B0
0DE4:  MOVWF  FF6
0DE6:  MOVLW  05
0DE8:  MOVWF  FF7
0DEA:  MOVLW  03
0DEC:  MOVWF  xAF
0DEE:  BRA    0A34
0DF0:  MOVFF  3B,AF
0DF4:  MOVLW  18
0DF6:  MOVWF  xB0
0DF8:  BRA    0A7E
0DFA:  MOVLW  3A
0DFC:  BTFSS  F9E.4
0DFE:  BRA    0DFC
0E00:  MOVWF  FAD
0E02:  MOVLW  20
0E04:  BTFSS  F9E.4
0E06:  BRA    0E04
0E08:  MOVWF  FAD
0E0A:  MOVFF  A7,AF
0E0E:  MOVLW  37
0E10:  MOVWF  xB0
0E12:  RCALL  0B32
0E14:  MOVLW  20
0E16:  BTFSS  F9E.4
0E18:  BRA    0E16
0E1A:  MOVWF  FAD
0E1C:  MOVFF  A8,AF
0E20:  MOVLW  37
0E22:  MOVWF  xB0
0E24:  RCALL  0B32
0E26:  MOVLW  20
0E28:  BTFSS  F9E.4
0E2A:  BRA    0E28
0E2C:  MOVWF  FAD
0E2E:  MOVFF  A9,AF
0E32:  MOVLW  37
0E34:  MOVWF  xB0
0E36:  RCALL  0B32
0E38:  MOVLW  20
0E3A:  BTFSS  F9E.4
0E3C:  BRA    0E3A
0E3E:  MOVWF  FAD
0E40:  MOVLW  20
0E42:  BTFSS  F9E.4
0E44:  BRA    0E42
0E46:  MOVWF  FAD
0E48:  MOVFF  AA,AF
0E4C:  MOVLW  37
0E4E:  MOVWF  xB0
0E50:  RCALL  0B32
0E52:  MOVLW  20
0E54:  BTFSS  F9E.4
0E56:  BRA    0E54
0E58:  MOVWF  FAD
0E5A:  MOVLW  20
0E5C:  BTFSS  F9E.4
0E5E:  BRA    0E5C
0E60:  MOVWF  FAD
0E62:  MOVFF  AB,AF
0E66:  MOVLW  37
0E68:  MOVWF  xB0
0E6A:  RCALL  0B32
0E6C:  MOVLW  20
0E6E:  BTFSS  F9E.4
0E70:  BRA    0E6E
0E72:  MOVWF  FAD
0E74:  MOVLW  20
0E76:  BTFSS  F9E.4
0E78:  BRA    0E76
0E7A:  MOVWF  FAD
0E7C:  MOVFF  AC,AF
0E80:  MOVLW  37
0E82:  MOVWF  xB0
0E84:  RCALL  0B32
0E86:  MOVLW  20
0E88:  BTFSS  F9E.4
0E8A:  BRA    0E88
0E8C:  MOVWF  FAD
0E8E:  MOVLW  20
0E90:  BTFSS  F9E.4
0E92:  BRA    0E90
0E94:  MOVWF  FAD
0E96:  MOVFF  AD,AF
0E9A:  MOVLW  37
0E9C:  MOVWF  xB0
0E9E:  RCALL  0B32
0EA0:  MOVLW  20
0EA2:  BTFSS  F9E.4
0EA4:  BRA    0EA2
0EA6:  MOVWF  FAD
0EA8:  MOVLW  20
0EAA:  BTFSS  F9E.4
0EAC:  BRA    0EAA
0EAE:  MOVWF  FAD
0EB0:  MOVFF  AE,AF
0EB4:  MOVLW  37
0EB6:  MOVWF  xB0
0EB8:  RCALL  0B32
0EBA:  MOVLW  0D
0EBC:  BTFSS  F9E.4
0EBE:  BRA    0EBC
0EC0:  MOVWF  FAD
0EC2:  INCF   3B,F
0EC4:  BRA    0CB6
....................            }   
....................         } 
....................         break; 
....................    }                              
....................                                                           
....................    if (DevicesFound == 0) {      
0EC6:  MOVF   x99,F
0EC8:  BNZ   0EDA
....................       DS1990A.X.MATCH_DONE=1;  
0ECA:  BSF    48.1
....................       DS1990A.X.SEARCH_DONE=1;   
0ECC:  BSF    48.0
....................       queue=0;   
0ECE:  CLRF   x9B
....................       printf("No devices found\r");  
0ED0:  MOVLW  E6
0ED2:  MOVWF  FF6
0ED4:  MOVLW  05
0ED6:  MOVWF  FF7
0ED8:  BRA    0B74
....................    }                                                                                                      
....................    if(isInterruptAvailable)           
0EDA:  MOVF   xA4,F
0EDC:  BZ    0F02
....................       *interruptAddress |= (1<<interruptControlBit);  
0EDE:  MOVFF  A2,03
0EE2:  MOVFF  A1,FE9
0EE6:  MOVFF  A2,FEA
0EEA:  MOVLW  01
0EEC:  MOVWF  00
0EEE:  MOVF   xA3,W
0EF0:  MOVWF  01
0EF2:  BZ    0EFC
0EF4:  BCF    FD8.0
0EF6:  RLCF   00,F
0EF8:  DECFSZ 01,F
0EFA:  BRA    0EF4
0EFC:  MOVF   00,W
0EFE:  IORWF  FEF,W
0F00:  MOVWF  FEF
0F02:  GOTO   0168 (RETURN)
.................... }      
.................... void ds1990ReadAndMatch(uchar_t * interruptAddress, uchar_t interruptControlBit, uchar_t isInterruptAvailable){    
....................    DevicesFound = 0; 
*
107E:  CLRF   x99
....................    DS1990A.X.MATCH_DONE=0;                                
1080:  BCF    48.1
....................    if(isInterruptAvailable)        
1082:  MOVF   xA4,F
1084:  BZ    10AC
....................      *interruptAddress &= ~(1<<interruptControlBit);         
1086:  MOVFF  A2,03
108A:  MOVFF  A1,FE9
108E:  MOVFF  A2,FEA
1092:  MOVLW  01
1094:  MOVWF  00
1096:  MOVF   xA3,W
1098:  MOVWF  01
109A:  BZ    10A4
109C:  BCF    FD8.0
109E:  RLCF   00,F
10A0:  DECFSZ 01,F
10A2:  BRA    109C
10A4:  MOVF   00,W
10A6:  XORLW  FF
10A8:  ANDWF  FEF,W
10AA:  MOVWF  FEF
....................    if(Ow_First()){    // Check for the first device   
10AC:  RCALL  0A06
10AE:  MOVF   01,F
10B0:  BZ    10F0
....................       for(i=0; i<8; i++){     
10B2:  CLRF   3B
10B4:  MOVF   3B,W
10B6:  SUBLW  07
10B8:  BNC   10EC
....................          ReadROM[i]=ROM_NO[i];          
10BA:  CLRF   03
10BC:  MOVF   3B,W
10BE:  ADDLW  91
10C0:  MOVWF  01
10C2:  MOVLW  00
10C4:  ADDWFC 03,F
10C6:  MOVFF  03,A6
10CA:  CLRF   03
10CC:  MOVF   3B,W
10CE:  ADDLW  3C
10D0:  MOVWF  FE9
10D2:  MOVLW  00
10D4:  ADDWFC 03,W
10D6:  MOVWF  FEA
10D8:  MOVFF  FEF,A7
10DC:  MOVFF  A6,FEA
10E0:  MOVFF  01,FE9
10E4:  MOVFF  A7,FEF
10E8:  INCF   3B,F
10EA:  BRA    10B4
....................       }    
....................       compareROM();      
10EC:  BRA    0F9A
....................       DevicesFound++;  // Increment the device found counter 
10EE:  INCF   x99,F
....................    }                 
....................    if (DevicesFound == 0) {  
10F0:  MOVF   x99,F
10F2:  BNZ   112C
....................       memset(TEMPBF,0,32);                    
10F4:  CLRF   FEA
10F6:  MOVLW  49
10F8:  MOVWF  FE9
10FA:  CLRF   00
10FC:  CLRF   02
10FE:  MOVLW  20
1100:  MOVWF  01
1102:  RCALL  0A12
....................       sprintf(TEMPBF,"No devices found");  
1104:  CLRF   x9F
1106:  MOVLW  49
1108:  MOVWF  x9E
110A:  MOVLW  F8
110C:  MOVWF  FF6
110E:  MOVLW  05
1110:  MOVWF  FF7
1112:  BRA    105C
....................       memcpy(strLCD, TEMPBF, 32);    
1114:  CLRF   FEA
1116:  MOVLW  19
1118:  MOVWF  FE9
111A:  CLRF   FE2
111C:  MOVLW  49
111E:  MOVWF  FE1
1120:  MOVLW  20
1122:  MOVWF  01
1124:  MOVFF  FE6,FEE
1128:  DECFSZ 01,F
112A:  BRA    1124
....................    }   
....................    DS1990A.X.MATCH_DONE=1;  
112C:  BSF    48.1
....................    if(isInterruptAvailable)   
112E:  MOVF   xA4,F
1130:  BZ    1156
....................       *interruptAddress |= (1<<interruptControlBit);  
1132:  MOVFF  A2,03
1136:  MOVFF  A1,FE9
113A:  MOVFF  A2,FEA
113E:  MOVLW  01
1140:  MOVWF  00
1142:  MOVF   xA3,W
1144:  MOVWF  01
1146:  BZ    1150
1148:  BCF    FD8.0
114A:  RLCF   00,F
114C:  DECFSZ 01,F
114E:  BRA    1148
1150:  MOVF   00,W
1152:  IORWF  FEF,W
1154:  MOVWF  FEF
1156:  GOTO   0184 (RETURN)
.................... }                                                                   
.................... void compareROM(){  
....................    memset(strLCD,0,32); 
*
0F9A:  CLRF   FEA
0F9C:  MOVLW  19
0F9E:  MOVWF  FE9
0FA0:  CLRF   00
0FA2:  CLRF   02
0FA4:  MOVLW  20
0FA6:  MOVWF  01
0FA8:  RCALL  0A12
....................    memcpy(strLCD, "DEVICE UNDEFINED", 16);  
0FAA:  CLRF   FEA
0FAC:  MOVLW  19
0FAE:  MOVWF  FE9
0FB0:  MOVFF  FF2,A5
0FB4:  BCF    FF2.7
0FB6:  MOVLW  10
0FB8:  MOVWF  01
0FBA:  CLRF   FF7
0FBC:  MOVLW  00
0FBE:  CALL   051C
0FC2:  TBLRD*-
0FC4:  TBLRD*+
0FC6:  MOVFF  FF5,FEE
0FCA:  DECFSZ 01,F
0FCC:  BRA    0FC4
0FCE:  BTFSC  xA5.7
0FD0:  BSF    FF2.7
....................    for(i=0;i<RegisteredDevice;i++){   
0FD2:  CLRF   3B
0FD4:  MOVF   x9A,W
0FD6:  SUBWF  3B,W
0FD8:  BC    103A
....................       if(!strncmp(ReadROM,SlaveROM[i],64)){                            
0FDA:  MOVF   3B,W
0FDC:  MULLW  08
0FDE:  MOVF   FF3,W
0FE0:  CLRF   03
0FE2:  ADDLW  69
0FE4:  MOVWF  01
0FE6:  MOVLW  00
0FE8:  ADDWFC 03,F
0FEA:  MOVFF  01,A5
0FEE:  MOVFF  03,A6
0FF2:  CLRF   xA8
0FF4:  MOVLW  91
0FF6:  MOVWF  xA7
0FF8:  MOVFF  03,AA
0FFC:  MOVFF  01,A9
1000:  CLRF   xAC
1002:  MOVLW  40
1004:  MOVWF  xAB
1006:  BRA    0F06
1008:  MOVF   01,F
100A:  BNZ   1036
....................         memcpy(strLCD, " DEVICE DEFINED ", 16); 
100C:  CLRF   FEA
100E:  MOVLW  19
1010:  MOVWF  FE9
1012:  MOVFF  FF2,A5
1016:  BCF    FF2.7
1018:  MOVLW  10
101A:  MOVWF  01
101C:  CLRF   FF7
101E:  MOVLW  00
1020:  CALL   0548
1024:  TBLRD*-
1026:  TBLRD*+
1028:  MOVFF  FF5,FEE
102C:  DECFSZ 01,F
102E:  BRA    1026
1030:  BTFSC  xA5.7
1032:  BSF    FF2.7
....................         break;                                           
1034:  BRA    103A
....................       } 
1036:  INCF   3B,F
1038:  BRA    0FD4
....................    }    
103A:  GOTO   10EE (RETURN)
.................... } 
....................  
.................... #endif // DS1990A_H                                              
....................  
....................  
....................                               
....................                                     
.................... //TIMER1 UNION STRUCTURE AND COUNT MS 
.................... tmr1_time_t tmr1_time;  
.................... uint16_t iSayac;  
.................... uchar_t period;    
....................  
.................... void setupTimerIOSC(void){          
....................    //Setup Osilator 
....................    IRCF2 = 1;   
*
066A:  BSF    FD3.6
....................    IRCF1 = 1; 
066C:  BSF    FD3.5
....................    IRCF0 = 1;                    
066E:  BSF    FD3.4
....................                          
....................    //D ve P portlari cikis olarak ayarlanip sifirlandi. 
....................    TRISB = 0x00;                  
0670:  CLRF   F93
....................    TRISD = 0x00; 
0672:  CLRF   F95
....................    TRISE = 0x00;       
0674:  CLRF   F96
....................    PORTB = 0x00;                                                       
0676:  CLRF   F81
....................    PORTD = 0x00; 
0678:  CLRF   F8C
....................    PORTE = 0x00;   
067A:  CLRF   F84
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
067C:  CLRF   18
....................  
....................    // Kesmelere izin verildi 
....................    RCON_IPEN = 1;                                               
067E:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 1;  
0680:  BSF    FF2.7
....................    INTCON_PEIE = 1;           
0682:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
0684:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
0686:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
0688:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit  
068A:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
068C:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
068E:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
0690:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
0692:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
0694:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
0696:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
0698:  MOVLW  F8
069A:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.     
069C:  MOVLW  30
069E:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit         
06A0:  BSF    FCD.0
06A2:  GOTO   0134 (RETURN)
....................     
....................   
....................           
.................... }                  
....................                       
.................... void printOn2x16(){                   
....................    delayUsFun(40);                                                                                                                                       
*
06FA:  MOVLW  28
06FC:  MOVWF  xA5
06FE:  RCALL  00DA
....................    twoLinesBCDMode();    
0700:  BRA    06C8
....................    LinesActive();   
0702:  BRA    06D2
....................    lcdCursorOff(); 
0704:  BRA    06DC
....................    lcdShiftRight();                      
0706:  BRA    06E6
....................    lcdClear();                                                    
0708:  BRA    06F0
....................    memcpy(strLCD, "INFORMELEKTRONIKAR-GE    STAJYER", 32);  
070A:  CLRF   FEA
070C:  MOVLW  19
070E:  MOVWF  FE9
0710:  MOVFF  FF2,A1
0714:  BCF    FF2.7
0716:  MOVLW  20
0718:  MOVWF  01
071A:  CLRF   FF7
071C:  MOVLW  00
071E:  RCALL  0574
0720:  TBLRD*-
0722:  TBLRD*+
0724:  MOVFF  FF5,FEE
0728:  DECFSZ 01,F
072A:  BRA    0722
072C:  BTFSC  xA1.7
072E:  BSF    FF2.7
....................    countLCDChar=0;    
0730:  CLRF   39
....................    LCDW1SecFlag=1;                              
0732:  MOVLW  01
0734:  MOVWF  3A
0736:  GOTO   0136 (RETURN)
.................... }                           
....................                                 
.................... void I2C_Init() {     
....................    SCL_DIR = 1;     //Set as a digital input 
....................    SDA_DIR = 1;     //Set as a digital input 
....................    SSPADD  = 19;  
....................    SSPCON1 = 0x28;  // enable I2C pins SCL and SDA for serial communication 
....................    //SSPCON2 = 0x00;   
....................    SSPSTAT = 0x80;  //slew rate disabled for high speed control       
.................... }                                               
....................        
....................  
.................... #INT_TIMER1                                                            
.................... void timer1_interrupt(){  
....................    TMR1H = 0xF8; //Tasma saayci| 
*
060A:  MOVLW  F8
060C:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.   
060E:  MOVLW  30
0610:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor.    
0612:  BCF    F9E.0
....................    iSayac++; 
0614:  INCF   16,F
0616:  BTFSC  FD8.2
0618:  INCF   17,F
....................  
....................    if (iSayac % 2 == 0)  //5ms   
061A:  MOVF   16,W
061C:  ANDLW  01
061E:  MOVWF  xB8
0620:  CLRF   xB9
0622:  MOVF   xB8,F
0624:  BNZ   062C
0626:  MOVF   xB9,F
0628:  BNZ   062C
....................       tmr1_time.tmr1_flags._2ms = true;   
062A:  BSF    18.0
....................    if (iSayac % 50 == 0)//50ms        
062C:  MOVFF  17,B9
0630:  MOVFF  16,B8
0634:  CLRF   xBB
0636:  MOVLW  32
0638:  MOVWF  xBA
063A:  BRA    0096
063C:  MOVFF  00,B8
0640:  MOVFF  03,B9
0644:  MOVF   xB8,F
0646:  BNZ   064E
0648:  MOVF   xB9,F
064A:  BNZ   064E
....................       tmr1_time.tmr1_flags._20ms = true;   
064C:  BSF    18.1
....................    if(iSayac >= 1000){    //1 Second 
064E:  MOVF   17,W
0650:  SUBLW  02
0652:  BC    0664
0654:  XORLW  FF
0656:  BNZ   065E
0658:  MOVF   16,W
065A:  SUBLW  E7
065C:  BC    0664
....................       tmr1_time.tmr1_flags._1000ms = true;  
065E:  BSF    18.6
....................       iSayac = 0;              
0660:  CLRF   17
0662:  CLRF   16
....................    }                                         
.................... }                     
....................                                   
....................                                    
0664:  BCF    F9E.0
0666:  GOTO   0054
.................... #ORG 0x0100,0x0400                                                                     
.................... void main(){           
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  MOVLW  70
0108:  MOVWF  FD3
010A:  MOVF   FD3,W
010C:  BCF    FB8.3
010E:  MOVLW  0C
0110:  MOVWF  FAF
0112:  MOVLW  A2
0114:  MOVWF  FAC
0116:  MOVLW  90
0118:  MOVWF  FAB
011A:  NOP   
011C:  NOP   
011E:  CLRF   x9F
0120:  CLRF   x9E
0122:  MOVF   FC1,W
0124:  ANDLW  C0
0126:  IORLW  0F
0128:  MOVWF  FC1
012A:  MOVLW  07
012C:  MOVWF  FB4
012E:  CLRF   x9C
0130:  CLRF   x9D
....................    setupTimerIOSC();                                                      
0132:  BRA    066A
....................    printOn2x16();     
0134:  BRA    06FA
....................    while (TRUE){                                                                        
....................      WDTreset();          
0136:  BRA    00FA
....................                                       
....................      if(tmr1_time.tmr1_flags._2ms){ 
0138:  BTFSS  18.0
013A:  BRA    0144
....................         tmr1_time.tmr1_flags._2ms = false;                                                                                               
013C:  BCF    18.0
....................         if(LCDW1SecFlag){      
013E:  MOVF   3A,F
0140:  BZ    0144
....................            LCD_String();                               
0142:  BRA    0784
....................         }                  
....................      }                  
....................      if(tmr1_time.tmr1_flags._20ms){ 
0144:  BTFSS  18.1
0146:  BRA    014A
....................         tmr1_time.tmr1_flags._20ms = false;      
0148:  BCF    18.1
....................      }                                         
....................      if(tmr1_time.tmr1_flags._1000ms){                       
014A:  BTFSS  18.6
014C:  BRA    018A
....................         tmr1_time.tmr1_flags._1000ms = false;  
014E:  BCF    18.6
....................         if(!DS1990A.X.SEARCH_DONE)                    
0150:  BTFSC  48.0
0152:  BRA    0168
....................            ds1990SearchRom(&INTCON,7,1); 
0154:  MOVLW  0F
0156:  MOVWF  xA2
0158:  MOVLW  F2
015A:  MOVWF  xA1
015C:  MOVLW  07
015E:  MOVWF  xA3
0160:  MOVLW  01
0162:  MOVWF  xA4
0164:  GOTO   0B98
....................         if(DS1990A.X.MATCH_DONE && DS1990A.X.SEARCH_DONE)  
0168:  BTFSS  48.1
016A:  BRA    0184
016C:  BTFSS  48.0
016E:  BRA    0184
....................            ds1990ReadAndMatch(&INTCON,7,1);     
0170:  MOVLW  0F
0172:  MOVWF  xA2
0174:  MOVLW  F2
0176:  MOVWF  xA1
0178:  MOVLW  07
017A:  MOVWF  xA3
017C:  MOVLW  01
017E:  MOVWF  xA4
0180:  GOTO   107E
....................            PORTB_7=~PORTB_7;                             
0184:  BTG    F81.7
....................         LCDW1SecFlag=1;        
0186:  MOVLW  01
0188:  MOVWF  3A
....................      }                                
018A:  BRA    0136
....................   }   
.................... }   
....................  
018C:  SLEEP 
....................                                   
.................... void WDTreset(void){          
....................    #asm                   
*
00FA:  CLRWDT
....................    CLRWDT                           
....................    #endasm                                  
00FC:  GOTO   0138 (RETURN)
.................... }            
....................                                         

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 061E   PUT BROWNOUT BORV21 NOWDT WDT8
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
