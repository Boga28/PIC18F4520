CCS PCH C Compiler, Version 5.015, 5967               13-Aug-23 18:24

               Filename:   C:\18F4520\CCS\I2C-RTC-EEPROM-LCD\main.lst

               ROM used:   1314 bytes (4%)
                           Largest free fragment is 30768
               RAM used:   105 (7%) at main() level
                           116 (8%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   0456
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir. 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  CLRF   FF7
009E:  ADDLW  B0
00A0:  MOVWF  FF6
00A2:  MOVLW  00
00A4:  ADDWFC FF7,F
00A6:  TBLRD*+
00A8:  MOVF   FF5,W
00AA:  BTFSC  0D.7
00AC:  BSF    FF2.7
00AE:  RETURN 0
00B0:  DATA 49,4E
00B2:  DATA 46,4F
00B4:  DATA 52,4D
00B6:  DATA 45,4C
00B8:  DATA 45,4B
00BA:  DATA 54,52
00BC:  DATA 4F,4E
00BE:  DATA 49,4B
00C0:  DATA 41,52
00C2:  DATA 2D,47
00C4:  DATA 45,20
00C6:  DATA 20,20
00C8:  DATA 20,53
00CA:  DATA 54,41
00CC:  DATA 4A,59
00CE:  DATA 45,52
00D0:  DATA 00,00
00D2:  DATA 20,20
00D4:  DATA 25,30
00D6:  DATA 32,64
00D8:  DATA 20,3A
00DA:  DATA 20,25
00DC:  DATA 30,32
00DE:  DATA 64,20
00E0:  DATA 3A,20
00E2:  DATA 25,30
00E4:  DATA 32,64
00E6:  DATA 20,20
00E8:  DATA 20,25
00EA:  DATA 73,20
00EC:  DATA 2D,20
00EE:  DATA 25,30
00F0:  DATA 32,64
00F2:  DATA 2F,25
00F4:  DATA 30,32
00F6:  DATA 64,2F
00F8:  DATA 25,30
00FA:  DATA 32,64
00FC:  DATA 00,00
*
0402:  DATA 20,20
0404:  DATA 20,20
0406:  DATA 20,20
0408:  DATA 25,63
040A:  DATA 20,20
040C:  DATA 20,20
040E:  DATA 20,20
0410:  DATA 00,00
0412:  CLRF   01
0414:  CLRF   02
0416:  CLRF   00
0418:  CLRF   03
041A:  MOVF   72,W
041C:  BNZ   0422
041E:  MOVF   71,W
0420:  BZ    0452
0422:  MOVLW  10
0424:  MOVWF  73
0426:  BCF    FD8.0
0428:  RLCF   6F,F
042A:  RLCF   70,F
042C:  RLCF   00,F
042E:  RLCF   03,F
0430:  MOVF   72,W
0432:  SUBWF  03,W
0434:  BNZ   043A
0436:  MOVF   71,W
0438:  SUBWF  00,W
043A:  BNC   044A
043C:  MOVF   71,W
043E:  SUBWF  00,F
0440:  BTFSS  FD8.0
0442:  DECF   03,F
0444:  MOVF   72,W
0446:  SUBWF  03,F
0448:  BSF    FD8.0
044A:  RLCF   01,F
044C:  RLCF   02,F
044E:  DECFSZ 73,F
0450:  BRA    0426
0452:  GOTO   0488 (RETURN)
*
071A:  MOVFF  68,FEA
071E:  MOVFF  67,FE9
0722:  MOVFF  6D,FEF
0726:  INCF   FE9,F
0728:  BTFSC  FD8.2
072A:  INCF   FEA,F
072C:  CLRF   FEF
072E:  INCF   67,F
0730:  BTFSC  FD8.2
0732:  INCF   68,F
0734:  RETURN 0
0736:  TBLRD*+
0738:  MOVFF  FF6,6B
073C:  MOVFF  FF7,6C
0740:  MOVFF  FF5,6D
0744:  RCALL  071A
0746:  MOVFF  6B,FF6
074A:  MOVFF  6C,FF7
074E:  DECFSZ 6A,F
0750:  BRA    0736
0752:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanýr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       Â· LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       Â· WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini saðlar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       Â· PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin içine yükleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       Â· PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       Â· BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       Â· INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       Â· NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */                                
....................                                                          
.................... #FUSES NOWDT, WDT1, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC  
.................... #use delay (internal=8MHz)                   
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7) 
.................... //#use i2c(Master, Fast=100000, sda=PIN_C4, scl=PIN_C3, SMBUS)             
....................                                                                                            
.................... #include "definitions.h"                                                                                                       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "main.h"                                                               
.................... #ifndef MAIN_H      
.................... #define MAIN_H  
.................... #define DELAY 500  
....................                             
.................... void WDTreset(void);   
....................                      
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"                                     
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................                                                                                                       
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h"                                                                                          
.................... #ifndef INITS_H 
.................... #define INITS_H       
....................  
.................... extern uint16_t iSayac;  
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _2ms    : 1;  //bit:0, 2ms  
....................       uint8_t _20ms   : 1;  //bit:2, 20ms  
....................       uint8_t _50ms   : 1;  //bit:3, 50ms  
....................       uint8_t _100ms  : 1;  //bit:4, 100ms     
....................       uint8_t _200ms  : 1;  //bit:5, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:6, 500ms  
....................       uint8_t _1000ms : 1;  //bit:7, 1000ms  
....................       uint8_t _200msKEYPAD     : 1; 
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t tmr1_time;     
....................  
....................  
....................  
....................  
....................                                                 
.................... #endif //INIT_H                               
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "DS1307.h" 
.................... #ifndef DS1307_H      
.................... #define DS1307_H    
....................  
.................... //DS1307 TIME-DATE INFO VARIABLES   
.................... extern uchar_t sec, min, hrs; 
.................... extern uchar_t day, month, yr, dow;       
.................... extern uchar_t dayText[4];  
.................... //READ WRITE SET QUEUE 
.................... extern uchar_t timeSwitchPosition; 
.................... //LCD BUFFER 
.................... extern uchar_t DATE_TIME[32]; 
....................             
....................  
.................... void DS1307_Init();     
.................... void ds1307_run(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t);   
.................... void ds1307_set_date_time(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t);   
.................... void ds1307_get_date(); 
.................... void ds1307_get_time();                                     
.................... void getDayText();                     
....................                
.................... uchar_t getSec(); 
.................... uchar_t getMin();                     
.................... uchar_t getHour(); 
....................                            
.................... uchar_t getDay();  
.................... uchar_t getMonth();  
.................... uchar_t getYear(); 
.................... uchar_t getDow();                                                                  
....................                 
.................... uint16_t day_of_the_week(uint16_t, uint16_t, uint16_t );                   
....................                     
.................... #endif //DS1307_H                      
....................                                        
....................  
.................... #include "24lc256.h"   
.................... #include "definitions.h"     
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef 24LC256_H                                          
.................... #define 24LC256_H   
.................... #define EEPROM_ADDRESS 0xA0 
....................   
.................... void eeprom_test();                           
.................... void eeprom_write_char(uchar_t, uchar_t, uchar_t); 
.................... uchar_t eeprom_read_char(uchar_t, uchar_t);                                                   
....................                                                    
.................... #endif //24LC256_H 
....................  
....................                                                              
.................... #include "lcd.c"                                  
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................                                                                                                       
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "delayms.h"  
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................                  
....................                
.................... /*Hex Code   LCD Ekran Karsiligi  
....................  Initialize Lcd in 4-bit mode               0x02 
.................... 1   Function Set: 8-bit, 1 Line, 5×7 Dots   0x30   48                                              
.................... 2   Function Set: 8-bit, 2 Line, 5×7 Dots   0x38   56                            
.................... 3   Function Set: 4-bit, 1 Line, 5×7 Dots   0x20   32 
.................... 4   Function Set: 4-bit, 2 Line, 5×7 Dots   0x28   40  
.................... 0F   LCD acik, Imlec acik 
.................... 01   Ekrani Temizle                                 
.................... 02   Satir Basina Dön            
.................... 04   Imleci Sola Kaydir 
.................... 06   Imleci Saga Kaydir 
.................... 05   Ekrani Saga Kaydir 
.................... 07   Ekrani Sola Kaydir 
.................... 0E   Ekran Acik, Imleç Yanip Sonuyor 
.................... 80   Imleci Ilk Satirin Basinda Konumlandir 
.................... C0   Imleci Ikinci Satirin Basinda Konumlandir         
.................... 3C   Ikinci Satiri Etkinlestir                                                     
.................... 08   Ekran Kapali, Imleç Kapali              
.................... OC   Ekran Acik, Imlec Kapali*/   
....................                                             
.................... uchar_t strLCD[32]; 
.................... uint8_t countLCDChar; 
.................... uchar_t LCDW1SecFlag; 
....................                                          
.................... /*LCD (CHIP: HD44780), COMMAND MODE*/  
.................... void dis_cmd(uchar_t cmdout){  
....................    PORTD=cmdout;      //Send command to lcdport=PORTB 
*
0500:  MOVFF  6B,F8C
....................    PORTE_RS=0;                   
0504:  BCF    F84.0
....................    PORTE_E=1;                
0506:  BSF    F84.1
....................    delayUsFun(1); 
0508:  MOVLW  01
050A:  MOVWF  6D
050C:  RCALL  04F2
....................    PORTE_E=0;                               
050E:  BCF    F84.1
0510:  RETURN 0
.................... }                                   
....................  
....................  
....................  
.................... void lcdcmd(uchar_t cmd_value){          
....................    uchar_t cmd_value1;                              
....................    cmd_value1 = (cmd_value & 0xF0);      // Mask lower nibble because RB4-RB7 pins are being used    
0512:  MOVF   69,W
0514:  ANDLW  F0
0516:  MOVWF  6A
....................    dis_cmd(cmd_value1);                   // Send to LCD 
0518:  MOVFF  6A,6B
051C:  RCALL  0500
....................    cmd_value1 = ((cmd_value<<4) & 0xF0);  // Shift 4-bit and mask 
051E:  SWAPF  69,W
0520:  MOVWF  00
0522:  MOVLW  F0
0524:  ANDWF  00,F
0526:  MOVF   00,W
0528:  ANDLW  F0
052A:  MOVWF  6A
....................    dis_cmd(cmd_value1);                   // Send to LCD 
052C:  MOVFF  6A,6B
0530:  RCALL  0500
0532:  RETURN 0
.................... } 
....................  // 2 lines are active.              
.................... void twoLinesBCDMode(){  
....................    lcdcmd(0x02); 
0534:  MOVLW  02
0536:  MOVWF  69
0538:  RCALL  0512
053A:  GOTO   056E (RETURN)
.................... } 
....................                         
.................... // 2 lines are active. BCD MODE 
.................... void LinesActive(){  
....................    lcdcmd(0x28);                
053E:  MOVLW  28
0540:  MOVWF  69
0542:  RCALL  0512
0544:  GOTO   0570 (RETURN)
.................... }                          
.................... // LCD screen clear.                   
.................... void lcdClear(){ 
....................    lcdcmd(0x01);                   
*
055C:  MOVLW  01
055E:  MOVWF  69
0560:  RCALL  0512
0562:  GOTO   0576 (RETURN)
.................... }                   
.................... // Go to first line. 
.................... void lcdGoToFirstLine(){  
....................    lcdcmd(0x80); 
*
05C0:  MOVLW  80
05C2:  MOVWF  69
05C4:  RCALL  0512
05C6:  GOTO   0610 (RETURN)
.................... }                                  
.................... // Go to second line.                        
.................... void lcdGoToSecondLine(){ 
....................    lcdcmd(0xC0); 
05CA:  MOVLW  C0
05CC:  MOVWF  69
05CE:  RCALL  0512
05D0:  GOTO   0618 (RETURN)
.................... }                        
.................... // Shift cursor to right. 
.................... void lcdShiftRight(){   
....................    lcdcmd(0x06);                                                     
*
0552:  MOVLW  06
0554:  MOVWF  69
0556:  RCALL  0512
0558:  GOTO   0574 (RETURN)
.................... }                                           
.................... // Display on, Cursor on              
.................... void lcdCursorOn(){                  
....................    lcdcmd(0x0E); 
.................... }                                      
.................... //Display off, Cursor off 
.................... void lcdCursorOff(){                                             
....................    lcdcmd(0x0C);                             
*
0548:  MOVLW  0C
054A:  MOVWF  69
054C:  RCALL  0512
054E:  GOTO   0572 (RETURN)
.................... }                              
....................   
.................... void dis_data(uchar_t dataout) {  
....................    PORTD=dataout;   //Send data to lcdport=PORTB 
*
05D4:  MOVFF  6C,F8C
....................    PORTE_RS=1;                   
05D8:  BSF    F84.0
....................    PORTE_E=1;                          
05DA:  BSF    F84.1
....................    delayUsFun(1); 
05DC:  MOVLW  01
05DE:  MOVWF  6D
05E0:  RCALL  04F2
....................    PORTE_E=0;   
05E2:  BCF    F84.1
05E4:  RETURN 0
....................    //PORTD=0x00; 
....................    //while(test_bit(PORTD,7));           
.................... }   
.................... /*DATA MODE*/   
.................... void lcddata(uchar_t text){  
....................    uchar_t data;                                                                 
....................    data=(text & 0xF0);         
05E6:  MOVF   6A,W
05E8:  ANDLW  F0
05EA:  MOVWF  6B
....................    dis_data(data);     
05EC:  MOVFF  6B,6C
05F0:  RCALL  05D4
....................    data=((text<<4)&0xF0);      
05F2:  SWAPF  6A,W
05F4:  MOVWF  00
05F6:  MOVLW  F0
05F8:  ANDWF  00,F
05FA:  MOVF   00,W
05FC:  ANDLW  F0
05FE:  MOVWF  6B
....................    dis_data(data);                  
0600:  MOVFF  6B,6C
0604:  RCALL  05D4
0606:  GOTO   0636 (RETURN)
.................... }                                
.................... void LCD_String(){  
....................    if(countLCDChar==0)  
060A:  MOVF   39,F
060C:  BNZ   0610
....................       lcdGoToFirstLine(); 
060E:  BRA    05C0
....................    if(countLCDChar==16)   
0610:  MOVF   39,W
0612:  SUBLW  10
0614:  BNZ   0618
....................       lcdGoToSecondLine();    
0616:  BRA    05CA
....................    if(countLCDChar<=31){  
0618:  MOVF   39,W
061A:  SUBLW  1F
061C:  BNC   063A
....................       lcddata(strLCD[countLCDChar]); 
061E:  CLRF   03
0620:  MOVF   39,W
0622:  ADDLW  19
0624:  MOVWF  FE9
0626:  MOVLW  00
0628:  ADDWFC 03,W
062A:  MOVWF  FEA
062C:  MOVFF  FEF,69
0630:  MOVFF  69,6A
0634:  BRA    05E6
....................       countLCDChar++;   
0636:  INCF   39,F
....................    }else{    
0638:  BRA    063E
....................       LCDW1SecFlag=0; 
063A:  CLRF   3A
....................       countLCDChar=0; 
063C:  CLRF   39
....................    }                  
063E:  GOTO   0154 (RETURN)
.................... }  
....................  
....................  
.................... void LCD_Custom_Char(uchar_t loc, uchar_t *msg){ 
....................     uchar_t i; 
....................     if(loc<8) 
....................     { 
....................      lcdcmd(0x40 + (loc*8));    /* Command 0x40 and onwards forces the device to point CGRAM address */ 
....................      for(i=0;i<8;i++)          /* Write 8 byte for generation of 1 character */ 
....................         lcddata(msg[i]);       
....................     }                        
.................... } 
....................  
....................                                           
....................  
....................       
....................  
.................... #include "delayms.c"  
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs){  // Delay function - generates a delay of specified msecs 
....................    uint16_t i; 
....................    uint8_t j;  
....................    for(i=0;i<=msecs;i++) 
....................    for(j=0;j<205;j++); /*This count Provide delay of 1 ms for 8MHz Frequency */                              
.................... }        
....................  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
*
04F2:  CLRF   6E
04F4:  MOVF   6E,W
04F6:  SUBWF  6D,W
04F8:  BNC   04FE
04FA:  INCF   6E,F
04FC:  BRA    04F4
....................     }                                
04FE:  RETURN 0
.................... }   
....................  
....................  
.................... #include "DS1307.c"  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                   /// 
.................... ///                     Driver for Real Time Clock                           /// 
.................... ///                                                                          /// 
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -/// 
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     /// 
.................... ///               - Disable squarewave output                                /// 
.................... ///                                                                          /// 
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             /// 
.................... ///                                                                          /// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
....................                                                                                               
.................... #include "binbcdconv.c"   
.................... #include "binbcdconv.h" 
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef BINBCDCONV_H         
.................... #define BINBCDCONV_H   
....................  
.................... uchar_t bin2bcd(uchar_t binary_value); 
.................... uchar_t bcd2bin(uchar_t bcd_value); 
....................                          
.................... #endif //BINBCDCONV_H      
....................  
....................                                                      
.................... uchar_t bin2bcd(uchar_t binary_value){ 
....................   uchar_t retval;                     
....................   retval = 0;                                                
....................   while(1){ 
....................     if(binary_value >= 10){    // 10'dan buyuk oldugu muddetce                                     
....................       binary_value   -= 10;    // 10 cikar 
....................       retval += 0x10;  //asil degiskenimizin MsB'sine 1 ekle      
....................     }  
....................     else{  
....................       retval += binary_value;  //artik 10'dan buyuk degil kalan 0-9 arasi sayiyi asil degiskenimize ekle                             
....................       break;                 
....................     } 
....................   } 
....................   return(retval);   
.................... } 
....................                            
....................                                
.................... // 8-Bit ile oldugu icin 0-99 arasi bir bcd sayi yazilmalidir.  
.................... uchar_t bcd2bin(uchar_t bcd_value){  
....................          // (bcd_value>>4)*10) BCD'nin 10 luk kisim ilk 4 bite kaydirildi ve 10 ile carpildi. 
....................          // (bcd_value & 0x0F) BCD'nin yuksek degerli 4 biti sifirlandi ve 0-9 kismi birakildi. 
....................          // 2 sayi toplanarak binary karsiligi elde edildi. 
....................   return ((bcd_value>>4)*10) + (bcd_value & 0x0F);   
.................... }                      
....................  
.................... #include "DS1307.h"   
.................... #ifndef DS1307_H      
.................... #define DS1307_H    
....................  
.................... //DS1307 TIME-DATE INFO VARIABLES   
.................... extern uchar_t sec, min, hrs; 
.................... extern uchar_t day, month, yr, dow;       
.................... extern uchar_t dayText[4];  
.................... //READ WRITE SET QUEUE 
.................... extern uchar_t timeSwitchPosition; 
.................... //LCD BUFFER 
.................... extern uchar_t DATE_TIME[32]; 
....................             
....................  
.................... void DS1307_Init();     
.................... void ds1307_run(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t);   
.................... void ds1307_set_date_time(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t);   
.................... void ds1307_get_date(); 
.................... void ds1307_get_time();                                     
.................... void getDayText();                     
....................                
.................... uchar_t getSec(); 
.................... uchar_t getMin();                     
.................... uchar_t getHour(); 
....................                            
.................... uchar_t getDay();  
.................... uchar_t getMonth();  
.................... uchar_t getYear(); 
.................... uchar_t getDow();                                                                  
....................                 
.................... uint16_t day_of_the_week(uint16_t, uint16_t, uint16_t );                   
....................                     
.................... #endif //DS1307_H                      
....................                                        
....................  
.................... #include "i2c.h"  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef I2C_H 
.................... #define I2C_H      
....................  
....................             
.................... void _I2C_Start(void);        
.................... void _I2C_ReStart(void);     
.................... void _I2C_Stop(void);               
.................... void _I2CACK(void);   
.................... void _I2CNACK(void); 
.................... void _I2C_WAIT(void); 
.................... uchar_t _I2C_Write_Byte(uchar_t);   
.................... uchar_t _I2C_Read_Byte(uchar_t);            
....................                
.................... #endif //I2C_H      
....................  
.................... #include "i2c.c" 
.................... #include "i2c.h"                                                                                         
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef I2C_H 
.................... #define I2C_H      
....................  
....................             
.................... void _I2C_Start(void);        
.................... void _I2C_ReStart(void);     
.................... void _I2C_Stop(void);               
.................... void _I2CACK(void);   
.................... void _I2CNACK(void); 
.................... void _I2C_WAIT(void); 
.................... uchar_t _I2C_Write_Byte(uchar_t);   
.................... uchar_t _I2C_Read_Byte(uchar_t);            
....................                
.................... #endif //I2C_H      
....................  
.................... #include "definitions.h"     
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "ucregisters.h"         
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................                                                                                                       
.................... #endif UCREGISTER_H                                                                          
....................  
....................             
.................... void _I2C_WAIT(){ 
....................    while ( ( SSPCON2 & 0x1F ) || ( SSPSTAT & 0x04 ) ); 
*
064A:  MOVF   FC5,W
064C:  ANDLW  1F
064E:  BNZ   064A
0650:  BTFSC  FC7.2
0652:  BRA    064A
0654:  RETURN 0
....................    // wait for any pending transfer  
.................... }                                     
.................... // Function Purpose: I2C_Write_Byte transfers one byte  
.................... uchar_t _I2C_Write_Byte(uchar_t data){               
....................    SSPBUF = data;      // Send Byte value 
0656:  MOVFF  6C,FC9
....................    while(BF);      // Wait for it to complete  
065A:  BTFSC  FC7.0
065C:  BRA    065A
....................    _I2C_WAIT(); 
065E:  RCALL  064A
....................    return ACKSTAT;     // Return ACK/NACK from slave 
0660:  MOVLW  00
0662:  BTFSC  FC5.6
0664:  MOVLW  01
0666:  MOVWF  01
0668:  RETURN 0
.................... }                            
....................                                          
.................... // Function Purpose: I2C_Read_Byte reads one byte 
.................... uchar_t _I2C_Read_Byte(uchar_t flag){     
*
06BA:  CLRF   6D
....................    uchar_t receive = 0; 
....................    RCEN = 1;                     
06BC:  BSF    FC5.3
....................    while(!BF);      // Wait for it to complete          
06BE:  BTFSS  FC7.0
06C0:  BRA    06BE
....................    receive = SSPBUF;     
06C2:  MOVFF  FC9,6D
....................    if(flag==0)  
06C6:  MOVF   6C,F
06C8:  BNZ   06CE
....................       _I2CACK();                                      
06CA:  BRA    06A2
06CC:  BRA    06D0
....................    else 
....................       _I2CNACK();  
06CE:  BRA    06AE
....................    _I2C_WAIT();  
06D0:  RCALL  064A
....................    return receive; // Return The Received Byte   
06D2:  MOVFF  6D,01
06D6:  GOTO   070E (RETURN)
.................... }     
....................    
.................... void _I2C_Start(void){  
....................    SEN = 1;         // Start condition enabled  
*
0642:  BSF    FC5.0
....................    while(SEN);      // automatically cleared by hardware  
0644:  BTFSC  FC5.0
0646:  BRA    0644
0648:  RETURN 0
....................                     // wait for start condition to finish   
.................... }   
....................  
.................... void _I2C_ReStart(void){ 
....................    RSEN = 1;         // Send Restart bit 
*
066A:  BSF    FC5.1
....................    while(RSEN);      // Wait for it to complete 
066C:  BTFSC  FC5.1
066E:  BRA    066C
0670:  RETURN 0
.................... }                     
....................                                             
.................... //Function : I2C_Stop sends stop bit sequence  
.................... void _I2C_Stop(void){      
....................    PEN = 1;      // Initiate Stop condition on SDA and SCL pins  
0672:  BSF    FC5.2
....................    while(PEN);   // Wait for stop condition to finish  
0674:  BTFSC  FC5.2
0676:  BRA    0674
0678:  RETURN 0
....................                      // PEN automatically cleared by hardware  
.................... }     
....................  
.................... void _I2CACK(void){ 
....................    ACKDT = 0; //Acknowledge Data bit   
*
06A2:  BCF    FC5.5
....................    ACKEN = 1;  // Acknowledge Sequence Enable bit    
06A4:  BSF    FC5.4
....................    while(ACKEN);      // Wait for it to complete 
06A6:  BTFSC  FC5.4
06A8:  BRA    06A6
06AA:  GOTO   06D0 (RETURN)
.................... }        
....................  
.................... void _I2CNACK(void){ 
....................    ACKDT = 1;    
06AE:  BSF    FC5.5
....................    ACKEN = 1;  
06B0:  BSF    FC5.4
....................    while(ACKEN);      // Wait for it to complete     
06B2:  BTFSC  FC5.4
06B4:  BRA    06B2
06B6:  GOTO   06D0 (RETURN)
.................... }       
....................  
....................                                         
.................... // START(0) <--------------0xD - 13 is adres of DS1307----------------->  <-R/W->                  <-DATA->    ACK    STOP(1)  
.................... //|------| |------| |------| |------| |------| |------| |------| |------| |------|       |------|  |------| |------| |------|   
.................... //|  S   | |   1  |-|   1  |-|   0  |-|   1  |-|   0  |-|   0  |-|   0  |-|   0  |       |   0  |  |nx8BIT| |   0  | |  P   |    
.................... //|------| |------| |------| |------| |------| |------| |------| |------| |------|       |------|  |------| |------| |------|    
.................... //          7.Bit    6.Bit    5.Bit    4.Bit    3.Bit    2.Bit    1.Bit    0.Bit           ACK                       
....................                          
.................... uchar_t sec, min, hrs; 
.................... uchar_t day, month, yr, dow;          
.................... uchar_t dayText[4];  
.................... uchar_t timeSwitchPosition; 
.................... uchar_t DATE_TIME[32]; 
....................  
.................... void DS1307_Init(){   
....................     _I2C_Start();          
....................     while(_I2C_Write_Byte(0xD0 + 0) == 1)// Wait until device is free 
....................     {   _I2C_ReStart();   }  
....................     _I2C_Write_Byte(0x07);          // Select the Ds1307 ControlRegister to configure Ds1307 
....................     _I2C_Write_Byte(0x00);          // Write 0x00 to Control register to disable SQW-Out       
....................     _I2C_Stop();                // Stop I2C communication after initilizing DS1307 
....................     timeSwitchPosition=0; 
....................  }                                                               
....................         
.................... void ds1307_run(uchar_t day_t, uchar_t mth_t, uchar_t year_t, uchar_t dow_t, uchar_t hr_t, uchar_t min_t, uchar_t sec_t){  
....................    if(timeSwitchPosition>=0 && timeSwitchPosition<=10){  
....................       ds1307_set_date_time(day_t, mth_t, year_t, dow_t, hr_t, min_t, sec_t); 
....................    }  
....................    else if(timeSwitchPosition>=11 && timeSwitchPosition<=19){  
....................       ds1307_get_time();     
....................    } 
....................    else if(timeSwitchPosition>=20 && timeSwitchPosition<=29){ 
....................       ds1307_get_date();         
....................    }        
.................... }                                                                                                                          
....................  
.................... void ds1307_set_date_time(uchar_t day_t, uchar_t mth_t, uchar_t year_t, uchar_t dow_t, uchar_t hr_t, uchar_t min_t, uchar_t sec_t){      
....................    switch(timeSwitchPosition){ 
....................    case 0: 
....................         _I2C_Start();                         // I2C write address  
....................         timeSwitchPosition++;  
....................    break;  
....................       
....................    case 1:  
....................         while(_I2C_Write_Byte(0xD0 + 0) == 1) // Wait until device is free  
....................         {   _I2C_ReStart();   }    
....................         timeSwitchPosition++;  
....................    break;    
....................     
....................    case 2:  
....................         _I2C_Write_Byte(0x00);                // Start at REG 0 - Seconds   
....................         timeSwitchPosition++;  
....................    break;  
....................     
....................    case 3:   
....................         sec_t &= 0x7F; 
....................         _I2C_Write_Byte(bin2bcd(sec_t));      // REG 0   
....................         timeSwitchPosition++;  
....................    break;    
....................     
....................    case 4:  
....................         min_t &= 0x7F; 
....................         _I2C_Write_Byte(bin2bcd(min_t));      // REG 1   
....................         timeSwitchPosition++;  
....................    break;     
....................     
....................    case 5:  
....................         hr_t &= (0x7F|0x40);  //format 24H  
....................         _I2C_Write_Byte(bin2bcd(hr_t));       // REG 2  
....................         timeSwitchPosition++;  
....................    break;  
....................     
....................    case 6: 
....................         _I2C_Write_Byte(bin2bcd(dow_t));      // REG 3  
....................         timeSwitchPosition++;  
....................    break;    
....................     
....................    case 7:  
....................        _I2C_Write_Byte(bin2bcd(day_t));      // REG 4   
....................        timeSwitchPosition++;  
....................    break;   
....................     
....................    case 8:  
....................        _I2C_Write_Byte(bin2bcd(mth_t));      // REG 5   
....................        timeSwitchPosition++;  
....................    break;    
....................     
....................    case 9: 
....................        _I2C_Write_Byte(bin2bcd(year_t));     // REG 6  
....................        timeSwitchPosition++;  
....................    break; 
....................     
....................    case 10: 
....................        _I2C_Stop();         
....................        timeSwitchPosition++;  
....................    break;            
....................   }            
.................... }                              
....................     
.................... void ds1307_get_time(){  
....................  switch(timeSwitchPosition){ 
....................    case 11: 
....................         _I2C_Start();                         // I2C write address  
....................         timeSwitchPosition++;  
....................    break;  
....................       
....................    case 12:  
....................         while(_I2C_Write_Byte(0xD0 + 0) == 1)   // Wait until device is free 
....................         {   _I2C_ReStart();   }     
....................         timeSwitchPosition++;  
....................    break;    
....................     
....................    case 13:  
....................         _I2C_Write_Byte(0x00);                  // Start at REG 3 - Day of week   
....................         timeSwitchPosition++;  
....................    break;  
....................     
....................    case 14:   
....................         _I2C_ReStart();  
....................         timeSwitchPosition++;  
....................    break;    
....................     
....................    case 15:  
....................         _I2C_Write_Byte(0xD0 + 1);   
....................         timeSwitchPosition++;  
....................    break;     
....................     
....................    case 16:                 
....................         sec = bcd2bin(_I2C_Read_Byte(0) & 0x7F);  
....................         timeSwitchPosition++;  
....................    break;  
....................     
....................    case 17: 
....................         min = bcd2bin(_I2C_Read_Byte(0) & 0x7F); 
....................         timeSwitchPosition++;  
....................    break;    
....................                                 
....................    case 18: 
....................         hrs = bcd2bin(_I2C_Read_Byte(1) & 0x7F); 
....................         timeSwitchPosition++;  
....................    break;   
....................     
....................    case 19:  
....................         _I2C_Stop();    
....................         timeSwitchPosition++;  
....................    break;   
....................  
....................   }                    
.................... }                                                     
....................  
.................... void ds1307_get_date(){ 
....................    switch(timeSwitchPosition){ 
....................    case 20: 
....................         _I2C_Start();                         // I2C write address  
....................         timeSwitchPosition++;  
....................    break;      
....................       
....................    case 21:  
....................         while(_I2C_Write_Byte(0xD0 + 0) == 1)   // Wait until device is free 
....................         {   _I2C_ReStart();   }  
....................         timeSwitchPosition++;  
....................    break;    
....................                 
....................    case 22:  
....................         _I2C_Write_Byte(0x03);                  // Start at REG 3 - Day of week   
....................         timeSwitchPosition++;  
....................    break;  
....................     
....................    case 23:   
....................         _I2C_ReStart();  
....................         timeSwitchPosition++;  
....................    break;    
....................     
....................    case 24:  
....................         _I2C_Write_Byte(0xD0 + 1);   
....................         timeSwitchPosition++;  
....................    break;     
....................     
....................    case 25:  
....................         // lecture DS1307 retourne (une valeur binaire codee BCD 
....................          // ex retourne 19 ou 0x13   l'an 13                  
....................         dow    = bcd2bin(_I2C_Read_Byte(0) & 0x07);   // REG 3  
....................         timeSwitchPosition++;  
....................    break;  
....................     
....................    case 26: 
....................         day    = bcd2bin(_I2C_Read_Byte(0) & 0x3F);   // REG 4  
....................         timeSwitchPosition++;  
....................    break;    
....................     
....................    case 27: 
....................         month  = bcd2bin(_I2C_Read_Byte(0) & 0x1F);   // REG 5 
....................         timeSwitchPosition++;  
....................    break;   
....................     
....................    case 28:  
....................         yr     = bcd2bin(_I2C_Read_Byte(1));    // REG 6   
....................         timeSwitchPosition++;  
....................    break;   
....................     
....................    case 29:  
....................        _I2C_Stop();  
....................        getDayText();  
....................        sprintf(DATE_TIME,"  \%02d : \%02d : \%02d   %s - \%02d/\%02d/\%02d",hrs,min,sec,dayText,day,month,yr);        
....................        memcpy(strLCD,DATE_TIME,32); 
....................        eeprom_test();  
....................        timeSwitchPosition=11;  
....................    break;    
....................   }            
.................... }      
....................  
....................          
....................             
....................        
.................... void getDayText(){                           
....................    switch(day_of_the_week(getYear(),getMonth(),getDay())){ 
....................      case 0: memcpy(dayText,"Sun",3); break; 
....................      case 1: memcpy(dayText,"Mon",3); break; 
....................      case 2: memcpy(dayText,"Tue",3); break; 
....................      case 3: memcpy(dayText,"Wed",3); break; 
....................      case 4: memcpy(dayText,"Thu",3); break; 
....................      case 5: memcpy(dayText,"Fri",3); break; 
....................      case 6: memcpy(dayText,"Sat",3); break; 
....................    }  
.................... }    
....................  
.................... uchar_t getSec(){ 
....................    return sec;   
.................... }  
.................... uchar_t getMin(){ 
....................    return min;   
.................... }   
.................... uchar_t getHour(){                     
....................    return hrs; 
.................... }   
.................... uchar_t getDow(){ 
....................    return dow;   
.................... }   
.................... uchar_t getDay(){ 
....................    return day;   
.................... }  
.................... uchar_t getMonth(){ 
....................    return month;   
.................... }   
.................... uchar_t getYear(){ 
....................    return yr;   
.................... }                                            
.................... // <-------------      (0-7, Start Sunday)       ----------->  
.................... uint16_t day_of_the_week(uint16_t Y, uint16_t M, uint16_t D) {  
....................    uint16_t days[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };  
....................    if (M < 3)  
....................       Y--;         
....................    return (Y + Y / 4 - Y / 100 + Y / 400 + days[M - 1] + D) % 7;  
.................... }  
....................  
....................                                                                                                                 
....................  
.................... #include "24lc256.c"   
.................... #include "definitions.h"     
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................                                                                                                       
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "24lc256.h"  
.................... #include "definitions.h"     
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef 24LC256_H                                          
.................... #define 24LC256_H   
.................... #define EEPROM_ADDRESS 0xA0 
....................   
.................... void eeprom_test();                           
.................... void eeprom_write_char(uchar_t, uchar_t, uchar_t); 
.................... uchar_t eeprom_read_char(uchar_t, uchar_t);                                                   
....................                                                    
.................... #endif //24LC256_H 
....................  
....................   
.................... void eeprom_test(){  
....................   eeprom_write_char(0x00,0x00,'R'); 
*
0754:  CLRF   69
0756:  CLRF   6A
0758:  MOVLW  52
075A:  MOVWF  6B
075C:  BRA    067A
....................   delay_us(5); 
075E:  MOVLW  02
0760:  MOVWF  00
0762:  DECFSZ 00,F
0764:  BRA    0762
0766:  BRA    0768
0768:  NOP   
....................   sprintf(DATE_TIME,"      %c      " ,eeprom_read_char(0x00,0x00));   
076A:  CLRF   69
076C:  CLRF   6A
076E:  RCALL  06DA
0770:  MOVFF  01,69
0774:  CLRF   68
0776:  MOVLW  47
0778:  MOVWF  67
077A:  MOVLW  02
077C:  MOVWF  FF6
077E:  MOVLW  04
0780:  MOVWF  FF7
0782:  MOVLW  06
0784:  MOVWF  6A
0786:  RCALL  0736
0788:  MOVFF  69,6D
078C:  RCALL  071A
078E:  MOVLW  0A
0790:  MOVWF  FF6
0792:  MOVLW  04
0794:  MOVWF  FF7
0796:  MOVLW  06
0798:  MOVWF  6A
079A:  RCALL  0736
....................   printf("%c\r",eeprom_read_char(0x00,0x00)); 
079C:  CLRF   69
079E:  CLRF   6A
07A0:  RCALL  06DA
07A2:  MOVF   01,W
07A4:  MOVWF  69
07A6:  BTFSS  F9E.4
07A8:  BRA    07A6
07AA:  MOVWF  FAD
07AC:  MOVLW  0D
07AE:  BTFSS  F9E.4
07B0:  BRA    07AE
07B2:  MOVWF  FAD
....................   memcpy(strLCD,DATE_TIME,32);                               
07B4:  CLRF   FEA
07B6:  MOVLW  19
07B8:  MOVWF  FE9
07BA:  CLRF   FE2
07BC:  MOVLW  47
07BE:  MOVWF  FE1
07C0:  MOVLW  20
07C2:  MOVWF  01
07C4:  MOVFF  FE6,FEE
07C8:  DECFSZ 01,F
07CA:  BRA    07C4
07CC:  GOTO   0156 (RETURN)
.................... } 
.................... void eeprom_write_char(uchar_t addressH, uchar_t addressL, uchar_t value){ 
....................     _I2C_Start();          
*
067A:  RCALL  0642
....................     while(_I2C_Write_Byte(EEPROM_ADDRESS + 0) == 1)// Wait until device is free 
067C:  MOVLW  A0
067E:  MOVWF  6C
0680:  RCALL  0656
0682:  DECFSZ 01,W
0684:  BRA    068A
....................     {   _I2C_ReStart();   }   
0686:  RCALL  066A
0688:  BRA    067C
....................      
....................      //0-14'nci bitler adres bitleridir. 15. bit anlamsiz bittir.  
....................     _I2C_Write_Byte(addressH);   // Adresin yuksek bitleri 
068A:  MOVFF  69,6C
068E:  RCALL  0656
....................     _I2C_Write_Byte(addressL);   // Adresin dusuk bitleri   
0690:  MOVFF  6A,6C
0694:  RCALL  0656
....................     _I2C_Write_Byte(value);      // gonderecegimiz 8 bit 
0696:  MOVFF  6B,6C
069A:  RCALL  0656
....................     _I2C_Stop();                                 
069C:  RCALL  0672
069E:  GOTO   075E (RETURN)
.................... }               
....................  
.................... uchar_t eeprom_read_char(uchar_t addressH, uchar_t addressL){    
*
06DA:  CLRF   6B
....................    uchar_t recieve= 0; 
....................    _I2C_Start();                          
06DC:  RCALL  0642
....................    while(_I2C_Write_Byte(EEPROM_ADDRESS + 0) == 1)// Wait until device is free 
06DE:  MOVLW  A0
06E0:  MOVWF  6C
06E2:  RCALL  0656
06E4:  DECFSZ 01,W
06E6:  BRA    06EC
....................    {   _I2C_ReStart();   }  
06E8:  RCALL  066A
06EA:  BRA    06DE
....................    _I2C_Write_Byte(addressH);   // Adresin yuksek bitleri 
06EC:  MOVFF  69,6C
06F0:  RCALL  0656
....................    _I2C_Write_Byte(addressL);   // Adresin dusuk bitleri 
06F2:  MOVFF  6A,6C
06F6:  RCALL  0656
....................    _I2C_ReStart(); 
06F8:  RCALL  066A
....................    while(_I2C_Write_Byte(EEPROM_ADDRESS + 1) == 1)// Wait until device is free 
06FA:  MOVLW  A1
06FC:  MOVWF  6C
06FE:  RCALL  0656
0700:  DECFSZ 01,W
0702:  BRA    0708
....................     {   _I2C_ReStart();   }          
0704:  RCALL  066A
0706:  BRA    06FA
....................    recieve=_I2C_Read_Byte(1);       
0708:  MOVLW  01
070A:  MOVWF  6C
070C:  BRA    06BA
070E:  MOVFF  01,6B
....................    _I2C_Stop();      
0712:  RCALL  0672
....................     
....................  return recieve; 
0714:  MOVFF  6B,01
0718:  RETURN 0
.................... } 
....................  
....................  
....................                               
....................                                     
.................... //TIMER1 UNION STRUCTURE AND COUNT MS 
.................... tmr1_time_t tmr1_time;  
.................... uint16_t iSayac; 
....................                       
.................... void setupTimerIOSC(void){          
....................    //Setup Osilator 
....................    IRCF2 = 1;   
*
04B6:  BSF    FD3.6
....................    IRCF1 = 1; 
04B8:  BSF    FD3.5
....................    IRCF0 = 1;                    
04BA:  BSF    FD3.4
....................                          
....................    //D ve P portlari cikis olarak ayarlanip sifirlandi. 
....................    TRISB = 0x00;                  
04BC:  CLRF   F93
....................    TRISD = 0x00; 
04BE:  CLRF   F95
....................    TRISE = 0x00;       
04C0:  CLRF   F96
....................    PORTB = 0x00;                                                       
04C2:  CLRF   F81
....................    PORTD = 0x00; 
04C4:  CLRF   F8C
....................    PORTE = 0x00;   
04C6:  CLRF   F84
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
04C8:  CLRF   18
....................  
....................    // Kesmelere izin verildi 
....................    RCON_IPEN = 1;                                               
04CA:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 1; 
04CC:  BSF    FF2.7
....................    INTCON_PEIE = 1;           
04CE:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
04D0:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
04D2:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
04D4:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit 
04D6:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
04D8:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
04DA:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
04DC:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
04DE:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
04E0:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
04E2:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
04E4:  MOVLW  F8
04E6:  MOVWF  FCF
....................    TMR1L = 0x30; // |||65436 decimal sayisina esit. 
04E8:  MOVLW  30
04EA:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit                                            
04EC:  BSF    FCD.0
04EE:  GOTO   0130 (RETURN)
.................... } 
....................                       
.................... void printOn2x16(){                   
....................    delayUsFun(40);                                                                                                                                       
*
0566:  MOVLW  28
0568:  MOVWF  6D
056A:  RCALL  04F2
....................    twoLinesBCDMode();    
056C:  BRA    0534
....................    LinesActive();   
056E:  BRA    053E
....................    lcdCursorOff(); 
0570:  BRA    0548
....................    lcdShiftRight();                      
0572:  BRA    0552
....................    lcdClear();                                                    
0574:  BRA    055C
....................    memcpy(strLCD, "INFORMELEKTRONIKAR-GE    STAJYER", 32); 
0576:  CLRF   FEA
0578:  MOVLW  19
057A:  MOVWF  FE9
057C:  MOVFF  FF2,69
0580:  BCF    FF2.7
0582:  MOVLW  20
0584:  MOVWF  01
0586:  CLRF   FF7
0588:  MOVLW  00
058A:  RCALL  0096
058C:  TBLRD*-
058E:  TBLRD*+
0590:  MOVFF  FF5,FEE
0594:  DECFSZ 01,F
0596:  BRA    058E
0598:  BTFSC  69.7
059A:  BSF    FF2.7
....................    countLCDChar=0;    
059C:  CLRF   39
....................    LCDW1SecFlag=1; 
059E:  MOVLW  01
05A0:  MOVWF  3A
05A2:  GOTO   0132 (RETURN)
....................    // LCD_Custom_CHAR(7, legrandLCDCharacter); 
....................    //LCD_Custom_CHAR(6, stickManLCDCharacter);                                
.................... }                           
....................                                 
.................... void I2C_Init() {     
....................    SCL_DIR = 1;     //Set as a digital input 
05A6:  BSF    F94.3
....................    SDA_DIR = 1;     //Set as a digital input 
05A8:  BSF    F94.4
....................    SSPADD  = 19;  
05AA:  MOVLW  13
05AC:  MOVWF  FC8
....................    SSPCON1 = 0x28;  // enable I2C pins SCL and SDA for serial communication 
05AE:  MOVLW  28
05B0:  MOVWF  FC6
....................    //SSPCON2 = 0x00;   
....................    SSPSTAT = 0x80;  //slew rate disabled for high speed control       
05B2:  MOVLW  80
05B4:  MOVWF  FC7
05B6:  GOTO   0134 (RETURN)
.................... }                                               
....................  
....................  
.................... #INT_TIMER1                                                            
.................... void timer1_interrupt(){  
....................    TMR1H = 0xF8; //Tasma saayci| 
*
0456:  MOVLW  F8
0458:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.  
045A:  MOVLW  30
045C:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor. 
045E:  BCF    F9E.0
....................    iSayac++;  
0460:  INCF   16,F
0462:  BTFSC  FD8.2
0464:  INCF   17,F
....................    if (iSayac % 2 == 0) //2ms   
0466:  MOVF   16,W
0468:  ANDLW  01
046A:  MOVWF  6F
046C:  CLRF   70
046E:  MOVF   6F,F
0470:  BNZ   0478
0472:  MOVF   70,F
0474:  BNZ   0478
....................       tmr1_time.tmr1_flags._2ms = true; 
0476:  BSF    18.0
....................    if (iSayac % 50 == 0) //50ms   
0478:  MOVFF  17,70
047C:  MOVFF  16,6F
0480:  CLRF   72
0482:  MOVLW  32
0484:  MOVWF  71
0486:  BRA    0412
0488:  MOVFF  00,6F
048C:  MOVFF  03,70
0490:  MOVF   6F,F
0492:  BNZ   049A
0494:  MOVF   70,F
0496:  BNZ   049A
....................       tmr1_time.tmr1_flags._20ms = true; 
0498:  BSF    18.1
....................    if(iSayac > 1000){   // 1 Saniye   
049A:  MOVF   17,W
049C:  SUBLW  02
049E:  BC    04B0
04A0:  XORLW  FF
04A2:  BNZ   04AA
04A4:  MOVF   16,W
04A6:  SUBLW  E8
04A8:  BC    04B0
....................       tmr1_time.tmr1_flags._1000ms = true;  
04AA:  BSF    18.6
....................       iSayac = 0;       
04AC:  CLRF   17
04AE:  CLRF   16
....................    }      
.................... }                              
....................                                    
04B0:  BCF    F9E.0
04B2:  GOTO   0054
.................... #ORG 0x0100,0x0400                                                                     
.................... void main(){                                  
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  MOVLW  70
0108:  MOVWF  FD3
010A:  MOVF   FD3,W
010C:  BCF    FB8.3
010E:  MOVLW  0C
0110:  MOVWF  FAF
0112:  MOVLW  A2
0114:  MOVWF  FAC
0116:  MOVLW  90
0118:  MOVWF  FAB
011A:  NOP   
011C:  NOP   
011E:  CLRF   68
0120:  CLRF   67
0122:  MOVF   FC1,W
0124:  ANDLW  C0
0126:  IORLW  0F
0128:  MOVWF  FC1
012A:  MOVLW  07
012C:  MOVWF  FB4
....................    setupTimerIOSC();                                                      
012E:  BRA    04B6
....................    printOn2x16();  
0130:  BRA    0566
....................    I2C_Init();  
0132:  BRA    05A6
....................   // DS1307_Init();   
....................    while (TRUE){                         
....................      WDTreset();                                             
0134:  BRA    05BA
....................      if(tmr1_time.tmr1_flags._1000ms){                       
0136:  BTFSS  18.6
0138:  BRA    0142
....................         tmr1_time.tmr1_flags._1000ms = false;     
013A:  BCF    18.6
....................         PORTB_7=~PORTB_7;                  
013C:  BTG    F81.7
....................         LCDW1SecFlag=1;   
013E:  MOVLW  01
0140:  MOVWF  3A
....................          
....................         //printf("\f\%02d/\%02d/\%02d -->%s\r\n",getDay(),getMonth(),getYear(),dayText); 
....................         //printf("\%02d:\%02d:\%02d", getHour(),getMin(),getSec()); 
....................      }  
....................      if(tmr1_time.tmr1_flags._20ms){ 
0142:  BTFSS  18.1
0144:  BRA    0148
....................         tmr1_time.tmr1_flags._20ms = false; 
0146:  BCF    18.1
....................        // ds1307_run(27,7,23,2,14,59,10); 
....................      } 
....................      if(tmr1_time.tmr1_flags._2ms){ 
0148:  BTFSS  18.0
014A:  BRA    0156
....................         tmr1_time.tmr1_flags._2ms = false;                                                                                               
014C:  BCF    18.0
....................         if(LCDW1SecFlag){      
014E:  MOVF   3A,F
0150:  BZ    0156
....................            LCD_String();   
0152:  BRA    060A
....................            eeprom_test(); 
0154:  BRA    0754
....................                                       
....................         }            
....................      }                    
0156:  BRA    0134
....................   }   
.................... }  
....................  
0158:  SLEEP 
.................... void WDTreset(void){          
....................    #asm                   
*
05BA:  CLRWDT
....................    CLRWDT                           
....................    #endasm                                  
05BC:  GOTO   0136 (RETURN)
.................... }            
....................                                         

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 001E   PUT BROWNOUT BORV21 NOWDT WDT1
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
