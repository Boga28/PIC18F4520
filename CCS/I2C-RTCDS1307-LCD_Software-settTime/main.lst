CCS PCH C Compiler, Version 5.015, 5967               25-Jul-23 19:38

               Filename:   C:\18F4520\CCS\I2C-RTCDS1307-LCD_Software-settTime\main.lst

               ROM used:   5778 bytes (18%)
                           Largest free fragment is 26504
               RAM used:   119 (8%) at main() level
                           164 (11%) worst case
               Stack used: 9 locations (7 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   058C
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir. 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  CLRF   FF7
009E:  ADDLW  B0
00A0:  MOVWF  FF6
00A2:  MOVLW  00
00A4:  ADDWFC FF7,F
00A6:  TBLRD*+
00A8:  MOVF   FF5,W
00AA:  BTFSC  0D.7
00AC:  BSF    FF2.7
00AE:  RETURN 0
00B0:  DATA 49,4E
00B2:  DATA 46,4F
00B4:  DATA 52,4D
00B6:  DATA 45,4C
00B8:  DATA 45,4B
00BA:  DATA 54,52
00BC:  DATA 4F,4E
00BE:  DATA 49,4B
00C0:  DATA 41,52
00C2:  DATA 2D,47
00C4:  DATA 45,20
00C6:  DATA 20,20
00C8:  DATA 20,53
00CA:  DATA 54,41
00CC:  DATA 4A,59
00CE:  DATA 45,52
00D0:  DATA 00,00
00D2:  DATA 20,20
00D4:  DATA 20,20
00D6:  DATA 20,53
00D8:  DATA 45,43
00DA:  DATA 4F,4E
00DC:  DATA 44,20
00DE:  DATA 20,20
00E0:  DATA 20,20
00E2:  DATA 00,00
00E4:  DATA 20,20
00E6:  DATA 20,20
00E8:  DATA 20,4D
00EA:  DATA 49,4E
00EC:  DATA 55,54
00EE:  DATA 45,20
00F0:  DATA 20,20
00F2:  DATA 20,20
00F4:  DATA 00,00
*
0402:  DATA 20,20
0404:  DATA 20,20
0406:  DATA 20,20
0408:  DATA 48,4F
040A:  DATA 55,52
040C:  DATA 20,20
040E:  DATA 20,20
0410:  DATA 20,20
0412:  DATA 00,00
0414:  DATA 20,20
0416:  DATA 20,20
0418:  DATA 20,20
041A:  DATA 20,44
041C:  DATA 41,59
041E:  DATA 20,20
0420:  DATA 20,20
0422:  DATA 20,20
0424:  DATA 00,00
0426:  DATA 20,20
0428:  DATA 20,20
042A:  DATA 20,20
042C:  DATA 4D,4F
042E:  DATA 4E,54
0430:  DATA 48,20
0432:  DATA 20,20
0434:  DATA 20,20
0436:  DATA 00,00
0438:  DATA 20,20
043A:  DATA 20,20
043C:  DATA 20,20
043E:  DATA 59,45
0440:  DATA 41,52
0442:  DATA 20,20
0444:  DATA 20,20
0446:  DATA 20,20
0448:  DATA 00,00
044A:  DATA 20,20
044C:  DATA 20,20
044E:  DATA 20,53
0450:  DATA 45,43
0452:  DATA 4F,4E
0454:  DATA 44,20
0456:  DATA 20,20
0458:  DATA 20,20
045A:  DATA 20,20
045C:  DATA 20,20
045E:  DATA 20,20
0460:  DATA 20,25
0462:  DATA 30,32
0464:  DATA 64,20
0466:  DATA 20,20
0468:  DATA 20,20
046A:  DATA 20,20
046C:  DATA 00,00
046E:  DATA 20,20
0470:  DATA 20,20
0472:  DATA 20,4D
0474:  DATA 49,4E
0476:  DATA 55,54
0478:  DATA 45,20
047A:  DATA 20,20
047C:  DATA 20,20
047E:  DATA 20,20
0480:  DATA 20,20
0482:  DATA 20,20
0484:  DATA 20,25
0486:  DATA 30,32
0488:  DATA 64,20
048A:  DATA 20,20
048C:  DATA 20,20
048E:  DATA 20,20
0490:  DATA 00,00
0492:  DATA 20,20
0494:  DATA 20,20
0496:  DATA 20,20
0498:  DATA 48,4F
049A:  DATA 55,52
049C:  DATA 20,20
049E:  DATA 20,20
04A0:  DATA 20,20
04A2:  DATA 20,20
04A4:  DATA 20,20
04A6:  DATA 20,20
04A8:  DATA 20,25
04AA:  DATA 30,32
04AC:  DATA 64,20
04AE:  DATA 20,20
04B0:  DATA 20,20
04B2:  DATA 20,20
04B4:  DATA 00,00
04B6:  DATA 20,20
04B8:  DATA 20,20
04BA:  DATA 20,20
04BC:  DATA 44,41
04BE:  DATA 59,27
04C0:  DATA 20,20
04C2:  DATA 20,20
04C4:  DATA 20,20
04C6:  DATA 20,20
04C8:  DATA 20,20
04CA:  DATA 20,20
04CC:  DATA 20,25
04CE:  DATA 30,32
04D0:  DATA 64,20
04D2:  DATA 20,20
04D4:  DATA 20,20
04D6:  DATA 20,20
04D8:  DATA 00,00
04DA:  DATA 20,20
04DC:  DATA 20,20
04DE:  DATA 20,20
04E0:  DATA 4D,4F
04E2:  DATA 4E,54
04E4:  DATA 48,20
04E6:  DATA 20,20
04E8:  DATA 20,20
04EA:  DATA 20,20
04EC:  DATA 20,20
04EE:  DATA 20,20
04F0:  DATA 20,25
04F2:  DATA 30,32
04F4:  DATA 64,20
04F6:  DATA 20,20
04F8:  DATA 20,20
04FA:  DATA 00,00
04FC:  DATA 20,20
04FE:  DATA 20,20
0500:  DATA 20,20
0502:  DATA 59,45
0504:  DATA 41,52
0506:  DATA 20,20
0508:  DATA 20,20
050A:  DATA 20,20
050C:  DATA 20,20
050E:  DATA 20,20
0510:  DATA 20,20
0512:  DATA 20,25
0514:  DATA 30,32
0516:  DATA 64,20
0518:  DATA 20,20
051A:  DATA 20,20
051C:  DATA 00,00
051E:  DATA 20,20
0520:  DATA 25,30
0522:  DATA 32,64
0524:  DATA 20,3A
0526:  DATA 20,25
0528:  DATA 30,32
052A:  DATA 64,20
052C:  DATA 3A,20
052E:  DATA 25,30
0530:  DATA 32,64
0532:  DATA 20,20
0534:  DATA 20,25
0536:  DATA 73,20
0538:  DATA 2D,20
053A:  DATA 25,30
053C:  DATA 32,64
053E:  DATA 2F,25
0540:  DATA 30,32
0542:  DATA 64,2F
0544:  DATA 25,30
0546:  DATA 32,64
0548:  DATA 00,00
054A:  CLRF   01
054C:  CLRF   02
054E:  CLRF   00
0550:  CLRF   03
0552:  MOVF   xA2,W
0554:  BNZ   055A
0556:  MOVF   xA1,W
0558:  BZ    058A
055A:  MOVLW  10
055C:  MOVWF  xA3
055E:  BCF    FD8.0
0560:  RLCF   x9F,F
0562:  RLCF   xA0,F
0564:  RLCF   00,F
0566:  RLCF   03,F
0568:  MOVF   xA2,W
056A:  SUBWF  03,W
056C:  BNZ   0572
056E:  MOVF   xA1,W
0570:  SUBWF  00,W
0572:  BNC   0582
0574:  MOVF   xA1,W
0576:  SUBWF  00,F
0578:  BTFSS  FD8.0
057A:  DECF   03,F
057C:  MOVF   xA2,W
057E:  SUBWF  03,F
0580:  BSF    FD8.0
0582:  RLCF   01,F
0584:  RLCF   02,F
0586:  DECFSZ xA3,F
0588:  BRA    055E
058A:  RETURN 0
*
0B5C:  MOVF   7E,W
0B5E:  CLRF   01
0B60:  SUBWF  7D,W
0B62:  BC    0B6A
0B64:  MOVFF  7D,00
0B68:  BRA    0B82
0B6A:  CLRF   00
0B6C:  MOVLW  08
0B6E:  MOVWF  7F
0B70:  RLCF   7D,F
0B72:  RLCF   00,F
0B74:  MOVF   7E,W
0B76:  SUBWF  00,W
0B78:  BTFSC  FD8.0
0B7A:  MOVWF  00
0B7C:  RLCF   01,F
0B7E:  DECFSZ 7F,F
0B80:  BRA    0B70
0B82:  RETURN 0
*
0DF0:  MOVFF  75,FEA
0DF4:  MOVFF  74,FE9
0DF8:  MOVFF  7D,FEF
0DFC:  INCF   FE9,F
0DFE:  BTFSC  FD8.2
0E00:  INCF   FEA,F
0E02:  CLRF   FEF
0E04:  INCF   74,F
0E06:  BTFSC  FD8.2
0E08:  INCF   75,F
0E0A:  RETURN 0
0E0C:  MOVLW  20
0E0E:  BTFSS  78.4
0E10:  MOVLW  30
0E12:  MOVWF  79
0E14:  MOVFF  77,00
0E18:  BTFSS  77.7
0E1A:  BRA    0E2C
0E1C:  COMF   00,F
0E1E:  INCF   00,F
0E20:  MOVFF  00,77
0E24:  MOVLW  2D
0E26:  MOVWF  79
0E28:  BSF    78.7
0E2A:  BSF    78.0
0E2C:  MOVF   01,W
0E2E:  MOVFF  77,7D
0E32:  MOVLW  64
0E34:  MOVWF  7E
0E36:  RCALL  0B5C
0E38:  MOVFF  00,77
0E3C:  MOVLW  30
0E3E:  ADDWF  01,W
0E40:  MOVWF  7A
0E42:  MOVFF  77,7D
0E46:  MOVLW  0A
0E48:  MOVWF  7E
0E4A:  RCALL  0B5C
0E4C:  MOVLW  30
0E4E:  ADDWF  00,W
0E50:  MOVWF  7C
0E52:  MOVLW  30
0E54:  ADDWF  01,W
0E56:  MOVWF  7B
0E58:  MOVFF  79,00
0E5C:  MOVLW  30
0E5E:  SUBWF  7A,W
0E60:  BZ    0E6A
0E62:  BSF    78.1
0E64:  BTFSC  78.7
0E66:  BSF    78.2
0E68:  BRA    0E8E
0E6A:  BTFSC  78.2
0E6C:  BRA    0E8E
0E6E:  MOVFF  79,7A
0E72:  BTFSC  78.1
0E74:  BRA    0E7E
0E76:  MOVLW  30
0E78:  SUBWF  7B,W
0E7A:  BZ    0E84
0E7C:  BSF    78.0
0E7E:  BTFSC  78.7
0E80:  BSF    78.1
0E82:  BRA    0E8E
0E84:  BTFSS  FD8.2
0E86:  BSF    78.0
0E88:  BTFSC  FD8.2
0E8A:  MOVFF  7A,7B
0E8E:  BTFSC  78.2
0E90:  BRA    0E9C
0E92:  BTFSC  78.1
0E94:  BRA    0EA2
0E96:  BTFSC  78.0
0E98:  BRA    0EA8
0E9A:  BRA    0EAE
0E9C:  MOVFF  79,7D
0EA0:  RCALL  0DF0
0EA2:  MOVFF  7A,7D
0EA6:  RCALL  0DF0
0EA8:  MOVFF  7B,7D
0EAC:  RCALL  0DF0
0EAE:  MOVFF  7C,7D
0EB2:  RCALL  0DF0
0EB4:  RETURN 0
0EB6:  TBLRD*+
0EB8:  MOVFF  FF6,78
0EBC:  MOVFF  FF7,79
0EC0:  MOVFF  FF5,7D
0EC4:  RCALL  0DF0
0EC6:  MOVFF  78,FF6
0ECA:  MOVFF  79,FF7
0ECE:  DECFSZ 77,F
0ED0:  BRA    0EB6
0ED2:  RETURN 0
0ED4:  MOVF   FEF,F
0ED6:  BZ    0EF6
0ED8:  MOVFF  FEA,78
0EDC:  MOVFF  FE9,77
0EE0:  MOVFF  FEF,7D
0EE4:  RCALL  0DF0
0EE6:  MOVFF  78,FEA
0EEA:  MOVFF  77,FE9
0EEE:  INCF   FE9,F
0EF0:  BTFSC  FD8.2
0EF2:  INCF   FEA,F
0EF4:  BRA    0ED4
0EF6:  GOTO   0FD2 (RETURN)
0EFA:  TSTFSZ 01
0EFC:  BRA    0F04
0EFE:  TSTFSZ 02
0F00:  BRA    0F06
0F02:  BRA    0F12
0F04:  INCF   02,F
0F06:  MOVFF  00,FEE
0F0A:  DECFSZ 01,F
0F0C:  BRA    0F06
0F0E:  DECFSZ 02,F
0F10:  BRA    0F06
0F12:  RETURN 0
*
103A:  TBLRD*+
103C:  MOVF   FF5,F
103E:  BZ    1058
1040:  MOVFF  FF6,77
1044:  MOVFF  FF7,78
1048:  MOVFF  FF5,7D
104C:  RCALL  0DF0
104E:  MOVFF  77,FF6
1052:  MOVFF  78,FF7
1056:  BRA    103A
1058:  RETURN 0
*
11C6:  MOVFF  FF2,0D
11CA:  BCF    FF2.7
11CC:  ADDWF  FE8,W
11CE:  CLRF   FF7
11D0:  RLCF   FF7,F
11D2:  ADDLW  EB
11D4:  MOVWF  FF6
11D6:  MOVLW  11
11D8:  ADDWFC FF7,F
11DA:  TBLRD*-
11DC:  MOVF   FF5,W
11DE:  MOVWF  FFA
11E0:  TBLRD*
11E2:  MOVF   FF5,W
11E4:  BTFSC  0D.7
11E6:  BSF    FF2.7
11E8:  MOVWF  FF9
11EA:  DATA 68,10
11EC:  DATA A2,10
11EE:  DATA DC,10
11F0:  DATA 16,11
11F2:  DATA 50,11
11F4:  DATA 8A,11
*
140A:  MOVFF  FF2,0D
140E:  BCF    FF2.7
1410:  ADDWF  FE8,W
1412:  CLRF   FF7
1414:  RLCF   FF7,F
1416:  ADDLW  2F
1418:  MOVWF  FF6
141A:  MOVLW  14
141C:  ADDWFC FF7,F
141E:  TBLRD*-
1420:  MOVF   FF5,W
1422:  MOVWF  FFA
1424:  TBLRD*
1426:  MOVF   FF5,W
1428:  BTFSC  0D.7
142A:  BSF    FF2.7
142C:  MOVWF  FF9
142E:  DATA 04,12
1430:  DATA 5A,12
1432:  DATA B0,12
1434:  DATA 06,13
1436:  DATA 5C,13
1438:  DATA B2,13
*
14CE:  MOVFF  FF2,0D
14D2:  BCF    FF2.7
14D4:  ADDWF  FE8,W
14D6:  CLRF   FF7
14D8:  RLCF   FF7,F
14DA:  ADDLW  F3
14DC:  MOVWF  FF6
14DE:  MOVLW  14
14E0:  ADDWFC FF7,F
14E2:  TBLRD*-
14E4:  MOVF   FF5,W
14E6:  MOVWF  FFA
14E8:  TBLRD*
14EA:  MOVF   FF5,W
14EC:  BTFSC  0D.7
14EE:  BSF    FF2.7
14F0:  MOVWF  FF9
14F2:  DATA 7A,14
14F4:  DATA 84,14
14F6:  DATA 90,14
14F8:  DATA 9C,14
14FA:  DATA A8,14
14FC:  DATA B4,14
*
15D2:  MOVFF  FF2,0D
15D6:  BCF    FF2.7
15D8:  ADDWF  FE8,W
15DA:  CLRF   FF7
15DC:  RLCF   FF7,F
15DE:  ADDLW  F7
15E0:  MOVWF  FF6
15E2:  MOVLW  15
15E4:  ADDWFC FF7,F
15E6:  TBLRD*-
15E8:  MOVF   FF5,W
15EA:  MOVWF  FFA
15EC:  TBLRD*
15EE:  MOVF   FF5,W
15F0:  BTFSC  0D.7
15F2:  BSF    FF2.7
15F4:  MOVWF  FF9
15F6:  DATA 72,15
15F8:  DATA 80,15
15FA:  DATA 8E,15
15FC:  DATA 9C,15
15FE:  DATA B0,15
1600:  DATA C0,15
*
16DC:  MOVFF  FF2,0D
16E0:  BCF    FF2.7
16E2:  ADDWF  FE8,W
16E4:  CLRF   FF7
16E6:  RLCF   FF7,F
16E8:  ADDLW  01
16EA:  MOVWF  FF6
16EC:  MOVLW  17
16EE:  ADDWFC FF7,F
16F0:  TBLRD*-
16F2:  MOVF   FF5,W
16F4:  MOVWF  FFA
16F6:  TBLRD*
16F8:  MOVF   FF5,W
16FA:  BTFSC  0D.7
16FC:  BSF    FF2.7
16FE:  MOVWF  FF9
1700:  DATA 7E,16
1702:  DATA 8C,16
1704:  DATA 9A,16
1706:  DATA A8,16
1708:  DATA BC,16
170A:  DATA CC,16
....................  
.................... #list 
....................  
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanýr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       Â· LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       Â· WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini saðlar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       Â· PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin içine yükleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       Â· PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       Â· BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       Â· INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       Â· NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */                                
....................                                                          
.................... #FUSES NOWDT, WDT8, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC  
.................... #use delay (internal=8MHz)                   
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7) 
.................... //#use I2C(master, sda=PIN_C4, scl=PIN_C3) 
....................                                             
.................... #include "definitions.h"                                                                                                       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "main.h"                  
.................... #ifndef MAIN_H      
.................... #define MAIN_H  
.................... #define DELAY 500  
....................  
.................... uint8_t timeCounter=120; // 2 dakikada bir rtc zamani cek 
....................                             
.................... void WDTreset(void);   
....................                      
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"                                     
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0  
.................... #bit  PORTB_1=PORTB.1     
.................... #bit  PORTB_2=PORTB.2 
.................... #bit  PORTB_7=PORTB.7 
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
.................... // COMPARATOR MODULE  
.................... #byte CMCON = 0x0FB4 
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //  
.................... #bit  SCL_DIR=TRISC.3  
.................... #bit  SDA_DIR=TRISC.4  
.................... #bit  SCL=PORTC.3  
.................... #bit  SDA=PORTC.4     
....................  
.................... #byte PIR2    = 0x0FA1  
.................... #bit BCLIF    = PIR2.3 
....................                           
.................... #byte SSPSTAT = 0x0FC7         
.................... #bit  BF      = SSPSTAT.0 
.................... #bit  RW      = SSPSTAT.2  
.................... #bit  S       = SSPSTAT.3   
.................... #bit  P       = SSPSTAT.4 
.................... #bit  CKE     = SSPSTAT.6 
.................... #bit  SMP     = SSPSTAT.7 
....................  
.................... #byte SSPCON1 = 0x0FC6  
.................... #bit  SSPM0   = SSPCON1.0 
.................... #bit  SSPM1   = SSPCON1.1 
.................... #bit  SSPM2   = SSPCON1.2 
.................... #bit  SSPM3   = SSPCON1.3 
.................... #bit  SSPEN   = SSPCON1.5  
....................  
.................... #byte SSPCON2 = 0x0FC5  
.................... #bit  SEN     = SSPCON2.0 
.................... #bit  RSEN    = SSPCON2.1  
.................... #bit  PEN     = SSPCON2.2  
.................... #bit  RCEN    = SSPCON2.3  
.................... #bit  ACKEN   = SSPCON2.4 
.................... #bit  ACKDT   = SSPCON2.5           
.................... #bit  ACKSTAT = SSPCON2.6  
....................  
.................... #byte SSPBUF  = 0x0FC9  
.................... #byte SSPADD  = 0x0FC8 
.................... #bit  SSPIE   = PIE1.3 
.................... #bit  SSPIF   = PIR1.3  
....................  
....................                        
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h"                                                                                          
.................... #ifndef INITS_H 
.................... #define INITS_H       
....................  
.................... extern uint16_t iSayac;  
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _2ms    : 1;  //bit:0, 2ms   
....................       uint8_t _10ms   : 1;  //bit:1, 10ms  
....................       uint8_t _20ms   : 1;  //bit:2, 20ms  
....................       uint8_t _50ms   : 1;  //bit:3, 50ms  
....................       uint8_t _100ms  : 1;  //bit:4, 100ms     
....................       uint8_t _200ms  : 1;  //bit:5, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:6, 500ms  
....................       uint8_t _1000ms : 1;  //bit:7, 1000ms   
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t tmr1_time;     
....................  
....................  
....................  
....................  
....................                                                 
.................... #endif //INIT_H                               
....................  
.................... #include "lcd.h"   
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "button.h"        
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED_1,BUTTON_PRESSED_RELEASED_2,BUTTON_PRESSED_RELEASED_3;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS_B1, STATUS_B2, STATUS_B3;  
.................... extern uint8_t bt_queue; 
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t);   
....................    
.................... #endif            
....................  
.................... #include "DS1307timeset.h"  
.................... #include "definitions.h"       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................                              
.................... #ifndef DS1307TIMESET_H 
.................... #define DS1307TIMESET_H   
....................  
.................... extern uint8_t position; 
.................... extern uint8_t executed; 
.................... //TIME CONTROL VIA BUTTON AND LCD 
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t SECOND     : 1;  //bit:0,   
....................       uint8_t MINUTE     : 1;  //bit:1,   
....................       uint8_t HOUR       : 1;  //bit:2,   
....................       uint8_t DAY        : 1;  //bit:3,      
....................       uint8_t MONTH      : 1;  //bit:4,                    
....................       uint8_t YEAR       : 1;  //bit:5,   
....................       uint8_t SET        : 2;  //bit:6-7,   
....................    }X;                     
.................... }date_t;    
.................... extern date_t DATE_STATUS;    
....................  
.................... void setTimeCases(); 
.................... void chooseElement(uchar_t);       
.................... void arrangeValueOfElement(uchar_t); 
....................  
.................... // INCREASE OR DECREASE 
.................... void increaseElement(uchar_t);  
.................... void decreaseElement(uchar_t); 
....................  
.................... //Send DATE ELEMENTS to RTC 
.................... void setRTC(uchar_t);    
.................... void txRTC(uchar_t, uchar_t);  
....................                                
.................... uchar_t exactDayOfMonth();           
....................  
....................  
....................  
.................... #endif //DS1307TIMESET_H 
....................  
....................  
....................  
....................  
....................  
.................... #include "timedate.h" 
.................... #ifndef TIMEDATE_H 
.................... #define TIMEDATE_H 
....................  
.................... //METHODS  
.................... void getTime(); 
.................... void runTime();  
.................... void getDayTextt(); 
.................... uchar_t exactDayOfMonthh();      
.................... uint16_t day_of_the_weekk(uint16_t, uint16_t, uint16_t); 
....................  
....................  
.................... #endif //TIMEDATE_H 
....................  
....................                           
.................... #include "lcd.c"                                 
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0  
.................... #bit  PORTB_1=PORTB.1     
.................... #bit  PORTB_2=PORTB.2 
.................... #bit  PORTB_7=PORTB.7 
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
.................... // COMPARATOR MODULE  
.................... #byte CMCON = 0x0FB4 
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //  
.................... #bit  SCL_DIR=TRISC.3  
.................... #bit  SDA_DIR=TRISC.4  
.................... #bit  SCL=PORTC.3  
.................... #bit  SDA=PORTC.4     
....................  
.................... #byte PIR2    = 0x0FA1  
.................... #bit BCLIF    = PIR2.3 
....................                           
.................... #byte SSPSTAT = 0x0FC7         
.................... #bit  BF      = SSPSTAT.0 
.................... #bit  RW      = SSPSTAT.2  
.................... #bit  S       = SSPSTAT.3   
.................... #bit  P       = SSPSTAT.4 
.................... #bit  CKE     = SSPSTAT.6 
.................... #bit  SMP     = SSPSTAT.7 
....................  
.................... #byte SSPCON1 = 0x0FC6  
.................... #bit  SSPM0   = SSPCON1.0 
.................... #bit  SSPM1   = SSPCON1.1 
.................... #bit  SSPM2   = SSPCON1.2 
.................... #bit  SSPM3   = SSPCON1.3 
.................... #bit  SSPEN   = SSPCON1.5  
....................  
.................... #byte SSPCON2 = 0x0FC5  
.................... #bit  SEN     = SSPCON2.0 
.................... #bit  RSEN    = SSPCON2.1  
.................... #bit  PEN     = SSPCON2.2  
.................... #bit  RCEN    = SSPCON2.3  
.................... #bit  ACKEN   = SSPCON2.4 
.................... #bit  ACKDT   = SSPCON2.5           
.................... #bit  ACKSTAT = SSPCON2.6  
....................  
.................... #byte SSPBUF  = 0x0FC9  
.................... #byte SSPADD  = 0x0FC8 
.................... #bit  SSPIE   = PIE1.3 
.................... #bit  SSPIF   = PIR1.3  
....................  
....................                        
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "delayms.h"  
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................                  
....................                
.................... /*Hex Code   LCD Ekran Karsiligi  
....................  Initialize Lcd in 4-bit mode               0x02 
.................... 1   Function Set: 8-bit, 1 Line, 5×7 Dots   0x30   48                                              
.................... 2   Function Set: 8-bit, 2 Line, 5×7 Dots   0x38   56                            
.................... 3   Function Set: 4-bit, 1 Line, 5×7 Dots   0x20   32 
.................... 4   Function Set: 4-bit, 2 Line, 5×7 Dots   0x28   40  
.................... 0F   LCD acik, Imlec acik 
.................... 01   Ekrani Temizle                                 
.................... 02   Satir Basina Dön            
.................... 04   Imleci Sola Kaydir 
.................... 06   Imleci Saga Kaydir 
.................... 05   Ekrani Saga Kaydir 
.................... 07   Ekrani Sola Kaydir 
.................... 0E   Ekran Acik, Imleç Yanip Sonuyor 
.................... 80   Imleci Ilk Satirin Basinda Konumlandir 
.................... C0   Imleci Ikinci Satirin Basinda Konumlandir         
.................... 3C   Ikinci Satiri Etkinlestir                                                     
.................... 08   Ekran Kapali, Imleç Kapali              
.................... OC   Ekran Acik, Imlec Kapali*/   
....................                                             
.................... uchar_t strLCD[32]; 
.................... uint8_t countLCDChar; 
.................... uchar_t LCDW1SecFlag; 
....................                                          
.................... /*LCD (CHIP: HD44780), COMMAND MODE*/  
.................... void dis_cmd(uchar_t cmdout){  
....................    PORTD=cmdout;      //Send command to lcdport=PORTB 
*
0664:  MOVFF  78,F8C
....................    PORTE_RS=0;                   
0668:  BCF    F84.0
....................    PORTE_E=1;                
066A:  BSF    F84.1
....................    delayUsFun(1); 
066C:  MOVLW  01
066E:  MOVWF  x80
0670:  RCALL  0656
....................    PORTE_E=0;                               
0672:  BCF    F84.1
0674:  RETURN 0
.................... }                                   
....................  
....................  
....................  
.................... void lcdcmd(uchar_t cmd_value){          
....................    uchar_t cmd_value1;                              
....................    cmd_value1 = (cmd_value & 0xF0);      // Mask lower nibble because RB4-RB7 pins are being used    
0676:  MOVF   76,W
0678:  ANDLW  F0
067A:  MOVWF  77
....................    dis_cmd(cmd_value1);                   // Send to LCD 
067C:  MOVFF  77,78
0680:  RCALL  0664
....................    cmd_value1 = ((cmd_value<<4) & 0xF0);  // Shift 4-bit and mask 
0682:  SWAPF  76,W
0684:  MOVWF  00
0686:  MOVLW  F0
0688:  ANDWF  00,F
068A:  MOVF   00,W
068C:  ANDLW  F0
068E:  MOVWF  77
....................    dis_cmd(cmd_value1);                   // Send to LCD 
0690:  MOVFF  77,78
0694:  RCALL  0664
0696:  RETURN 0
.................... } 
....................  // 2 lines are active.              
.................... void twoLinesBCDMode(){  
....................    lcdcmd(0x02); 
*
00F6:  MOVLW  02
00F8:  MOVWF  76
00FA:  RCALL  0676
00FC:  GOTO   06C8 (RETURN)
.................... } 
....................                         
.................... // 2 lines are active. BCD MODE 
.................... void LinesActive(){  
....................    lcdcmd(0x28);                
*
0698:  MOVLW  28
069A:  MOVWF  76
069C:  RCALL  0676
069E:  GOTO   06CA (RETURN)
.................... }                          
.................... // LCD screen clear.                   
.................... void lcdClear(){ 
....................    lcdcmd(0x01);                   
*
06B6:  MOVLW  01
06B8:  MOVWF  76
06BA:  RCALL  0676
06BC:  GOTO   06D0 (RETURN)
.................... }                   
.................... // Go to first line. 
.................... void lcdGoToFirstLine(){  
....................    lcdcmd(0x80); 
*
17F0:  MOVLW  80
17F2:  MOVWF  76
17F4:  CALL   0676
17F8:  GOTO   1846 (RETURN)
.................... }                                  
.................... // Go to second line.                        
.................... void lcdGoToSecondLine(){ 
....................    lcdcmd(0xC0); 
17FC:  MOVLW  C0
17FE:  MOVWF  76
1800:  CALL   0676
1804:  GOTO   184E (RETURN)
.................... }                        
.................... // Shift cursor to right. 
.................... void lcdShiftRight(){   
....................    lcdcmd(0x06);                                                     
*
06AC:  MOVLW  06
06AE:  MOVWF  76
06B0:  RCALL  0676
06B2:  GOTO   06CE (RETURN)
.................... }                                           
.................... // Display on, Cursor on              
.................... void lcdCursorOn(){                  
....................    lcdcmd(0x0E); 
.................... }                                      
.................... //Display off, Cursor off 
.................... void lcdCursorOff(){                                             
....................    lcdcmd(0x0C);                             
*
06A2:  MOVLW  0C
06A4:  MOVWF  76
06A6:  RCALL  0676
06A8:  GOTO   06CC (RETURN)
.................... }                              
....................   
.................... void dis_data(uchar_t dataout) {  
....................    PORTD=dataout;   //Send data to lcdport=PORTB 
*
1808:  MOVFF  79,F8C
....................    PORTE_RS=1;                   
180C:  BSF    F84.0
....................    PORTE_E=1;                          
180E:  BSF    F84.1
....................    delayUsFun(1); 
1810:  MOVLW  01
1812:  MOVWF  x80
1814:  CALL   0656
....................    PORTE_E=0;   
1818:  BCF    F84.1
181A:  RETURN 0
....................    //PORTD=0x00; 
....................    //while(test_bit(PORTD,7));           
.................... }   
.................... /*DATA MODE*/   
.................... void lcddata(uchar_t text){  
....................    uchar_t data;                                                                 
....................    data=(text & 0xF0);         
181C:  MOVF   77,W
181E:  ANDLW  F0
1820:  MOVWF  78
....................    dis_data(data);     
1822:  MOVFF  78,79
1826:  RCALL  1808
....................    data=((text<<4)&0xF0);      
1828:  SWAPF  77,W
182A:  MOVWF  00
182C:  MOVLW  F0
182E:  ANDWF  00,F
1830:  MOVF   00,W
1832:  ANDLW  F0
1834:  MOVWF  78
....................    dis_data(data);                  
1836:  MOVFF  78,79
183A:  RCALL  1808
183C:  GOTO   186C (RETURN)
.................... }                                
.................... void LCD_String(){  
....................    if(countLCDChar==0)  
1840:  MOVF   3B,F
1842:  BNZ   1846
....................       lcdGoToFirstLine(); 
1844:  BRA    17F0
....................    if(countLCDChar==16)   
1846:  MOVF   3B,W
1848:  SUBLW  10
184A:  BNZ   184E
....................       lcdGoToSecondLine();    
184C:  BRA    17FC
....................    if(countLCDChar<=31){  
184E:  MOVF   3B,W
1850:  SUBLW  1F
1852:  BNC   1870
....................       lcddata(strLCD[countLCDChar]); 
1854:  CLRF   03
1856:  MOVF   3B,W
1858:  ADDLW  1B
185A:  MOVWF  FE9
185C:  MOVLW  00
185E:  ADDWFC 03,W
1860:  MOVWF  FEA
1862:  MOVFF  FEF,76
1866:  MOVFF  76,77
186A:  BRA    181C
....................       countLCDChar++;   
186C:  INCF   3B,F
....................    }else{    
186E:  BRA    1874
....................       LCDW1SecFlag=0; 
1870:  CLRF   3C
....................       countLCDChar=0; 
1872:  CLRF   3B
....................    }                  
1874:  GOTO   021C (RETURN)
.................... }  
....................  
....................  
.................... void LCD_Custom_Char(uchar_t loc, uchar_t *msg){ 
....................     uchar_t i; 
....................     if(loc<8) 
....................     { 
....................      lcdcmd(0x40 + (loc*8));    /* Command 0x40 and onwards forces the device to point CGRAM address */ 
....................      for(i=0;i<8;i++)          /* Write 8 byte for generation of 1 character */ 
....................         lcddata(msg[i]);       
....................     }                        
.................... } 
....................  
....................                                           
....................  
....................       
....................  
.................... #include "delayms.c"                  
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs){  // Delay function - generates a delay of specified msecs 
....................    uint16_t i; 
....................    uint8_t j;  
....................    for(i=0;i<=msecs;i++) 
....................    for(j=0;j<205;j++); /*This count Provide delay of 1 ms for 8MHz Frequency */                              
.................... }        
....................  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
*
0656:  CLRF   x81
0658:  MOVF   x81,W
065A:  SUBWF  x80,W
065C:  BNC   0662
065E:  INCF   x81,F
0660:  BRA    0658
....................     }                                
0662:  RETURN 0
.................... }   
....................  
....................  
.................... #include "DS1307.c"  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                   /// 
.................... ///                     Driver for Real Time Clock                           /// 
.................... ///                                                                          /// 
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -/// 
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     /// 
.................... ///               - Disable squarewave output                                /// 
.................... ///                                                                          /// 
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             /// 
.................... ///                                                                          /// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#use i2c(master, sda=PIN_C4, scl=PIN_C3)                                                                                                
.................... #include "binbcdconv.c"   
.................... #include "binbcdconv.h" 
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef BINBCDCONV_H         
.................... #define BINBCDCONV_H   
....................  
.................... uchar_t bin2bcd(uchar_t binary_value); 
.................... uchar_t bcd2bin(uchar_t bcd_value); 
....................                          
.................... #endif //BINBCDCONV_H      
....................  
....................                                                      
.................... uchar_t bin2bcd(uchar_t binary_value){ 
....................   uchar_t retval;                     
....................   retval = 0;                                                
*
0782:  CLRF   7E
....................   while(1){ 
....................     if(binary_value >= 10){    // 10'dan buyuk oldugu muddetce                                     
0784:  MOVF   7D,W
0786:  SUBLW  09
0788:  BC    0794
....................       binary_value   -= 10;    // 10 cikar 
078A:  MOVLW  0A
078C:  SUBWF  7D,F
....................       retval += 0x10;  //asil degiskenimizin MsB'sine 1 ekle      
078E:  MOVLW  10
0790:  ADDWF  7E,F
....................     }  
0792:  BRA    079A
....................     else{  
....................       retval += binary_value;  //artik 10'dan buyuk degil kalan 0-9 arasi sayiyi asil degiskenimize ekle                             
0794:  MOVF   7D,W
0796:  ADDWF  7E,F
....................       break;                 
0798:  BRA    079C
....................     } 
079A:  BRA    0784
....................   } 
....................   return(retval);   
079C:  MOVFF  7E,01
07A0:  RETURN 0
.................... } 
....................                            
....................                                
.................... // 8-Bit ile oldugu icin 0-99 arasi bir bcd sayi yazilmalidir.  
.................... uchar_t bcd2bin(uchar_t bcd_value){  
....................          // (bcd_value>>4)*10) BCD'nin 10 luk kisim ilk 4 bite kaydirildi ve 10 ile carpildi. 
....................          // (bcd_value & 0x0F) BCD'nin yuksek degerli 4 biti sifirlandi ve 0-9 kismi birakildi. 
....................          // 2 sayi toplanarak binary karsiligi elde edildi. 
....................   return ((bcd_value>>4)*10) + (bcd_value & 0x0F);   
*
086C:  SWAPF  77,W
086E:  MOVWF  00
0870:  MOVLW  0F
0872:  ANDWF  00,F
0874:  MOVF   00,W
0876:  MULLW  0A
0878:  MOVFF  FF3,78
087C:  MOVF   77,W
087E:  ANDLW  0F
0880:  ADDWF  78,W
0882:  MOVWF  01
0884:  RETURN 0
.................... }                      
....................  
.................... #include "DS1307.h"                                               
.................... #ifndef DS1307_H                             
.................... #define DS1307_H    
....................  
....................     
....................  
....................  
.................... //DS1307 TIME-DATE INFO VARIABLES   
.................... extern uchar_t sec, min, hrs; 
.................... extern uchar_t day, month, yr, dow;       
.................... extern uchar_t dayText[4];   
.................... extern uchar_t DATE_TIME[32];   
....................  
....................  
.................... void DS1307_Init();                                                      
.................... void ds1307_set_date_time(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t); 
.................... void ds1307_get_date(); 
.................... void ds1307_get_time();   
.................... void getDayText();      
....................                
.................... uchar_t getSec(); 
.................... uchar_t getMin();  
.................... uchar_t getHour(); 
....................                            
.................... uchar_t getDay();  
.................... uchar_t getMonth();  
.................... uchar_t getYear(); 
.................... uchar_t getDow();                                                                  
....................                 
.................... uint16_t day_of_the_week(uint16_t, uint16_t, uint16_t );                   
....................                     
.................... #endif //DS1307_H                      
....................                                        
....................  
.................... #include "i2c.h"              
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef I2C_H                                                            
.................... #define I2C_H                                                                  
....................  
.................... void _I2C_Start();          
.................... void _I2C_Stop();   
.................... void I2C_Clock();                                                             
....................  
.................... uchar_t _I2C_Read(uchar_t);                
.................... void _I2CACK(uchar_t);      
.................... void _I2C_Write(uchar_t);      
....................  
....................  
.................... void i2cHighSda(void);                     
.................... void i2cLowSda(void);                                                           
.................... void i2cHighScl(void); 
.................... void i2cLowScl(void);  
....................  
....................  
....................                     
.................... #endif //I2C_H      
....................  
....................  
....................            
....................  
.................... #include "i2c.c"     
.................... #include "i2c.h" 
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef I2C_H                                                            
.................... #define I2C_H                                                                  
....................  
.................... void _I2C_Start();          
.................... void _I2C_Stop();   
.................... void I2C_Clock();                                                             
....................  
.................... uchar_t _I2C_Read(uchar_t);                
.................... void _I2CACK(uchar_t);      
.................... void _I2C_Write(uchar_t);      
....................  
....................  
.................... void i2cHighSda(void);                     
.................... void i2cLowSda(void);                                                           
.................... void i2cHighScl(void); 
.................... void i2cLowScl(void);  
....................  
....................  
....................                     
.................... #endif //I2C_H      
....................  
....................  
....................            
....................  
.................... #include "definitions.h"                                                                              
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "ucregisters.h"   
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0  
.................... #bit  PORTB_1=PORTB.1     
.................... #bit  PORTB_2=PORTB.2 
.................... #bit  PORTB_7=PORTB.7 
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
.................... // COMPARATOR MODULE  
.................... #byte CMCON = 0x0FB4 
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //  
.................... #bit  SCL_DIR=TRISC.3  
.................... #bit  SDA_DIR=TRISC.4  
.................... #bit  SCL=PORTC.3  
.................... #bit  SDA=PORTC.4     
....................  
.................... #byte PIR2    = 0x0FA1  
.................... #bit BCLIF    = PIR2.3 
....................                           
.................... #byte SSPSTAT = 0x0FC7         
.................... #bit  BF      = SSPSTAT.0 
.................... #bit  RW      = SSPSTAT.2  
.................... #bit  S       = SSPSTAT.3   
.................... #bit  P       = SSPSTAT.4 
.................... #bit  CKE     = SSPSTAT.6 
.................... #bit  SMP     = SSPSTAT.7 
....................  
.................... #byte SSPCON1 = 0x0FC6  
.................... #bit  SSPM0   = SSPCON1.0 
.................... #bit  SSPM1   = SSPCON1.1 
.................... #bit  SSPM2   = SSPCON1.2 
.................... #bit  SSPM3   = SSPCON1.3 
.................... #bit  SSPEN   = SSPCON1.5  
....................  
.................... #byte SSPCON2 = 0x0FC5  
.................... #bit  SEN     = SSPCON2.0 
.................... #bit  RSEN    = SSPCON2.1  
.................... #bit  PEN     = SSPCON2.2  
.................... #bit  RCEN    = SSPCON2.3  
.................... #bit  ACKEN   = SSPCON2.4 
.................... #bit  ACKDT   = SSPCON2.5           
.................... #bit  ACKSTAT = SSPCON2.6  
....................  
.................... #byte SSPBUF  = 0x0FC9  
.................... #byte SSPADD  = 0x0FC8 
.................... #bit  SSPIE   = PIE1.3 
.................... #bit  SSPIF   = PIR1.3  
....................  
....................                        
.................... #endif UCREGISTER_H                                                                          
....................  
....................  
....................   
....................  
.................... //This function is used to generate a clock pulse on SCL line. 
.................... void I2C_Clock(void){      
....................     i2cHighScl(); // Wait for Some time and Pull the SCL line High 
*
0738:  RCALL  0716
....................                   // Wdelay_us(1);        ait for Some time 
....................     i2cLowScl();  // Pull back the SCL line low to Generate a clock pulse    
073A:  RCALL  0700
073C:  RETURN 0
.................... }                                                  
....................  
.................... //This fun is used to receive a byte on SDA line using I2C protocol. 
.................... //8bit data is received bit-by-bit each clock and finally packed into Byte. 
.................... //MSB(bit) is received first and LSB(bit) is received at last.    
.................... //        ___     ___     ___     ___     ___     ___     ___     ___     ___             
.................... // SCD:  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    
.................... //     __|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|  
.................... // SDA:   D8      D7      D6      D5      D4      D3      D2      D1      D0       
.................... uchar_t _I2C_Read(uchar_t mode){                            
*
0840:  CLRF   78
....................     uchar_t i, dat=0x00; 
....................     i2cHighSda();            //Make SDA as I/P 
0842:  RCALL  070C
....................     for(i=0;i<8;i++){        // loop 8times to read 1-byte of data 
0844:  CLRF   77
0846:  MOVF   77,W
0848:  SUBLW  07
084A:  BNC   0860
....................         i2cHighScl();        // Pull SCL High                  
084C:  RCALL  0716
....................                                              
....................         dat = dat<<1;        //dat is Shifted each time and 
084E:  BCF    FD8.0
0850:  RLCF   78,F
....................         dat = dat | SDA;     //ORed with the received bit to pack into byte 
0852:  MOVLW  00
0854:  BTFSC  F82.4
0856:  MOVLW  01
0858:  IORWF  78,F
....................                         
....................         i2cLowScl();         // Clear SCL to complete the Clock 
085A:  RCALL  0700
085C:  INCF   77,F
085E:  BRA    0846
....................        } 
....................        _I2CACK(mode); 
0860:  MOVFF  76,79
0864:  BRA    082A
....................    return dat;               // Finally return the received Byte* 
0866:  MOVFF  78,01
086A:  RETURN 0
.................... }  
.................... //This function is used to send a byte on SDA line using I2C protocol 
.................... //8bit data is sent bit-by-bit on each clock cycle. 
.................... //MSB(bit) is sent first and LSB(bit) is sent at last. 
.................... //Data is sent when SCL is low.             
.................... //        ___     ___     ___     ___     ___     ___     ___     ___     ___             
.................... // SCD:  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    
.................... //     __|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|  
.................... // SDA:   D8      D7      D6      D5      D4      D3      D2      D1      D0       
.................... void _I2C_Write(uchar_t  dat){ 
....................     uchar_t i; 
....................     for(i=0;i<8;i++){         // loop 8 times to send 1-byte of data   
*
073E:  CLRF   7F
0740:  MOVF   7F,W
0742:  SUBLW  07
0744:  BNC   075A
....................         if(dat & 0x80){ 
0746:  BTFSS  7E.7
0748:  BRA    074E
....................             i2cHighSda();     // Send Bit by Bit on SDA line 
074A:  RCALL  070C
....................         }else{   
074C:  BRA    0750
....................             i2cLowSda();  
074E:  RCALL  0720
....................         } 
....................         I2C_Clock();          // Generate Clock at SCL 
0750:  RCALL  0738
....................         dat = dat<<1;          
0752:  BCF    FD8.0
0754:  RLCF   7E,F
0756:  INCF   7F,F
0758:  BRA    0740
....................       }                                                  
....................         i2cHighSda();         // Set SDA at last     
075A:  RCALL  070C
....................         I2C_Clock();  
075C:  RCALL  0738
075E:  RETURN 0
.................... }       
....................  
.................... //ACK  : This function is used to generate a the Positive ACK pulse on SDA after receiving a byte. 
.................... //NOACK: This function is used to generate a the Negative/NO ACK pulse on SDA after receiving all bytes. 
.................... void _I2CACK(uchar_t mode){ 
....................    if(mode==1){     //ACK      
*
082A:  DECFSZ 79,W
082C:  BRA    0836
....................     i2cLowSda();    //Pull SDA low to indicate Positive ACK  
082E:  RCALL  0720
....................     I2C_Clock();    //Generate the Clock 
0830:  RCALL  0738
....................     i2cHighSda();   // Pull SDA back to High(IDLE state) 
0832:  RCALL  070C
....................    }else{           //NACK  
0834:  BRA    083C
....................     i2cHighSda();   //Pull SDA high to indicate Negative/NO ACK 
0836:  RCALL  070C
....................     I2C_Clock();    // Generate the Clock   
0838:  RCALL  0738
....................     i2cHighScl();   // Set SCL  
083A:  RCALL  0716
....................    }                                                                                  
083C:  GOTO   0866 (RETURN)
.................... }                          
....................  
.................... //This function is used to generate I2C Start Condition. 
.................... //Start Condition: SDA goes low when SCL is High. 
.................... //              ________ 
.................... // SCL:        |        |                 
.................... //        _____|        |___________                 
.................... //            _____     
.................... // SDA:      |     | 
.................... //       ____|     |______  
.................... void _I2C_Start(){ 
....................     i2cLowScl();     // Pull SCL low   
*
072C:  RCALL  0700
....................     i2cHighSda();    // Pull SDA High  
072E:  RCALL  070C
....................              
....................     i2cHighScl();    //Pull SCL high      
0730:  RCALL  0716
....................     i2cLowSda();     //Now Pull SDA LOW, to generate the Start Condition   
0732:  RCALL  0720
....................                             
....................     i2cLowScl();     //Finally Clear the SCL to complete the cycle      
0734:  RCALL  0700
0736:  RETURN 0
.................... }                
....................   
.................... //This function is used to generate I2C Stop Condition. 
.................... //Stop Condition: SDA goes High when SCL is High. 
.................... //              __________ 
.................... // SCL:        |         |                 
.................... //        _____|         |___________                 
.................... //                ___________________   
.................... // SDA:          |            
.................... //      _________|       
.................... void _I2C_Stop(void){ 
....................     i2cLowScl();   // Pull SCL low             
*
0760:  RCALL  0700
....................     i2cLowSda();   // Pull SDA  low 
0762:  RCALL  0720
....................                       
....................     i2cHighScl();  // Pull SCL High  
0764:  RCALL  0716
....................     i2cHighSda();  // Now Pull SDA High, to generate the Stop Condition 
0766:  RCALL  070C
0768:  RETURN 0
.................... }          
....................  
.................... void i2cHighSda(void){     
....................    SDA_DIR = 1;      // bring SDA to high impedance 
*
070C:  BSF    F94.4
....................    delayUsFun(1);       
070E:  MOVLW  01
0710:  MOVWF  x80
0712:  RCALL  0656
0714:  RETURN 0
.................... }                                        
.................... void i2cLowSda(void){ 
....................    SDA = 0;   
*
0720:  BCF    F82.4
....................    SDA_DIR = 0;      // output a logic zero 
0722:  BCF    F94.4
....................    delayUsFun(1); 
0724:  MOVLW  01
0726:  MOVWF  x80
0728:  RCALL  0656
072A:  RETURN 0
.................... }                                                                          
.................... void i2cHighScl(void){ 
....................    SCL_DIR = 1;      // bring SCL to high impedance 
*
0716:  BSF    F94.3
....................    delayUsFun(1); 
0718:  MOVLW  01
071A:  MOVWF  x80
071C:  RCALL  0656
071E:  RETURN 0
.................... } 
.................... void i2cLowScl(void){ 
....................    SCL= 0;       
*
0700:  BCF    F82.3
....................    SCL_DIR = 0;    
0702:  BCF    F94.3
....................    delayUsFun(1); 
0704:  MOVLW  01
0706:  MOVWF  x80
0708:  RCALL  0656
070A:  RETURN 0
.................... }        
....................                
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................                       
.................... #define DS1307_ID 0xD0     // DS1307 ID 
.................... #define SEC_ADDRESS   0x00 // Address to access Ds1307 SEC register 
.................... #define DATE_ADDRESS  0x04 // Address to access Ds1307 DATE register 
.................... #define CONTROL 0x07       // Address to access Ds1307 CONTROL register  
....................                                         
.................... // START(0) <--------------0xD - 13 is adres of DS1307----------------->  <-R/W->                  <-DATA->    ACK    STOP(1)  
.................... //|------| |------| |------| |------| |------| |------| |------| |------| |------|       |------|  |------| |------| |------|   
.................... //|  S   | |   1  |-|   1  |-|   0  |-|   1  |-|   0  |-|   0  |-|   0  |-|   0  |       |   0  |  |nx8BIT| |   0  | |  P   |    
.................... //|------| |------| |------| |------| |------| |------| |------| |------| |------|       |------|  |------| |------| |------|    
.................... //          7.Bit    6.Bit    5.Bit    4.Bit    3.Bit    2.Bit    1.Bit    0.Bit           ACK                       
....................  
.................... //TIME VARIABLES and BUFFERS 
.................... uchar_t sec, min, hrs; 
.................... uchar_t day, month, yr, dow;          
.................... uchar_t dayText[4];       
.................... uchar_t DATE_TIME[32];    
....................  
....................  
....................        
....................                             
.................... void DS1307_Init(){                                      
....................     _I2C_Start();              // Start I2C communication 
*
076A:  RCALL  072C
....................     _I2C_Write(DS1307_ID);   // Connect to DS1307 by sending its ID on I2c Bus 
076C:  MOVLW  D0
076E:  MOVWF  7E
0770:  RCALL  073E
....................     _I2C_Write(CONTROL);     // Select the Ds1307 ControlRegister to configure Ds1307                    
0772:  MOVLW  07
0774:  MOVWF  7E
0776:  RCALL  073E
....................     _I2C_Write(0x00);        // Write 0x00 to Control register to disable SQW-Out 
0778:  CLRF   7E
077A:  RCALL  073E
....................     _I2C_Stop();               // Stop I2C communication after initilizing DS1307  
077C:  RCALL  0760
077E:  GOTO   013E (RETURN)
....................  }                             
....................  
.................... void ds1307_set_date_time(uchar_t day_t, uchar_t mth_t, uchar_t year_t, uchar_t dow_t, uchar_t hr_t, uchar_t min_t, uchar_t sec_t){      
....................                                        
....................    sec_t &= 0x7F;                     
*
07A2:  BCF    7C.7
....................    min_t &= 0x7F; 
07A4:  BCF    7B.7
....................    hr_t &= (0x7F|0x40);  //format 24H                   
07A6:  BCF    7A.7
....................                      
....................   _I2C_Start();                // I2C write address   
07A8:  RCALL  072C
....................   _I2C_Write(0xD0);            // Start at REG 0 - Seconds 
07AA:  MOVLW  D0
07AC:  MOVWF  7E
07AE:  RCALL  073E
....................   _I2C_Write(0x00);            // Start at REG 0 - Seconds 
07B0:  CLRF   7E
07B2:  RCALL  073E
....................   _I2C_Write(bin2bcd(sec_t));      // REG 0 
07B4:  MOVFF  7C,7D
07B8:  RCALL  0782
07BA:  MOVFF  01,7D
07BE:  MOVFF  01,7E
07C2:  RCALL  073E
....................   _I2C_Write(bin2bcd(min_t));      // REG 1 
07C4:  MOVFF  7B,7D
07C8:  RCALL  0782
07CA:  MOVFF  01,7D
07CE:  MOVFF  01,7E
07D2:  RCALL  073E
....................   _I2C_Write(bin2bcd(hr_t));      // REG 2            
07D4:  MOVFF  7A,7D
07D8:  RCALL  0782
07DA:  MOVFF  01,7D
07DE:  MOVFF  01,7E
07E2:  RCALL  073E
....................   _I2C_Write(bin2bcd(dow_t));      // REG 3              
07E4:  MOVFF  79,7D
07E8:  RCALL  0782
07EA:  MOVFF  01,7D
07EE:  MOVFF  01,7E
07F2:  RCALL  073E
....................   _I2C_Write(bin2bcd(day_t));      // REG 4  
07F4:  MOVFF  76,7D
07F8:  RCALL  0782
07FA:  MOVFF  01,7D
07FE:  MOVFF  01,7E
0802:  RCALL  073E
....................   _I2C_Write(bin2bcd(mth_t));      // REG 5   
0804:  MOVFF  77,7D
0808:  RCALL  0782
080A:  MOVFF  01,7D
080E:  MOVFF  01,7E
0812:  RCALL  073E
....................   _I2C_Write(bin2bcd(year_t));     // REG 6   
0814:  MOVFF  78,7D
0818:  RCALL  0782
081A:  MOVFF  01,7D
081E:  MOVFF  01,7E
0822:  RCALL  073E
....................   _I2C_Stop();  
0824:  RCALL  0760
0826:  GOTO   015C (RETURN)
.................... }                                                 
....................                                                      
.................... void ds1307_get_date(){  
....................    _I2C_Start();  
*
0AEA:  RCALL  072C
....................    _I2C_Write(0xD0);   
0AEC:  MOVLW  D0
0AEE:  MOVWF  7E
0AF0:  RCALL  073E
....................    _I2C_Write(0x03);                         // Start at REG 3 - Day of week 
0AF2:  MOVLW  03
0AF4:  MOVWF  7E
0AF6:  RCALL  073E
....................    _I2C_Start();  
0AF8:  RCALL  072C
....................    _I2C_Write(0xD1);          
0AFA:  MOVLW  D1
0AFC:  MOVWF  7E
0AFE:  RCALL  073E
....................    // lecture DS1307 retourne (une valeur binaire codee BCD 
....................    // ex retourne 19 ou 0x13   l'an 13        
....................    dow  = bcd2bin(_I2C_Read(1)  & 0x07);   // REG 3 
0B00:  MOVLW  01
0B02:  MOVWF  76
0B04:  RCALL  0840
0B06:  MOVF   01,W
0B08:  ANDLW  07
0B0A:  MOVWF  76
0B0C:  MOVWF  77
0B0E:  RCALL  086C
0B10:  MOVFF  01,4D
....................    day  = bcd2bin(_I2C_Read(1)  & 0x3f);   // REG 4  
0B14:  MOVLW  01
0B16:  MOVWF  76
0B18:  RCALL  0840
0B1A:  MOVF   01,W
0B1C:  ANDLW  3F
0B1E:  MOVWF  76
0B20:  MOVWF  77
0B22:  RCALL  086C
0B24:  MOVFF  01,4A
....................    month  = bcd2bin(_I2C_Read(1)& 0x1f);   // REG 5  
0B28:  MOVLW  01
0B2A:  MOVWF  76
0B2C:  RCALL  0840
0B2E:  MOVF   01,W
0B30:  ANDLW  1F
0B32:  MOVWF  76
0B34:  MOVWF  77
0B36:  RCALL  086C
0B38:  MOVFF  01,4B
....................    yr = bcd2bin(_I2C_Read(0));    // REG 6         
0B3C:  CLRF   76
0B3E:  RCALL  0840
0B40:  MOVFF  01,76
0B44:  MOVFF  01,77
0B48:  RCALL  086C
0B4A:  MOVFF  01,4C
....................    _I2C_Stop();                
0B4E:  RCALL  0760
....................    getDayText();   
0B50:  RCALL  0A16
0B52:  GOTO   0B5A (RETURN)
.................... }                                        
....................                                                        
.................... void ds1307_get_time(){ 
....................    _I2C_Start();   
*
0886:  RCALL  072C
....................    _I2C_Write(0XD0);     
0888:  MOVLW  D0
088A:  MOVWF  7E
088C:  RCALL  073E
....................    _I2C_Write(0x00);                        // Start at REG 0 - Secondes  
088E:  CLRF   7E
0890:  RCALL  073E
....................    _I2C_Start();   
0892:  RCALL  072C
....................    _I2C_Write(0XD1);            
0894:  MOVLW  D1
0896:  MOVWF  7E
0898:  RCALL  073E
....................    sec = bcd2bin(_I2C_Read(1) & 0x7f);          
089A:  MOVLW  01
089C:  MOVWF  76
089E:  RCALL  0840
08A0:  MOVF   01,W
08A2:  ANDLW  7F
08A4:  MOVWF  76
08A6:  MOVWF  77
08A8:  RCALL  086C
08AA:  MOVFF  01,47
....................    min = bcd2bin(_I2C_Read(1) & 0x7f); 
08AE:  MOVLW  01
08B0:  MOVWF  76
08B2:  RCALL  0840
08B4:  MOVF   01,W
08B6:  ANDLW  7F
08B8:  MOVWF  76
08BA:  MOVWF  77
08BC:  RCALL  086C
08BE:  MOVFF  01,48
....................    hrs = bcd2bin(_I2C_Read(0) & 0x7f);    
08C2:  CLRF   76
08C4:  RCALL  0840
08C6:  MOVF   01,W
08C8:  ANDLW  7F
08CA:  MOVWF  76
08CC:  MOVWF  77
08CE:  RCALL  086C
08D0:  MOVFF  01,49
....................    _I2C_Stop();   
08D4:  RCALL  0760
08D6:  GOTO   0B58 (RETURN)
....................    //.  14 : 00 : 25  . 
....................    //sprintf(TIME,"  \%02d : \%02d : \%02d  ",hrs,min,sec);  
.................... }                                                                                     
....................             
....................        
.................... void getDayText(){                           
....................    switch(day_of_the_week(getYear(),getMonth(),getDay())){ 
*
0A16:  BRA    08DA
0A18:  MOVFF  01,77
0A1C:  BRA    08E2
0A1E:  MOVFF  01,78
0A22:  BRA    08EA
0A24:  MOVFF  01,79
0A28:  CLRF   7B
0A2A:  MOVFF  77,7A
0A2E:  CLRF   7D
0A30:  MOVFF  78,7C
0A34:  CLRF   7F
0A36:  MOVFF  01,7E
0A3A:  BRA    08F2
0A3C:  MOVFF  01,00
0A40:  MOVF   02,W
0A42:  MOVWF  03
0A44:  BNZ   0A4A
0A46:  MOVF   00,F
0A48:  BZ    0A88
0A4A:  MOVF   03,W
0A4C:  BNZ   0A54
0A4E:  MOVLW  01
0A50:  SUBWF  00,W
0A52:  BZ    0A96
0A54:  MOVF   03,W
0A56:  BNZ   0A5E
0A58:  MOVLW  02
0A5A:  SUBWF  00,W
0A5C:  BZ    0AA4
0A5E:  MOVF   03,W
0A60:  BNZ   0A68
0A62:  MOVLW  03
0A64:  SUBWF  00,W
0A66:  BZ    0AB2
0A68:  MOVF   03,W
0A6A:  BNZ   0A72
0A6C:  MOVLW  04
0A6E:  SUBWF  00,W
0A70:  BZ    0AC0
0A72:  MOVF   03,W
0A74:  BNZ   0A7C
0A76:  MOVLW  05
0A78:  SUBWF  00,W
0A7A:  BZ    0ACE
0A7C:  MOVF   03,W
0A7E:  BNZ   0A86
0A80:  MOVLW  06
0A82:  SUBWF  00,W
0A84:  BZ    0ADC
0A86:  BRA    0AE8
....................      case 0: memcpy(dayText,"Sun",3); break; 
0A88:  MOVLW  53
0A8A:  MOVWF  4E
0A8C:  MOVLW  75
0A8E:  MOVWF  4F
0A90:  MOVLW  6E
0A92:  MOVWF  50
0A94:  BRA    0AE8
....................      case 1: memcpy(dayText,"Mon",3); break; 
0A96:  MOVLW  4D
0A98:  MOVWF  4E
0A9A:  MOVLW  6F
0A9C:  MOVWF  4F
0A9E:  MOVLW  6E
0AA0:  MOVWF  50
0AA2:  BRA    0AE8
....................      case 2: memcpy(dayText,"Tue",3); break; 
0AA4:  MOVLW  54
0AA6:  MOVWF  4E
0AA8:  MOVLW  75
0AAA:  MOVWF  4F
0AAC:  MOVLW  65
0AAE:  MOVWF  50
0AB0:  BRA    0AE8
....................      case 3: memcpy(dayText,"Wed",3); break; 
0AB2:  MOVLW  57
0AB4:  MOVWF  4E
0AB6:  MOVLW  65
0AB8:  MOVWF  4F
0ABA:  MOVLW  64
0ABC:  MOVWF  50
0ABE:  BRA    0AE8
....................      case 4: memcpy(dayText,"Thu",3); break; 
0AC0:  MOVLW  54
0AC2:  MOVWF  4E
0AC4:  MOVLW  68
0AC6:  MOVWF  4F
0AC8:  MOVLW  75
0ACA:  MOVWF  50
0ACC:  BRA    0AE8
....................      case 5: memcpy(dayText,"Fri",3); break; 
0ACE:  MOVLW  46
0AD0:  MOVWF  4E
0AD2:  MOVLW  72
0AD4:  MOVWF  4F
0AD6:  MOVLW  69
0AD8:  MOVWF  50
0ADA:  BRA    0AE8
....................      case 6: memcpy(dayText,"Sat",3); break; 
0ADC:  MOVLW  53
0ADE:  MOVWF  4E
0AE0:  MOVLW  61
0AE2:  MOVWF  4F
0AE4:  MOVLW  74
0AE6:  MOVWF  50
....................    }    
0AE8:  RETURN 0
.................... }    
....................  
.................... uchar_t getSec(){ 
....................    return sec;   
.................... }  
.................... uchar_t getMin(){ 
....................    return min;   
.................... }   
.................... uchar_t getHour(){                     
....................    return hrs; 
.................... }   
.................... uchar_t getDow(){ 
....................    return dow;   
.................... }   
.................... uchar_t getDay(){ 
....................    return day;   
*
08EA:  MOVF   4A,W
08EC:  MOVWF  01
08EE:  GOTO   0A24 (RETURN)
.................... }  
.................... uchar_t getMonth(){ 
....................    return month;   
*
08E2:  MOVF   4B,W
08E4:  MOVWF  01
08E6:  GOTO   0A1E (RETURN)
.................... }   
.................... uchar_t getYear(){ 
....................    return yr;   
*
08DA:  MOVF   4C,W
08DC:  MOVWF  01
08DE:  GOTO   0A18 (RETURN)
.................... }         
....................  
.................... // <-------------      (0-7, Start Sunday)       ----------->  
.................... uint16_t day_of_the_week(uint16_t Y, uint16_t M, uint16_t D) {  
....................    uint16_t days[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };  
*
08F2:  CLRF   x80
08F4:  CLRF   x81
08F6:  MOVLW  03
08F8:  MOVWF  x82
08FA:  CLRF   x83
08FC:  MOVLW  02
08FE:  MOVWF  x84
0900:  CLRF   x85
0902:  MOVLW  05
0904:  MOVWF  x86
0906:  CLRF   x87
0908:  CLRF   x88
090A:  CLRF   x89
090C:  MOVLW  03
090E:  MOVWF  x8A
0910:  CLRF   x8B
0912:  MOVLW  05
0914:  MOVWF  x8C
0916:  CLRF   x8D
0918:  MOVLW  01
091A:  MOVWF  x8E
091C:  CLRF   x8F
091E:  MOVLW  04
0920:  MOVWF  x90
0922:  CLRF   x91
0924:  MOVLW  06
0926:  MOVWF  x92
0928:  CLRF   x93
092A:  MOVLW  02
092C:  MOVWF  x94
092E:  CLRF   x95
0930:  MOVLW  04
0932:  MOVWF  x96
0934:  CLRF   x97
....................    if (M < 3)  
0936:  MOVF   7D,F
0938:  BNZ   0948
093A:  MOVF   7C,W
093C:  SUBLW  02
093E:  BNC   0948
....................       Y--;         
0940:  MOVF   7A,W
0942:  BTFSC  FD8.2
0944:  DECF   7B,F
0946:  DECF   7A,F
....................    return (Y + Y / 4 - Y / 100 + Y / 400 + days[M - 1] + D) % 7;  
0948:  RRCF   7B,W
094A:  MOVWF  03
094C:  RRCF   7A,W
094E:  MOVWF  02
0950:  RRCF   03,F
0952:  RRCF   02,F
0954:  MOVLW  3F
0956:  ANDWF  03,F
0958:  MOVF   02,W
095A:  ADDWF  7A,W
095C:  MOVWF  x98
095E:  MOVF   03,W
0960:  ADDWFC 7B,W
0962:  MOVWF  x99
0964:  CLRF   16
0966:  BTFSC  FF2.7
0968:  BSF    16.7
096A:  BCF    FF2.7
096C:  MOVFF  7B,A0
0970:  MOVFF  7A,9F
0974:  CLRF   xA2
0976:  MOVLW  64
0978:  MOVWF  xA1
097A:  RCALL  054A
097C:  BTFSC  16.7
097E:  BSF    FF2.7
0980:  MOVFF  02,03
0984:  MOVF   01,W
0986:  SUBWF  x98,F
0988:  MOVF   02,W
098A:  SUBWFB x99,F
098C:  CLRF   16
098E:  BTFSC  FF2.7
0990:  BSF    16.7
0992:  BCF    FF2.7
0994:  MOVFF  7B,A0
0998:  MOVFF  7A,9F
099C:  MOVLW  01
099E:  MOVWF  xA2
09A0:  MOVLW  90
09A2:  MOVWF  xA1
09A4:  RCALL  054A
09A6:  BTFSC  16.7
09A8:  BSF    FF2.7
09AA:  MOVFF  02,03
09AE:  MOVF   01,W
09B0:  ADDWF  x98,F
09B2:  MOVF   02,W
09B4:  ADDWFC x99,F
09B6:  MOVLW  01
09B8:  SUBWF  7C,W
09BA:  MOVWF  x9A
09BC:  MOVLW  00
09BE:  SUBWFB 7D,W
09C0:  MOVWF  x9B
09C2:  BCF    FD8.0
09C4:  RLCF   x9A,W
09C6:  MOVWF  02
09C8:  RLCF   x9B,W
09CA:  MOVWF  03
09CC:  MOVF   02,W
09CE:  ADDLW  80
09D0:  MOVWF  FE9
09D2:  MOVLW  00
09D4:  ADDWFC 03,W
09D6:  MOVWF  FEA
09D8:  MOVFF  FEC,03
09DC:  MOVF   FED,F
09DE:  MOVF   FEF,W
09E0:  ADDWF  x98,F
09E2:  MOVF   03,W
09E4:  ADDWFC x99,F
09E6:  MOVF   7E,W
09E8:  ADDWF  x98,F
09EA:  MOVF   7F,W
09EC:  ADDWFC x99,F
09EE:  CLRF   16
09F0:  BTFSC  FF2.7
09F2:  BSF    16.7
09F4:  BCF    FF2.7
09F6:  MOVFF  99,A0
09FA:  MOVFF  98,9F
09FE:  CLRF   xA2
0A00:  MOVLW  07
0A02:  MOVWF  xA1
0A04:  RCALL  054A
0A06:  BTFSC  16.7
0A08:  BSF    FF2.7
0A0A:  MOVFF  00,01
0A0E:  MOVFF  03,02
0A12:  GOTO   0A3C (RETURN)
.................... }                    
....................  
....................                                                                                                                 
....................  
.................... #include "DS1307timeset.c" 
.................... #include "definitions.h"       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "i2c.h"   
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef I2C_H                                                            
.................... #define I2C_H                                                                  
....................  
.................... void _I2C_Start();          
.................... void _I2C_Stop();   
.................... void I2C_Clock();                                                             
....................  
.................... uchar_t _I2C_Read(uchar_t);                
.................... void _I2CACK(uchar_t);      
.................... void _I2C_Write(uchar_t);      
....................  
....................  
.................... void i2cHighSda(void);                     
.................... void i2cLowSda(void);                                                           
.................... void i2cHighScl(void); 
.................... void i2cLowScl(void);  
....................  
....................  
....................                     
.................... #endif //I2C_H      
....................  
....................  
....................            
....................  
.................... //TIME CONTROL VIA BUTTON AND LCD 
.................... uint8_t position;      
.................... uint8_t executed;          
.................... date_t DATE_STATUS;   
....................                                       
.................... // SET = 0; herhangi bir ayarlama yok    
.................... // SET = 1; (AY/Yil/Gun... secimi)   
.................... // SET = 2; SET =1' de belilrlenen pozisyon elementinin degerini arttirma azaltma 
.................... // SET = 3 execute and SET=0;  
.................... void setTimeCases(){  
....................    if(DATE_STATUS.X.SET==1){       
*
14FE:  MOVF   46,W
1500:  MOVWF  00
1502:  SWAPF  00,F
1504:  RRCF   00,F
1506:  RRCF   00,W
1508:  ANDLW  03
150A:  SUBLW  01
150C:  BNZ   1514
....................       chooseElement(position);   
150E:  MOVFF  44,76
1512:  BRA    105A
....................    }                                      
....................    if(DATE_STATUS.X.SET==2){    
1514:  MOVFF  46,00
1518:  SWAPF  00,F
151A:  RRCF   00,F
151C:  RRCF   00,W
151E:  ANDLW  03
1520:  SUBLW  02
1522:  BNZ   152A
....................       arrangeValueOfElement(position);   
1524:  MOVFF  44,76
1528:  BRA    11F6
....................    }  
....................    if(DATE_STATUS.X.SET==3){    
152A:  MOVFF  46,00
152E:  SWAPF  00,F
1530:  RRCF   00,F
1532:  RRCF   00,W
1534:  ANDLW  03
1536:  SUBLW  03
1538:  BNZ   1540
....................       setRTC(position);   
153A:  MOVFF  44,76
153E:  BRA    146E
....................    }  
1540:  GOTO   01D0 (RETURN)
.................... }    
.................... // SET = 1; (AY/Yil/Gun... secimi) 
.................... void chooseElement(uchar_t position_t){        
....................                                      
....................    switch(position_t){ 
*
105A:  MOVF   76,W
105C:  ADDLW  FA
105E:  BTFSC  FD8.0
1060:  BRA    11C2
1062:  ADDLW  06
1064:  GOTO   11C6
....................    case 0: // SECOND                     
....................          memset(strLCD,0,32);  
1068:  CLRF   FEA
106A:  MOVLW  1B
106C:  MOVWF  FE9
106E:  CLRF   00
1070:  CLRF   02
1072:  MOVLW  20
1074:  MOVWF  01
1076:  RCALL  0EFA
....................          sprintf(DATE_TIME,"     SECOND     ");    
1078:  CLRF   75
107A:  MOVLW  52
107C:  MOVWF  74
107E:  MOVLW  D2
1080:  MOVWF  FF6
1082:  MOVLW  00
1084:  MOVWF  FF7
1086:  RCALL  103A
....................          memcpy(strLCD,DATE_TIME,17);  
1088:  CLRF   FEA
108A:  MOVLW  1B
108C:  MOVWF  FE9
108E:  CLRF   FE2
1090:  MOVLW  52
1092:  MOVWF  FE1
1094:  MOVLW  11
1096:  MOVWF  01
1098:  MOVFF  FE6,FEE
109C:  DECFSZ 01,F
109E:  BRA    1098
....................    break;             //1234567890123456 
10A0:  BRA    11C2
....................           
....................    case 1: // MINUTE 
....................          memset(strLCD,0,32);              
10A2:  CLRF   FEA
10A4:  MOVLW  1B
10A6:  MOVWF  FE9
10A8:  CLRF   00
10AA:  CLRF   02
10AC:  MOVLW  20
10AE:  MOVWF  01
10B0:  RCALL  0EFA
....................          sprintf(DATE_TIME,"     MINUTE     ");    
10B2:  CLRF   75
10B4:  MOVLW  52
10B6:  MOVWF  74
10B8:  MOVLW  E4
10BA:  MOVWF  FF6
10BC:  MOVLW  00
10BE:  MOVWF  FF7
10C0:  RCALL  103A
....................          memcpy(strLCD,DATE_TIME,17);  
10C2:  CLRF   FEA
10C4:  MOVLW  1B
10C6:  MOVWF  FE9
10C8:  CLRF   FE2
10CA:  MOVLW  52
10CC:  MOVWF  FE1
10CE:  MOVLW  11
10D0:  MOVWF  01
10D2:  MOVFF  FE6,FEE
10D6:  DECFSZ 01,F
10D8:  BRA    10D2
....................    break;             //1234567890123456   
10DA:  BRA    11C2
....................           
....................    case 2: // HOUR   
....................          memset(strLCD,0,32); 
10DC:  CLRF   FEA
10DE:  MOVLW  1B
10E0:  MOVWF  FE9
10E2:  CLRF   00
10E4:  CLRF   02
10E6:  MOVLW  20
10E8:  MOVWF  01
10EA:  RCALL  0EFA
....................          sprintf(DATE_TIME,"      HOUR      ");    
10EC:  CLRF   75
10EE:  MOVLW  52
10F0:  MOVWF  74
10F2:  MOVLW  02
10F4:  MOVWF  FF6
10F6:  MOVLW  04
10F8:  MOVWF  FF7
10FA:  RCALL  103A
....................          memcpy(strLCD,DATE_TIME,17);  
10FC:  CLRF   FEA
10FE:  MOVLW  1B
1100:  MOVWF  FE9
1102:  CLRF   FE2
1104:  MOVLW  52
1106:  MOVWF  FE1
1108:  MOVLW  11
110A:  MOVWF  01
110C:  MOVFF  FE6,FEE
1110:  DECFSZ 01,F
1112:  BRA    110C
....................    break;             //1234567890123456  
1114:  BRA    11C2
....................                         
....................    case 3: // DAY 
....................          memset(strLCD,0,32);           
1116:  CLRF   FEA
1118:  MOVLW  1B
111A:  MOVWF  FE9
111C:  CLRF   00
111E:  CLRF   02
1120:  MOVLW  20
1122:  MOVWF  01
1124:  RCALL  0EFA
....................          sprintf(DATE_TIME,"       DAY      ");    
1126:  CLRF   75
1128:  MOVLW  52
112A:  MOVWF  74
112C:  MOVLW  14
112E:  MOVWF  FF6
1130:  MOVLW  04
1132:  MOVWF  FF7
1134:  RCALL  103A
....................          memcpy(strLCD,DATE_TIME,17);  
1136:  CLRF   FEA
1138:  MOVLW  1B
113A:  MOVWF  FE9
113C:  CLRF   FE2
113E:  MOVLW  52
1140:  MOVWF  FE1
1142:  MOVLW  11
1144:  MOVWF  01
1146:  MOVFF  FE6,FEE
114A:  DECFSZ 01,F
114C:  BRA    1146
....................    break;             //1234567890123456  
114E:  BRA    11C2
....................     
....................    case 4: // MONTH   
....................          memset(strLCD,0,32);                            
1150:  CLRF   FEA
1152:  MOVLW  1B
1154:  MOVWF  FE9
1156:  CLRF   00
1158:  CLRF   02
115A:  MOVLW  20
115C:  MOVWF  01
115E:  RCALL  0EFA
....................          sprintf(DATE_TIME,"      MONTH     ");    
1160:  CLRF   75
1162:  MOVLW  52
1164:  MOVWF  74
1166:  MOVLW  26
1168:  MOVWF  FF6
116A:  MOVLW  04
116C:  MOVWF  FF7
116E:  RCALL  103A
....................          memcpy(strLCD,DATE_TIME,17);  
1170:  CLRF   FEA
1172:  MOVLW  1B
1174:  MOVWF  FE9
1176:  CLRF   FE2
1178:  MOVLW  52
117A:  MOVWF  FE1
117C:  MOVLW  11
117E:  MOVWF  01
1180:  MOVFF  FE6,FEE
1184:  DECFSZ 01,F
1186:  BRA    1180
....................    break;             //1234567890123456                       
1188:  BRA    11C2
....................     
....................    case 5: // YEAR   
....................          memset(strLCD,0,32);                          
118A:  CLRF   FEA
118C:  MOVLW  1B
118E:  MOVWF  FE9
1190:  CLRF   00
1192:  CLRF   02
1194:  MOVLW  20
1196:  MOVWF  01
1198:  RCALL  0EFA
....................          sprintf(DATE_TIME,"      YEAR      ");    
119A:  CLRF   75
119C:  MOVLW  52
119E:  MOVWF  74
11A0:  MOVLW  38
11A2:  MOVWF  FF6
11A4:  MOVLW  04
11A6:  MOVWF  FF7
11A8:  RCALL  103A
....................          memcpy(strLCD,DATE_TIME,17); 
11AA:  CLRF   FEA
11AC:  MOVLW  1B
11AE:  MOVWF  FE9
11B0:  CLRF   FE2
11B2:  MOVLW  52
11B4:  MOVWF  FE1
11B6:  MOVLW  11
11B8:  MOVWF  01
11BA:  MOVFF  FE6,FEE
11BE:  DECFSZ 01,F
11C0:  BRA    11BA
....................    break;             //1234567890123456 
....................    } 
11C2:  GOTO   1514 (RETURN)
.................... }    
....................                
.................... void arrangeValueOfElement(uchar_t position_t){    
....................    switch(position_t){  
*
11F6:  MOVF   76,W
11F8:  ADDLW  FA
11FA:  BTFSC  FD8.0
11FC:  BRA    1406
11FE:  ADDLW  06
1200:  GOTO   140A
....................    case 0:                                                                
....................          memset(strLCD,0,32);           // |        |                     
1204:  CLRF   FEA
1206:  MOVLW  1B
1208:  MOVWF  FE9
120A:  CLRF   00
120C:  CLRF   02
120E:  MOVLW  20
1210:  MOVWF  01
1212:  RCALL  0EFA
....................          sprintf(DATE_TIME,"     SECOND            \%02d       ",sec);  
1214:  CLRF   75
1216:  MOVLW  52
1218:  MOVWF  74
121A:  MOVLW  4A
121C:  MOVWF  FF6
121E:  MOVLW  04
1220:  MOVWF  FF7
1222:  MOVLW  17
1224:  MOVWF  77
1226:  RCALL  0EB6
1228:  MOVFF  47,77
122C:  MOVLW  01
122E:  MOVWF  78
1230:  RCALL  0E0C
1232:  MOVLW  65
1234:  MOVWF  FF6
1236:  MOVLW  04
1238:  MOVWF  FF7
123A:  MOVLW  07
123C:  MOVWF  77
123E:  RCALL  0EB6
....................          memcpy(strLCD,DATE_TIME,32);           
1240:  CLRF   FEA
1242:  MOVLW  1B
1244:  MOVWF  FE9
1246:  CLRF   FE2
1248:  MOVLW  52
124A:  MOVWF  FE1
124C:  MOVLW  20
124E:  MOVWF  01
1250:  MOVFF  FE6,FEE
1254:  DECFSZ 01,F
1256:  BRA    1250
....................    break; 
1258:  BRA    1406
....................     
....................    case 1: 
....................          memset(strLCD,0,32);           // |        |                     
125A:  CLRF   FEA
125C:  MOVLW  1B
125E:  MOVWF  FE9
1260:  CLRF   00
1262:  CLRF   02
1264:  MOVLW  20
1266:  MOVWF  01
1268:  RCALL  0EFA
....................          sprintf(DATE_TIME,"     MINUTE            \%02d       ",min); 
126A:  CLRF   75
126C:  MOVLW  52
126E:  MOVWF  74
1270:  MOVLW  6E
1272:  MOVWF  FF6
1274:  MOVLW  04
1276:  MOVWF  FF7
1278:  MOVLW  17
127A:  MOVWF  77
127C:  RCALL  0EB6
127E:  MOVFF  48,77
1282:  MOVLW  01
1284:  MOVWF  78
1286:  RCALL  0E0C
1288:  MOVLW  89
128A:  MOVWF  FF6
128C:  MOVLW  04
128E:  MOVWF  FF7
1290:  MOVLW  07
1292:  MOVWF  77
1294:  RCALL  0EB6
....................          memcpy(strLCD,DATE_TIME,32); 
1296:  CLRF   FEA
1298:  MOVLW  1B
129A:  MOVWF  FE9
129C:  CLRF   FE2
129E:  MOVLW  52
12A0:  MOVWF  FE1
12A2:  MOVLW  20
12A4:  MOVWF  01
12A6:  MOVFF  FE6,FEE
12AA:  DECFSZ 01,F
12AC:  BRA    12A6
....................     
....................    break; 
12AE:  BRA    1406
....................     
....................    case 2: 
....................          memset(strLCD,0,32);           // |        |                     
12B0:  CLRF   FEA
12B2:  MOVLW  1B
12B4:  MOVWF  FE9
12B6:  CLRF   00
12B8:  CLRF   02
12BA:  MOVLW  20
12BC:  MOVWF  01
12BE:  RCALL  0EFA
....................          sprintf(DATE_TIME,"      HOUR             \%02d       ",hrs); 
12C0:  CLRF   75
12C2:  MOVLW  52
12C4:  MOVWF  74
12C6:  MOVLW  92
12C8:  MOVWF  FF6
12CA:  MOVLW  04
12CC:  MOVWF  FF7
12CE:  MOVLW  17
12D0:  MOVWF  77
12D2:  RCALL  0EB6
12D4:  MOVFF  49,77
12D8:  MOVLW  01
12DA:  MOVWF  78
12DC:  RCALL  0E0C
12DE:  MOVLW  AD
12E0:  MOVWF  FF6
12E2:  MOVLW  04
12E4:  MOVWF  FF7
12E6:  MOVLW  07
12E8:  MOVWF  77
12EA:  RCALL  0EB6
....................          memcpy(strLCD,DATE_TIME,32); 
12EC:  CLRF   FEA
12EE:  MOVLW  1B
12F0:  MOVWF  FE9
12F2:  CLRF   FE2
12F4:  MOVLW  52
12F6:  MOVWF  FE1
12F8:  MOVLW  20
12FA:  MOVWF  01
12FC:  MOVFF  FE6,FEE
1300:  DECFSZ 01,F
1302:  BRA    12FC
....................    break;                                                        
1304:  BRA    1406
....................     
....................    case 3: 
....................          memset(strLCD,0,32);           // |        |                     
1306:  CLRF   FEA
1308:  MOVLW  1B
130A:  MOVWF  FE9
130C:  CLRF   00
130E:  CLRF   02
1310:  MOVLW  20
1312:  MOVWF  01
1314:  RCALL  0EFA
....................          sprintf(DATE_TIME,"      DAY'             \%02d       ",day); 
1316:  CLRF   75
1318:  MOVLW  52
131A:  MOVWF  74
131C:  MOVLW  B6
131E:  MOVWF  FF6
1320:  MOVLW  04
1322:  MOVWF  FF7
1324:  MOVLW  17
1326:  MOVWF  77
1328:  RCALL  0EB6
132A:  MOVFF  4A,77
132E:  MOVLW  01
1330:  MOVWF  78
1332:  RCALL  0E0C
1334:  MOVLW  D1
1336:  MOVWF  FF6
1338:  MOVLW  04
133A:  MOVWF  FF7
133C:  MOVLW  07
133E:  MOVWF  77
1340:  RCALL  0EB6
....................          memcpy(strLCD,DATE_TIME,32); 
1342:  CLRF   FEA
1344:  MOVLW  1B
1346:  MOVWF  FE9
1348:  CLRF   FE2
134A:  MOVLW  52
134C:  MOVWF  FE1
134E:  MOVLW  20
1350:  MOVWF  01
1352:  MOVFF  FE6,FEE
1356:  DECFSZ 01,F
1358:  BRA    1352
....................    break; 
135A:  BRA    1406
....................     
....................    case 4:                     
....................          memset(strLCD,0,32);           // |        |                     
135C:  CLRF   FEA
135E:  MOVLW  1B
1360:  MOVWF  FE9
1362:  CLRF   00
1364:  CLRF   02
1366:  MOVLW  20
1368:  MOVWF  01
136A:  RCALL  0EFA
....................          sprintf(DATE_TIME,"      MONTH            \%02d     ",month); 
136C:  CLRF   75
136E:  MOVLW  52
1370:  MOVWF  74
1372:  MOVLW  DA
1374:  MOVWF  FF6
1376:  MOVLW  04
1378:  MOVWF  FF7
137A:  MOVLW  17
137C:  MOVWF  77
137E:  RCALL  0EB6
1380:  MOVFF  4B,77
1384:  MOVLW  01
1386:  MOVWF  78
1388:  RCALL  0E0C
138A:  MOVLW  F5
138C:  MOVWF  FF6
138E:  MOVLW  04
1390:  MOVWF  FF7
1392:  MOVLW  05
1394:  MOVWF  77
1396:  RCALL  0EB6
....................          memcpy(strLCD,DATE_TIME,32); 
1398:  CLRF   FEA
139A:  MOVLW  1B
139C:  MOVWF  FE9
139E:  CLRF   FE2
13A0:  MOVLW  52
13A2:  MOVWF  FE1
13A4:  MOVLW  20
13A6:  MOVWF  01
13A8:  MOVFF  FE6,FEE
13AC:  DECFSZ 01,F
13AE:  BRA    13A8
....................    break; 
13B0:  BRA    1406
....................     
....................    case 5:  
....................          memset(strLCD,0,32);           // |        |                     
13B2:  CLRF   FEA
13B4:  MOVLW  1B
13B6:  MOVWF  FE9
13B8:  CLRF   00
13BA:  CLRF   02
13BC:  MOVLW  20
13BE:  MOVWF  01
13C0:  RCALL  0EFA
....................          sprintf(DATE_TIME,"      YEAR             \%02d     ",yr);    
13C2:  CLRF   75
13C4:  MOVLW  52
13C6:  MOVWF  74
13C8:  MOVLW  FC
13CA:  MOVWF  FF6
13CC:  MOVLW  04
13CE:  MOVWF  FF7
13D0:  MOVLW  17
13D2:  MOVWF  77
13D4:  RCALL  0EB6
13D6:  MOVFF  4C,77
13DA:  MOVLW  01
13DC:  MOVWF  78
13DE:  RCALL  0E0C
13E0:  MOVLW  17
13E2:  MOVWF  FF6
13E4:  MOVLW  05
13E6:  MOVWF  FF7
13E8:  MOVLW  05
13EA:  MOVWF  77
13EC:  RCALL  0EB6
....................          memcpy(strLCD,DATE_TIME,32); 
13EE:  CLRF   FEA
13F0:  MOVLW  1B
13F2:  MOVWF  FE9
13F4:  CLRF   FE2
13F6:  MOVLW  52
13F8:  MOVWF  FE1
13FA:  MOVLW  20
13FC:  MOVWF  01
13FE:  MOVFF  FE6,FEE
1402:  DECFSZ 01,F
1404:  BRA    13FE
....................    break; 
....................    } 
1406:  GOTO   152A (RETURN)
.................... }      
....................   
.................... //MODE=0 DECREASE, MODE = 1 INCREASE 
.................... void increaseElement(uchar_t position_t){         
....................    switch(position_t){ 
*
1566:  MOVF   78,W
1568:  ADDLW  FA
156A:  BC    15CE
156C:  ADDLW  06
156E:  GOTO   15D2
....................    case 0: 
....................         if(sec>=59){sec=0;}else{sec++;} 
1572:  MOVF   47,W
1574:  SUBLW  3A
1576:  BC    157C
1578:  CLRF   47
157A:  BRA    157E
157C:  INCF   47,F
....................    break;                                   
157E:  BRA    15CE
....................     
....................    case 1: 
....................         if(min>=59){min=0;}else{min++;}  
1580:  MOVF   48,W
1582:  SUBLW  3A
1584:  BC    158A
1586:  CLRF   48
1588:  BRA    158C
158A:  INCF   48,F
....................    break; 
158C:  BRA    15CE
....................     
....................    case 2:                           
....................         if(hrs>=23){hrs=0;}else{hrs++;}  
158E:  MOVF   49,W
1590:  SUBLW  16
1592:  BC    1598
1594:  CLRF   49
1596:  BRA    159A
1598:  INCF   49,F
....................    break; 
159A:  BRA    15CE
....................     
....................    case 3:  
....................         if(day>=exactDayOfMonth()){day=1;}else{day++;}  
159C:  CALL   0B84
15A0:  MOVF   01,W
15A2:  SUBWF  4A,W
15A4:  BNC   15AC
15A6:  MOVLW  01
15A8:  MOVWF  4A
15AA:  BRA    15AE
15AC:  INCF   4A,F
....................    break; 
15AE:  BRA    15CE
....................     
....................    case 4: 
....................         if(month>=12){month=1;}else{month++;} 
15B0:  MOVF   4B,W
15B2:  SUBLW  0B
15B4:  BC    15BC
15B6:  MOVLW  01
15B8:  MOVWF  4B
15BA:  BRA    15BE
15BC:  INCF   4B,F
....................    break; 
15BE:  BRA    15CE
....................                                              
....................    case 5: 
....................         if(yr>=99){yr=1;}else{yr++;} 
15C0:  MOVF   4C,W
15C2:  SUBLW  62
15C4:  BC    15CC
15C6:  MOVLW  01
15C8:  MOVWF  4C
15CA:  BRA    15CE
15CC:  INCF   4C,F
....................    break;  
....................    }   
15CE:  GOTO   163E (RETURN)
.................... }    
....................  
.................... void decreaseElement(uchar_t position_t){ 
....................    switch(position_t){ 
*
1672:  MOVF   78,W
1674:  ADDLW  FA
1676:  BC    16D8
1678:  ADDLW  06
167A:  GOTO   16DC
....................    case 0: 
....................         if(sec<=0){sec=59; }else{sec--;} 
167E:  MOVF   47,F
1680:  BNZ   1688
1682:  MOVLW  3B
1684:  MOVWF  47
1686:  BRA    168A
1688:  DECF   47,F
....................    break; 
168A:  BRA    16D8
....................     
....................    case 1: 
....................         if(min<=0){min=59; }else{min--;}   
168C:  MOVF   48,F
168E:  BNZ   1696
1690:  MOVLW  3B
1692:  MOVWF  48
1694:  BRA    1698
1696:  DECF   48,F
....................    break; 
1698:  BRA    16D8
....................     
....................    case 2: 
....................         if(hrs<=0){hrs=23; }else{hrs--;}   
169A:  MOVF   49,F
169C:  BNZ   16A4
169E:  MOVLW  17
16A0:  MOVWF  49
16A2:  BRA    16A6
16A4:  DECF   49,F
....................    break; 
16A6:  BRA    16D8
....................     
....................    case 3: 
....................         if(day<=1){day=exactDayOfMonth(); }else{day--;}  
16A8:  MOVF   4A,W
16AA:  SUBLW  01
16AC:  BNC   16B8
16AE:  CALL   0B84
16B2:  MOVFF  01,4A
16B6:  BRA    16BA
16B8:  DECF   4A,F
....................    break; 
16BA:  BRA    16D8
....................     
....................    case 4: 
....................         if(month<=1){month=12; }else{month--;}  
16BC:  MOVF   4B,W
16BE:  SUBLW  01
16C0:  BNC   16C8
16C2:  MOVLW  0C
16C4:  MOVWF  4B
16C6:  BRA    16CA
16C8:  DECF   4B,F
....................    break; 
16CA:  BRA    16D8
....................     
....................    case 5: 
....................         if(yr<=0){yr=99; }else{yr--;}  
16CC:  MOVF   4C,F
16CE:  BNZ   16D6
16D0:  MOVLW  63
16D2:  MOVWF  4C
16D4:  BRA    16D8
16D6:  DECF   4C,F
....................    break; 
....................        
....................    }      
16D8:  GOTO   1748 (RETURN)
.................... }      
....................  
.................... void setRTC(uchar_t position_t){ 
....................    switch(position_t){                        
*
146E:  MOVF   76,W
1470:  ADDLW  FA
1472:  BC    14BE
1474:  ADDLW  06
1476:  GOTO   14CE
....................    case 0: 
....................         txRTC(0x00,sec); 
147A:  CLRF   77
147C:  MOVFF  47,78
1480:  RCALL  143A
....................    break;                                   
1482:  BRA    14BE
....................     
....................    case 1: 
....................         txRTC(0x01,min);  
1484:  MOVLW  01
1486:  MOVWF  77
1488:  MOVFF  48,78
148C:  RCALL  143A
....................    break;                  
148E:  BRA    14BE
....................     
....................    case 2:                  
....................         txRTC(0x02,hrs);  
1490:  MOVLW  02
1492:  MOVWF  77
1494:  MOVFF  49,78
1498:  RCALL  143A
....................    break; 
149A:  BRA    14BE
....................                      
....................    case 3:  
....................         txRTC(0x04,day);  
149C:  MOVLW  04
149E:  MOVWF  77
14A0:  MOVFF  4A,78
14A4:  RCALL  143A
....................    break; 
14A6:  BRA    14BE
....................     
....................    case 4: 
....................         txRTC(0x05,month); 
14A8:  MOVLW  05
14AA:  MOVWF  77
14AC:  MOVFF  4B,78
14B0:  RCALL  143A
....................    break; 
14B2:  BRA    14BE
....................                                              
....................    case 5: 
....................         txRTC(0x06,yr); 
14B4:  MOVLW  06
14B6:  MOVWF  77
14B8:  MOVFF  4C,78
14BC:  RCALL  143A
....................    break;                 
....................    }   
....................    getDayText(); 
14BE:  CALL   0A16
....................    DATE_STATUS.X.SET=0;  
14C2:  MOVLW  3F
14C4:  ANDWF  46,W
14C6:  MOVWF  46
....................    position=0;                                                         
14C8:  CLRF   44
14CA:  GOTO   1540 (RETURN)
.................... }       
....................  
.................... void txRTC(uchar_t address, uchar_t value){ 
....................    sec &= 0x7F;                     
*
143A:  BCF    47.7
....................    min &= 0x7F;                                  
143C:  BCF    48.7
....................    hrs &= (0x7F|0x40);  //format 24H                                    
143E:  BCF    49.7
....................          
....................   _I2C_Start();                // I2C write address   
1440:  CALL   072C
....................   _I2C_Write(0xD0);            // Start at REG 0 - Seconds 
1444:  MOVLW  D0
1446:  MOVWF  7E
1448:  CALL   073E
....................   _I2C_Write(address);         // Start at REG 0 - Seconds 
144C:  MOVFF  77,7E
1450:  CALL   073E
....................   _I2C_Write(bin2bcd(value));  // REG 0   
1454:  MOVFF  78,7D
1458:  CALL   0782
145C:  MOVFF  01,79
1460:  MOVFF  01,7E
1464:  CALL   073E
....................   _I2C_Stop();  
1468:  CALL   0760
146C:  RETURN 0
.................... }   
....................                                    
.................... uchar_t exactDayOfMonth(){  
....................    if(month==4 || month==6 || month==9 || month==11)  
*
0B84:  MOVF   4B,W
0B86:  SUBLW  04
0B88:  BZ    0B9C
0B8A:  MOVF   4B,W
0B8C:  SUBLW  06
0B8E:  BZ    0B9C
0B90:  MOVF   4B,W
0B92:  SUBLW  09
0B94:  BZ    0B9C
0B96:  MOVF   4B,W
0B98:  SUBLW  0B
0B9A:  BNZ   0BA2
....................       return 30; 
0B9C:  MOVLW  1E
0B9E:  MOVWF  01
0BA0:  BRA    0C06
....................    if(month==2){  
0BA2:  MOVF   4B,W
0BA4:  SUBLW  02
0BA6:  BNZ   0C02
....................       if((yr%4) == 0){ 
0BA8:  MOVF   4C,W
0BAA:  ANDLW  03
0BAC:  BNZ   0BFC
0BAE:  CLRF   16
0BB0:  BTFSC  FF2.7
0BB2:  BSF    16.7
0BB4:  BCF    FF2.7
....................          if((yr%400) == 0)  
0BB6:  CLRF   xA0
0BB8:  MOVFF  4C,9F
0BBC:  MOVLW  01
0BBE:  MOVWF  xA2
0BC0:  MOVLW  90
0BC2:  MOVWF  xA1
0BC4:  RCALL  054A
0BC6:  BTFSC  16.7
0BC8:  BSF    FF2.7
0BCA:  MOVFF  00,79
0BCE:  MOVFF  03,7A
0BD2:  MOVF   79,F
0BD4:  BNZ   0BE2
0BD6:  MOVF   7A,F
0BD8:  BNZ   0BE2
....................             return 29;              
0BDA:  MOVLW  1D
0BDC:  MOVWF  01
0BDE:  BRA    0C06
0BE0:  BRA    0BF6
....................          else if((yr%100) == 0)  
0BE2:  MOVFF  4C,7D
0BE6:  MOVLW  64
0BE8:  MOVWF  7E
0BEA:  RCALL  0B5C
0BEC:  MOVF   00,F
0BEE:  BNZ   0BF6
....................             return 28; 
0BF0:  MOVLW  1C
0BF2:  MOVWF  01
0BF4:  BRA    0C06
....................          return 29; 
0BF6:  MOVLW  1D
0BF8:  MOVWF  01
0BFA:  BRA    0C06
....................       }  
....................       return 28; 
0BFC:  MOVLW  1C
0BFE:  MOVWF  01
0C00:  BRA    0C06
....................    }           
....................    return 31;  
0C02:  MOVLW  1F
0C04:  MOVWF  01
0C06:  RETURN 0
.................... } 
....................  
.................... #include "timedate.c" 
.................... #include "timedate.h" 
.................... #ifndef TIMEDATE_H 
.................... #define TIMEDATE_H 
....................  
.................... //METHODS  
.................... void getTime(); 
.................... void runTime();  
.................... void getDayTextt(); 
.................... uchar_t exactDayOfMonthh();      
.................... uint16_t day_of_the_weekk(uint16_t, uint16_t, uint16_t); 
....................  
....................  
.................... #endif //TIMEDATE_H 
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
....................                                                  
.................... void runTime(){  
*
0F14:  CLRF   76
.................... uint8_t calculatWeekDay=0; 
....................    if(sec>=59){ //SANIYE ASIMI 
0F16:  MOVF   47,W
0F18:  SUBLW  3A
0F1A:  BC    0F68
....................       sec=0; 
0F1C:  CLRF   47
....................       if(min>=59){ //DAKIKA ASIMI 
0F1E:  MOVF   48,W
0F20:  SUBLW  3A
0F22:  BC    0F64
....................          min=0;  
0F24:  CLRF   48
....................          if(hrs>=23){ //SAAT ASIMI 
0F26:  MOVF   49,W
0F28:  SUBLW  16
0F2A:  BC    0F60
....................             hrs=0; 
0F2C:  CLRF   49
....................             if(day>=exactDayOfMonth()){  //GUN ASIMI   
0F2E:  RCALL  0B84
0F30:  MOVF   01,W
0F32:  SUBWF  4A,W
0F34:  BNC   0F58
....................                day=1;  
0F36:  MOVLW  01
0F38:  MOVWF  4A
....................                calculatWeekDay=1;  
0F3A:  MOVWF  76
....................                if(month>=12){          //AY ASIMI 
0F3C:  MOVF   4B,W
0F3E:  SUBLW  0B
0F40:  BC    0F54
....................                   month=1; 
0F42:  MOVLW  01
0F44:  MOVWF  4B
....................                   if(yr>=99){ 
0F46:  MOVF   4C,W
0F48:  SUBLW  62
0F4A:  BC    0F50
....................                      yr=0;   
0F4C:  CLRF   4C
....................                   }else{ 
0F4E:  BRA    0F52
....................                      yr++; 
0F50:  INCF   4C,F
....................                   }                             
....................                }else{  
0F52:  BRA    0F56
....................                   month++; 
0F54:  INCF   4B,F
....................                } 
....................             }else{  
0F56:  BRA    0F5E
....................                day++; 
0F58:  INCF   4A,F
....................                calculatWeekDay=1;  
0F5A:  MOVLW  01
0F5C:  MOVWF  76
....................             } 
....................          }else{ 
0F5E:  BRA    0F62
....................             hrs++; 
0F60:  INCF   49,F
....................          } 
....................       }else{                                             
0F62:  BRA    0F66
....................         min++; 
0F64:  INCF   48,F
....................       } 
....................    }else{ 
0F66:  BRA    0F6A
....................       sec++; 
0F68:  INCF   47,F
....................    }   
....................    if(calculatWeekDay) 
0F6A:  MOVF   76,F
0F6C:  BZ    0F70
....................      getDayTextt(); 
0F6E:  BRA    0D2C
....................    //.  14 : 00 : 25  . 
....................     // Fri - 24/07/23   
....................    sprintf(DATE_TIME,"  \%02d : \%02d : \%02d   %s - \%02d/\%02d/\%02d",hrs,min,sec,dayText,day,month,yr);  
0F70:  CLRF   75
0F72:  MOVLW  52
0F74:  MOVWF  74
0F76:  MOVLW  20
0F78:  MOVWF  7D
0F7A:  RCALL  0DF0
0F7C:  MOVLW  20
0F7E:  MOVWF  7D
0F80:  RCALL  0DF0
0F82:  MOVFF  49,77
0F86:  MOVLW  01
0F88:  MOVWF  78
0F8A:  RCALL  0E0C
0F8C:  MOVLW  24
0F8E:  MOVWF  FF6
0F90:  MOVLW  05
0F92:  MOVWF  FF7
0F94:  MOVLW  03
0F96:  MOVWF  77
0F98:  RCALL  0EB6
0F9A:  MOVFF  48,77
0F9E:  MOVLW  01
0FA0:  MOVWF  78
0FA2:  RCALL  0E0C
0FA4:  MOVLW  2B
0FA6:  MOVWF  FF6
0FA8:  MOVLW  05
0FAA:  MOVWF  FF7
0FAC:  MOVLW  03
0FAE:  MOVWF  77
0FB0:  RCALL  0EB6
0FB2:  MOVFF  47,77
0FB6:  MOVLW  01
0FB8:  MOVWF  78
0FBA:  RCALL  0E0C
0FBC:  MOVLW  32
0FBE:  MOVWF  FF6
0FC0:  MOVLW  05
0FC2:  MOVWF  FF7
0FC4:  MOVLW  03
0FC6:  MOVWF  77
0FC8:  RCALL  0EB6
0FCA:  CLRF   FEA
0FCC:  MOVLW  4E
0FCE:  MOVWF  FE9
0FD0:  BRA    0ED4
0FD2:  MOVLW  37
0FD4:  MOVWF  FF6
0FD6:  MOVLW  05
0FD8:  MOVWF  FF7
0FDA:  MOVLW  03
0FDC:  MOVWF  77
0FDE:  RCALL  0EB6
0FE0:  MOVFF  4A,77
0FE4:  MOVLW  01
0FE6:  MOVWF  78
0FE8:  RCALL  0E0C
0FEA:  MOVLW  2F
0FEC:  MOVWF  7D
0FEE:  RCALL  0DF0
0FF0:  MOVFF  4B,77
0FF4:  MOVLW  01
0FF6:  MOVWF  78
0FF8:  RCALL  0E0C
0FFA:  MOVLW  2F
0FFC:  MOVWF  7D
0FFE:  RCALL  0DF0
1000:  MOVFF  4C,77
1004:  MOVLW  01
1006:  MOVWF  78
1008:  RCALL  0E0C
....................    memset(strLCD,0,32);                       
100A:  CLRF   FEA
100C:  MOVLW  1B
100E:  MOVWF  FE9
1010:  CLRF   00
1012:  CLRF   02
1014:  MOVLW  20
1016:  MOVWF  01
1018:  RCALL  0EFA
....................    memcpy(strLCD,DATE_TIME,32); 
101A:  CLRF   FEA
101C:  MOVLW  1B
101E:  MOVWF  FE9
1020:  CLRF   FE2
1022:  MOVLW  52
1024:  MOVWF  FE1
1026:  MOVLW  20
1028:  MOVWF  01
102A:  MOVFF  FE6,FEE
102E:  DECFSZ 01,F
1030:  BRA    102A
1032:  RETURN 0
.................... } 
....................    
.................... void getTime(){      
....................    ds1307_get_time();            
*
0B56:  BRA    0886
....................    ds1307_get_date();  
0B58:  BRA    0AEA
0B5A:  RETURN 0
.................... }      
.................... uchar_t exactDayOfMonthh(){  
....................    if(month==4 || month==6 || month==9 || month==11)  
....................       return 30;                            
....................    if(month==2){  
....................       if((yr%4) == 0){ 
....................          if((yr%400) == 0)  
....................             return 29;              
....................          else if((yr%100) == 0)  
....................             return 28; 
....................          return 29; 
....................       }  
....................       return 28; 
....................    }           
....................    return 31;  
.................... }              
.................... void getDayTextt(){                           
....................    switch(day_of_the_weekk(yr,month,day)){ 
*
0D2C:  CLRF   78
0D2E:  MOVFF  4C,77
0D32:  CLRF   7A
0D34:  MOVFF  4B,79
0D38:  CLRF   7C
0D3A:  MOVFF  4A,7B
0D3E:  BRA    0C08
0D40:  MOVFF  01,00
0D44:  MOVF   02,W
0D46:  MOVWF  03
0D48:  BNZ   0D4E
0D4A:  MOVF   00,F
0D4C:  BZ    0D8C
0D4E:  MOVF   03,W
0D50:  BNZ   0D58
0D52:  MOVLW  01
0D54:  SUBWF  00,W
0D56:  BZ    0D9A
0D58:  MOVF   03,W
0D5A:  BNZ   0D62
0D5C:  MOVLW  02
0D5E:  SUBWF  00,W
0D60:  BZ    0DA8
0D62:  MOVF   03,W
0D64:  BNZ   0D6C
0D66:  MOVLW  03
0D68:  SUBWF  00,W
0D6A:  BZ    0DB6
0D6C:  MOVF   03,W
0D6E:  BNZ   0D76
0D70:  MOVLW  04
0D72:  SUBWF  00,W
0D74:  BZ    0DC4
0D76:  MOVF   03,W
0D78:  BNZ   0D80
0D7A:  MOVLW  05
0D7C:  SUBWF  00,W
0D7E:  BZ    0DD2
0D80:  MOVF   03,W
0D82:  BNZ   0D8A
0D84:  MOVLW  06
0D86:  SUBWF  00,W
0D88:  BZ    0DE0
0D8A:  BRA    0DEC
....................      case 0: memcpy(dayText,"Sun",3); break; 
0D8C:  MOVLW  53
0D8E:  MOVWF  4E
0D90:  MOVLW  75
0D92:  MOVWF  4F
0D94:  MOVLW  6E
0D96:  MOVWF  50
0D98:  BRA    0DEC
....................      case 1: memcpy(dayText,"Mon",3); break; 
0D9A:  MOVLW  4D
0D9C:  MOVWF  4E
0D9E:  MOVLW  6F
0DA0:  MOVWF  4F
0DA2:  MOVLW  6E
0DA4:  MOVWF  50
0DA6:  BRA    0DEC
....................      case 2: memcpy(dayText,"Tue",3); break; 
0DA8:  MOVLW  54
0DAA:  MOVWF  4E
0DAC:  MOVLW  75
0DAE:  MOVWF  4F
0DB0:  MOVLW  65
0DB2:  MOVWF  50
0DB4:  BRA    0DEC
....................      case 3: memcpy(dayText,"Wed",3); break; 
0DB6:  MOVLW  57
0DB8:  MOVWF  4E
0DBA:  MOVLW  65
0DBC:  MOVWF  4F
0DBE:  MOVLW  64
0DC0:  MOVWF  50
0DC2:  BRA    0DEC
....................      case 4: memcpy(dayText,"Thu",3); break; 
0DC4:  MOVLW  54
0DC6:  MOVWF  4E
0DC8:  MOVLW  68
0DCA:  MOVWF  4F
0DCC:  MOVLW  75
0DCE:  MOVWF  50
0DD0:  BRA    0DEC
....................      case 5: memcpy(dayText,"Fri",3); break; 
0DD2:  MOVLW  46
0DD4:  MOVWF  4E
0DD6:  MOVLW  72
0DD8:  MOVWF  4F
0DDA:  MOVLW  69
0DDC:  MOVWF  50
0DDE:  BRA    0DEC
....................      case 6: memcpy(dayText,"Sat",3); break; 
0DE0:  MOVLW  53
0DE2:  MOVWF  4E
0DE4:  MOVLW  61
0DE6:  MOVWF  4F
0DE8:  MOVLW  74
0DEA:  MOVWF  50
....................    }    
0DEC:  GOTO   0F70 (RETURN)
.................... }  
.................... // <-------------      (0-7, Start Sunday)       ----------->  
.................... uint16_t day_of_the_weekk(uint16_t Y, uint16_t M, uint16_t D) {  
....................    uint16_t days[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };  
*
0C08:  CLRF   7D
0C0A:  CLRF   7E
0C0C:  MOVLW  03
0C0E:  MOVWF  7F
0C10:  CLRF   x80
0C12:  MOVLW  02
0C14:  MOVWF  x81
0C16:  CLRF   x82
0C18:  MOVLW  05
0C1A:  MOVWF  x83
0C1C:  CLRF   x84
0C1E:  CLRF   x85
0C20:  CLRF   x86
0C22:  MOVLW  03
0C24:  MOVWF  x87
0C26:  CLRF   x88
0C28:  MOVLW  05
0C2A:  MOVWF  x89
0C2C:  CLRF   x8A
0C2E:  MOVLW  01
0C30:  MOVWF  x8B
0C32:  CLRF   x8C
0C34:  MOVLW  04
0C36:  MOVWF  x8D
0C38:  CLRF   x8E
0C3A:  MOVLW  06
0C3C:  MOVWF  x8F
0C3E:  CLRF   x90
0C40:  MOVLW  02
0C42:  MOVWF  x91
0C44:  CLRF   x92
0C46:  MOVLW  04
0C48:  MOVWF  x93
0C4A:  CLRF   x94
....................    if (M < 3)  
0C4C:  MOVF   7A,F
0C4E:  BNZ   0C5E
0C50:  MOVF   79,W
0C52:  SUBLW  02
0C54:  BNC   0C5E
....................       Y--;         
0C56:  MOVF   77,W
0C58:  BTFSC  FD8.2
0C5A:  DECF   78,F
0C5C:  DECF   77,F
....................    return (Y + Y / 4 - Y / 100 + Y / 400 + days[M - 1] + D) % 7;  
0C5E:  RRCF   78,W
0C60:  MOVWF  03
0C62:  RRCF   77,W
0C64:  MOVWF  02
0C66:  RRCF   03,F
0C68:  RRCF   02,F
0C6A:  MOVLW  3F
0C6C:  ANDWF  03,F
0C6E:  MOVF   02,W
0C70:  ADDWF  77,W
0C72:  MOVWF  x95
0C74:  MOVF   03,W
0C76:  ADDWFC 78,W
0C78:  MOVWF  x96
0C7A:  CLRF   16
0C7C:  BTFSC  FF2.7
0C7E:  BSF    16.7
0C80:  BCF    FF2.7
0C82:  MOVFF  78,A0
0C86:  MOVFF  77,9F
0C8A:  CLRF   xA2
0C8C:  MOVLW  64
0C8E:  MOVWF  xA1
0C90:  RCALL  054A
0C92:  BTFSC  16.7
0C94:  BSF    FF2.7
0C96:  MOVFF  02,03
0C9A:  MOVF   01,W
0C9C:  SUBWF  x95,F
0C9E:  MOVF   02,W
0CA0:  SUBWFB x96,F
0CA2:  CLRF   16
0CA4:  BTFSC  FF2.7
0CA6:  BSF    16.7
0CA8:  BCF    FF2.7
0CAA:  MOVFF  78,A0
0CAE:  MOVFF  77,9F
0CB2:  MOVLW  01
0CB4:  MOVWF  xA2
0CB6:  MOVLW  90
0CB8:  MOVWF  xA1
0CBA:  RCALL  054A
0CBC:  BTFSC  16.7
0CBE:  BSF    FF2.7
0CC0:  MOVFF  02,03
0CC4:  MOVF   01,W
0CC6:  ADDWF  x95,F
0CC8:  MOVF   02,W
0CCA:  ADDWFC x96,F
0CCC:  MOVLW  01
0CCE:  SUBWF  79,W
0CD0:  MOVWF  x97
0CD2:  MOVLW  00
0CD4:  SUBWFB 7A,W
0CD6:  MOVWF  x98
0CD8:  BCF    FD8.0
0CDA:  RLCF   x97,W
0CDC:  MOVWF  02
0CDE:  RLCF   x98,W
0CE0:  MOVWF  03
0CE2:  MOVF   02,W
0CE4:  ADDLW  7D
0CE6:  MOVWF  FE9
0CE8:  MOVLW  00
0CEA:  ADDWFC 03,W
0CEC:  MOVWF  FEA
0CEE:  MOVFF  FEC,03
0CF2:  MOVF   FED,F
0CF4:  MOVF   FEF,W
0CF6:  ADDWF  x95,F
0CF8:  MOVF   03,W
0CFA:  ADDWFC x96,F
0CFC:  MOVF   7B,W
0CFE:  ADDWF  x95,F
0D00:  MOVF   7C,W
0D02:  ADDWFC x96,F
0D04:  CLRF   16
0D06:  BTFSC  FF2.7
0D08:  BSF    16.7
0D0A:  BCF    FF2.7
0D0C:  MOVFF  96,A0
0D10:  MOVFF  95,9F
0D14:  CLRF   xA2
0D16:  MOVLW  07
0D18:  MOVWF  xA1
0D1A:  RCALL  054A
0D1C:  BTFSC  16.7
0D1E:  BSF    FF2.7
0D20:  MOVFF  00,01
0D24:  MOVFF  03,02
0D28:  GOTO   0D40 (RETURN)
.................... }           
....................  
.................... #include "button.c"    
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "button.h" 
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED_1,BUTTON_PRESSED_RELEASED_2,BUTTON_PRESSED_RELEASED_3;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS_B1, STATUS_B2, STATUS_B3;  
.................... extern uint8_t bt_queue; 
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t);   
....................    
.................... #endif            
....................  
.................... #include "DS1307timeset.h"   
.................... #include "definitions.h"       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................                              
.................... #ifndef DS1307TIMESET_H 
.................... #define DS1307TIMESET_H   
....................  
.................... extern uint8_t position; 
.................... extern uint8_t executed; 
.................... //TIME CONTROL VIA BUTTON AND LCD 
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t SECOND     : 1;  //bit:0,   
....................       uint8_t MINUTE     : 1;  //bit:1,   
....................       uint8_t HOUR       : 1;  //bit:2,   
....................       uint8_t DAY        : 1;  //bit:3,      
....................       uint8_t MONTH      : 1;  //bit:4,                    
....................       uint8_t YEAR       : 1;  //bit:5,   
....................       uint8_t SET        : 2;  //bit:6-7,   
....................    }X;                     
.................... }date_t;    
.................... extern date_t DATE_STATUS;    
....................  
.................... void setTimeCases(); 
.................... void chooseElement(uchar_t);       
.................... void arrangeValueOfElement(uchar_t); 
....................  
.................... // INCREASE OR DECREASE 
.................... void increaseElement(uchar_t);  
.................... void decreaseElement(uchar_t); 
....................  
.................... //Send DATE ELEMENTS to RTC 
.................... void setRTC(uchar_t);    
.................... void txRTC(uchar_t, uchar_t);  
....................                                
.................... uchar_t exactDayOfMonth();           
....................  
....................  
....................  
.................... #endif //DS1307TIMESET_H 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... uint8_t BUTTON_PRESSED_RELEASED_1,BUTTON_PRESSED_RELEASED_2,BUTTON_PRESSED_RELEASED_3;    
.................... uint8_t STATUS_B1, STATUS_B2, STATUS_B3;  
.................... uint8_t bt_queue=0; 
....................            
.................... uint8_t test_bit(uint8_t valueOfInput, uint8_t bits){  
....................    return ((valueOfInput & (1<<bits)) != 0); 
*
1544:  MOVLW  01
1546:  MOVWF  00
1548:  MOVF   79,W
154A:  MOVWF  01
154C:  BZ    1556
154E:  BCF    FD8.0
1550:  RLCF   00,F
1552:  DECFSZ 01,F
1554:  BRA    154E
1556:  MOVF   00,W
1558:  ANDWF  78,W
155A:  BNZ   1560
155C:  MOVLW  00
155E:  BRA    1562
1560:  MOVLW  01
1562:  MOVWF  01
1564:  RETURN 0
.................... }                                          
....................   
.................... uint8_t button_debounce_1(uint8_t valueOfInput, uint8_t bit){ 
....................    if(!test_bit(valueOfInput,bit)){ 
*
1602:  MOVFF  76,78
1606:  MOVFF  77,79
160A:  RCALL  1544
160C:  MOVF   01,F
160E:  BNZ   1616
....................       BUTTON_PRESSED_RELEASED_1<<=1;           
1610:  BCF    FD8.0
1612:  RLCF   3D,F
....................    }else{                                
1614:  BRA    161C
....................       BUTTON_PRESSED_RELEASED_1<<=1;                        
1616:  BCF    FD8.0
1618:  RLCF   3D,F
....................       BUTTON_PRESSED_RELEASED_1|=1;           
161A:  BSF    3D.0
....................    }  
....................    if((BUTTON_PRESSED_RELEASED_1 & 0x1F)==0x1F){  
161C:  MOVF   3D,W
161E:  ANDLW  1F
1620:  SUBLW  1F
1622:  BNZ   165A
....................       if(executed){ 
1624:  MOVF   45,F
1626:  BZ    164E
....................          if(DATE_STATUS.X.SET==2){  
1628:  MOVFF  46,00
162C:  SWAPF  00,F
162E:  RRCF   00,F
1630:  RRCF   00,W
1632:  ANDLW  03
1634:  SUBLW  02
1636:  BNZ   1640
....................             increaseElement(position); 
1638:  MOVFF  44,78
163C:  BRA    1566
....................          }else{ 
163E:  BRA    164C
....................             if(position>=5) 
1640:  MOVF   44,W
1642:  SUBLW  04
1644:  BC    164A
....................                position=0; 
1646:  CLRF   44
1648:  BRA    164C
....................             else{position++;}  
164A:  INCF   44,F
....................          } 
....................          executed=0;  
164C:  CLRF   45
....................       } 
....................       STATUS_B1 = 1; 
164E:  MOVLW  01
1650:  MOVWF  40
....................       BUTTON_PRESSED_RELEASED_1=0; 
1652:  CLRF   3D
....................       return true;      
1654:  MOVWF  01
1656:  BRA    166E
....................    }else if((BUTTON_PRESSED_RELEASED_1  & 0x1F)==0x00){  
1658:  BRA    166E
165A:  MOVF   3D,W
165C:  ANDLW  1F
165E:  BNZ   166A
....................       STATUS_B1 = 0;                          
1660:  CLRF   40
....................       return false;        
1662:  MOVLW  00
1664:  MOVWF  01
1666:  BRA    166E
....................    }else{                            
1668:  BRA    166E
....................       return STATUS_B1;    
166A:  MOVFF  40,01
....................    } 
166E:  GOTO   01E8 (RETURN)
.................... } 
....................   
....................  
.................... uint8_t button_debounce_2(uint8_t valueOfInput, uint8_t bit){ 
....................  
....................    if(!test_bit(valueOfInput,bit)){         
*
170C:  MOVFF  76,78
1710:  MOVFF  77,79
1714:  RCALL  1544
1716:  MOVF   01,F
1718:  BNZ   1720
....................       BUTTON_PRESSED_RELEASED_2<<=1; 
171A:  BCF    FD8.0
171C:  RLCF   3E,F
....................    }else{                                
171E:  BRA    1726
....................       BUTTON_PRESSED_RELEASED_2<<=1;                        
1720:  BCF    FD8.0
1722:  RLCF   3E,F
....................       BUTTON_PRESSED_RELEASED_2|=1;           
1724:  BSF    3E.0
....................    }  
....................    if((BUTTON_PRESSED_RELEASED_2 & 0x1F)==0x1F){  
1726:  MOVF   3E,W
1728:  ANDLW  1F
172A:  SUBLW  1F
172C:  BNZ   1764
....................       if(executed) { 
172E:  MOVF   45,F
1730:  BZ    1758
....................          if(DATE_STATUS.X.SET==2){  
1732:  MOVFF  46,00
1736:  SWAPF  00,F
1738:  RRCF   00,F
173A:  RRCF   00,W
173C:  ANDLW  03
173E:  SUBLW  02
1740:  BNZ   174A
....................             decreaseElement(position); 
1742:  MOVFF  44,78
1746:  BRA    1672
....................          }else{ 
1748:  BRA    1756
....................             if(position<=0) 
174A:  MOVF   44,F
174C:  BNZ   1754
....................                position=5;       
174E:  MOVLW  05
1750:  MOVWF  44
1752:  BRA    1756
....................             else{position--;} 
1754:  DECF   44,F
....................          } 
....................          executed=0;  
1756:  CLRF   45
....................       }     
....................       STATUS_B2 = 1; 
1758:  MOVLW  01
175A:  MOVWF  41
....................       BUTTON_PRESSED_RELEASED_2=0; 
175C:  CLRF   3E
....................       return true; 
175E:  MOVWF  01
1760:  BRA    1778
....................    }else if((BUTTON_PRESSED_RELEASED_2  & 0x1F)==0x00){  
1762:  BRA    1778
1764:  MOVF   3E,W
1766:  ANDLW  1F
1768:  BNZ   1774
....................       STATUS_B2 = 0;  
176A:  CLRF   41
....................       return false;        
176C:  MOVLW  00
176E:  MOVWF  01
1770:  BRA    1778
....................    }else{                            
1772:  BRA    1778
....................       return STATUS_B2; 
1774:  MOVFF  41,01
....................    } 
1778:  GOTO   01FC (RETURN)
.................... }   
....................   
....................   
.................... uint8_t button_debounce_3(uint8_t valueOfInput, uint8_t bit){ 
....................    if(!test_bit(valueOfInput,bit)){ 
177C:  MOVFF  76,78
1780:  MOVFF  77,79
1784:  RCALL  1544
1786:  MOVF   01,F
1788:  BNZ   1790
....................       BUTTON_PRESSED_RELEASED_3<<=1;     
178A:  BCF    FD8.0
178C:  RLCF   3F,F
....................    }else{                                
178E:  BRA    1796
....................       BUTTON_PRESSED_RELEASED_3<<=1;                        
1790:  BCF    FD8.0
1792:  RLCF   3F,F
....................       BUTTON_PRESSED_RELEASED_3|=1;           
1794:  BSF    3F.0
....................    } 
....................    if((BUTTON_PRESSED_RELEASED_3 & 0x1F)==0x1F){   
1796:  MOVF   3F,W
1798:  ANDLW  1F
179A:  SUBLW  1F
179C:  BNZ   17D8
....................       if(executed){               
179E:  MOVF   45,F
17A0:  BZ    17CC
....................          if(DATE_STATUS.X.SET>=3) 
17A2:  MOVFF  46,00
17A6:  SWAPF  00,F
17A8:  RRCF   00,F
17AA:  RRCF   00,W
17AC:  ANDLW  03
17AE:  SUBLW  02
17B0:  BC    17BA
....................             DATE_STATUS.X.SET=0;                
17B2:  MOVLW  3F
17B4:  ANDWF  46,W
17B6:  MOVWF  46
17B8:  BRA    17CA
....................          else 
....................             DATE_STATUS.X.SET++;        
17BA:  MOVF   46,W
17BC:  ADDLW  40
17BE:  ANDLW  C0
17C0:  MOVWF  00
17C2:  MOVLW  3F
17C4:  ANDWF  46,W
17C6:  IORWF  00,W
17C8:  MOVWF  46
....................          executed=0;                                       
17CA:  CLRF   45
....................       }                             
....................       STATUS_B3 = 1;  
17CC:  MOVLW  01
17CE:  MOVWF  42
....................       BUTTON_PRESSED_RELEASED_3=0; 
17D0:  CLRF   3F
....................       return true;   
17D2:  MOVWF  01
17D4:  BRA    17EC
....................    }else if((BUTTON_PRESSED_RELEASED_3  & 0x1F)==0x00){  
17D6:  BRA    17EC
17D8:  MOVF   3F,W
17DA:  ANDLW  1F
17DC:  BNZ   17E8
....................       STATUS_B3 = 0;  
17DE:  CLRF   42
....................       return false;        
17E0:  MOVLW  00
17E2:  MOVWF  01
17E4:  BRA    17EC
....................    }else{                            
17E6:  BRA    17EC
....................       return STATUS_B3; 
17E8:  MOVFF  42,01
....................    } 
17EC:  GOTO   020C (RETURN)
.................... }     
....................  
....................  
....................                               
....................                                     
.................... //TIMER1 UNION STRUCTURE AND COUNT MS 
.................... tmr1_time_t tmr1_time;  
.................... uint16_t iSayac;     
....................                                           
....................                        
.................... void setupTimerIOSC(void){ 
....................    timeCounter=0; 
*
0612:  CLRF   17
....................    //Setup Osilator 
....................    IRCF2 = 1;                            
0614:  BSF    FD3.6
....................    IRCF1 = 1; 
0616:  BSF    FD3.5
....................    IRCF0 = 1;  
0618:  BSF    FD3.4
....................    ADCON1 = 0xFF;  
061A:  SETF   FC1
....................    CMCON  = 0x07; 
061C:  MOVLW  07
061E:  MOVWF  FB4
....................                          
....................    //D ve P portlari cikis olarak ayarlanip sifirlandi. 
....................    TRISB = 0x07; 
0620:  MOVWF  F93
....................    TRISD = 0x00; 
0622:  CLRF   F95
....................    TRISE = 0x00;                   
0624:  CLRF   F96
....................    PORTB = 0x00;                                                       
0626:  CLRF   F81
....................    PORTD = 0x00; 
0628:  CLRF   F8C
....................    PORTE = 0x00;          
062A:  CLRF   F84
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
062C:  CLRF   1A
....................  
....................    // Kesmelere izin verildi 
....................    RCON_IPEN = 1;                                               
062E:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 1; 
0630:  BSF    FF2.7
....................    INTCON_PEIE = 1;           
0632:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
0634:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
0636:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
0638:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit 
063A:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
063C:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
063E:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
0640:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
0642:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
0644:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
0646:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
0648:  MOVLW  F8
064A:  MOVWF  FCF
....................    TMR1L = 0x30; // |||65436 decimal sayisina esit. 
064C:  MOVLW  30
064E:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit                                            
0650:  BSF    FCD.0
0652:  GOTO   013A (RETURN)
.................... } 
....................                       
.................... void printOn2x16(){                   
....................    delayUsFun(40);                                                                                                                                       
*
06C0:  MOVLW  28
06C2:  MOVWF  x80
06C4:  RCALL  0656
....................    twoLinesBCDMode(); 
06C6:  BRA    00F6
....................    LinesActive();   
06C8:  BRA    0698
....................    lcdCursorOff(); 
06CA:  BRA    06A2
....................    lcdShiftRight();                      
06CC:  BRA    06AC
....................    lcdClear();                                                    
06CE:  BRA    06B6
....................    memcpy(strLCD, "INFORMELEKTRONIKAR-GE    STAJYER", 32); 
06D0:  CLRF   FEA
06D2:  MOVLW  1B
06D4:  MOVWF  FE9
06D6:  MOVFF  FF2,76
06DA:  BCF    FF2.7
06DC:  MOVLW  20
06DE:  MOVWF  01
06E0:  CLRF   FF7
06E2:  MOVLW  00
06E4:  RCALL  0096
06E6:  TBLRD*-
06E8:  TBLRD*+
06EA:  MOVFF  FF5,FEE
06EE:  DECFSZ 01,F
06F0:  BRA    06E8
06F2:  BTFSC  76.7
06F4:  BSF    FF2.7
....................    countLCDChar=0;  
06F6:  CLRF   3B
....................    LCDW1SecFlag=1; 
06F8:  MOVLW  01
06FA:  MOVWF  3C
06FC:  GOTO   013C (RETURN)
....................    // LCD_Custom_CHAR(7, legrandLCDCharacter); 
....................    //LCD_Custom_CHAR(6, stickManLCDCharacter);                                
.................... }                           
....................   
.................... #INT_TIMER1                                                            
.................... void timer1_interrupt(){  
....................    TMR1H = 0xF8; //Tasma saayci| 
*
058C:  MOVLW  F8
058E:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.  
0590:  MOVLW  30
0592:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor. 
0594:  BCF    F9E.0
....................    iSayac++;  
0596:  INCF   18,F
0598:  BTFSC  FD8.2
059A:  INCF   19,F
....................    if (iSayac % 2 == 0) //2ms  
059C:  MOVF   18,W
059E:  ANDLW  01
05A0:  MOVWF  x9F
05A2:  CLRF   xA0
05A4:  MOVF   x9F,F
05A6:  BNZ   05AE
05A8:  MOVF   xA0,F
05AA:  BNZ   05AE
....................       tmr1_time.tmr1_flags._2ms = true; 
05AC:  BSF    1A.0
....................    if (iSayac % 10 == 0) //20ms  
05AE:  MOVFF  19,A0
05B2:  MOVFF  18,9F
05B6:  CLRF   xA2
05B8:  MOVLW  0A
05BA:  MOVWF  xA1
05BC:  RCALL  054A
05BE:  MOVFF  00,9F
05C2:  MOVFF  03,A0
05C6:  MOVF   x9F,F
05C8:  BNZ   05D0
05CA:  MOVF   xA0,F
05CC:  BNZ   05D0
....................       tmr1_time.tmr1_flags._10ms = true;     
05CE:  BSF    1A.1
....................    if (iSayac % 500 == 0) //200ms  
05D0:  MOVFF  19,A0
05D4:  MOVFF  18,9F
05D8:  MOVLW  01
05DA:  MOVWF  xA2
05DC:  MOVLW  F4
05DE:  MOVWF  xA1
05E0:  RCALL  054A
05E2:  MOVFF  00,9F
05E6:  MOVFF  03,A0
05EA:  MOVF   x9F,F
05EC:  BNZ   05F4
05EE:  MOVF   xA0,F
05F0:  BNZ   05F4
....................       tmr1_time.tmr1_flags._500ms = true; 
05F2:  BSF    1A.6
....................    if(iSayac > 1000){   // 1 Saniye   
05F4:  MOVF   19,W
05F6:  SUBLW  02
05F8:  BC    060C
05FA:  XORLW  FF
05FC:  BNZ   0604
05FE:  MOVF   18,W
0600:  SUBLW  E8
0602:  BC    060C
....................       tmr1_time.tmr1_flags._1000ms = true;  
0604:  BSF    1A.7
....................       iSayac = 0;  
0606:  CLRF   19
0608:  CLRF   18
....................       timeCounter++; 
060A:  INCF   17,F
....................    }      
.................... }                              
....................                                    
060C:  BCF    F9E.0
060E:  GOTO   0054
.................... #ORG 0x0100,0x0400                                                                     
.................... void main(){                                                         
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  MOVLW  70
0108:  MOVWF  FD3
010A:  MOVF   FD3,W
010C:  BCF    FB8.3
010E:  MOVLW  0C
0110:  MOVWF  FAF
0112:  MOVLW  A2
0114:  MOVWF  FAC
0116:  MOVLW  90
0118:  MOVWF  FAB
011A:  NOP   
011C:  NOP   
011E:  MOVLW  78
0120:  MOVWF  17
0122:  CLRF   75
0124:  CLRF   74
0126:  CLRF   43
0128:  MOVF   FC1,W
012A:  ANDLW  C0
012C:  IORLW  0F
012E:  MOVWF  FC1
0130:  MOVLW  07
0132:  MOVWF  FB4
0134:  CLRF   72
0136:  CLRF   73
....................    setupTimerIOSC();                                                      
0138:  BRA    0612
....................    printOn2x16();              
013A:  BRA    06C0
....................    DS1307_Init();                                                                                       
013C:  BRA    076A
....................    ds1307_set_date_time(31,12,22,6,23,59,55); 
013E:  MOVLW  1F
0140:  MOVWF  76
0142:  MOVLW  0C
0144:  MOVWF  77
0146:  MOVLW  16
0148:  MOVWF  78
014A:  MOVLW  06
014C:  MOVWF  79
014E:  MOVLW  17
0150:  MOVWF  7A
0152:  MOVLW  3B
0154:  MOVWF  7B
0156:  MOVLW  37
0158:  MOVWF  7C
015A:  BRA    07A2
....................    getTime();  
015C:  CALL   0B56
....................    runTime(); 
0160:  CALL   0F14
....................    while (TRUE){                   
....................      WDTreset();                                        
0164:  GOTO   1034
....................      if(tmr1_time.tmr1_flags._1000ms){                       
0168:  BTFSS  1A.7
016A:  BRA    0186
....................         tmr1_time.tmr1_flags._1000ms = false;                 
016C:  BCF    1A.7
....................         PORTB_7=~PORTB_7;        
016E:  BTG    F81.7
....................         if(DATE_STATUS.X.SET==0){ 
0170:  MOVFF  46,00
0174:  SWAPF  00,F
0176:  RRCF   00,F
0178:  RRCF   00,W
017A:  ANDLW  03
017C:  BNZ   0186
....................            LCDW1SecFlag=1;  
017E:  MOVLW  01
0180:  MOVWF  3C
....................            runTime();                                            
0182:  CALL   0F14
....................         }    
....................         //printf("\f\%02d:\%02d:\%02d\r\n", getHour(), getMin(),getSec());  
....................         //printf("\%02d/\%02d/\%02d -->%s",day, getMonth(), getYear(), dayText);    
....................      }  
....................      if(timeCounter>=120){  
0186:  MOVF   17,W
0188:  SUBLW  77
018A:  BC    0192
....................         getTime();  
018C:  CALL   0B56
....................         timeCounter=0;        
0190:  CLRF   17
....................      } 
....................      if(tmr1_time.tmr1_flags._500ms){             
0192:  BTFSS  1A.6
0194:  BRA    01D4
....................         tmr1_time.tmr1_flags._500ms = false;   
0196:  BCF    1A.6
....................         executed=1; 
0198:  MOVLW  01
019A:  MOVWF  45
....................         if(DATE_STATUS.X.SET==1||DATE_STATUS.X.SET==2||DATE_STATUS.X.SET==3){ 
019C:  MOVFF  46,00
01A0:  SWAPF  00,F
01A2:  RRCF   00,F
01A4:  RRCF   00,W
01A6:  ANDLW  03
01A8:  SUBLW  01
01AA:  BZ    01CC
01AC:  MOVFF  46,00
01B0:  SWAPF  00,F
01B2:  RRCF   00,F
01B4:  RRCF   00,W
01B6:  ANDLW  03
01B8:  SUBLW  02
01BA:  BZ    01CC
01BC:  MOVFF  46,00
01C0:  SWAPF  00,F
01C2:  RRCF   00,F
01C4:  RRCF   00,W
01C6:  ANDLW  03
01C8:  SUBLW  03
01CA:  BNZ   01D4
....................            setTimeCases(); 
01CC:  GOTO   14FE
....................            LCDW1SecFlag=1;      
01D0:  MOVLW  01
01D2:  MOVWF  3C
....................            //printf("\fposition %d\r",position); 
....................            //printf("DATE_STATUS.X.SET: %d\r",DATE_STATUS.X.SET); 
....................         }  
....................      }                               
....................      if(tmr1_time.tmr1_flags._10ms){ 
01D4:  BTFSS  1A.1
01D6:  BRA    020E
....................         tmr1_time.tmr1_flags._10ms = false; 
01D8:  BCF    1A.1
....................         if(bt_queue==0){button_debounce_1(PORTB,0); bt_queue++;} 
01DA:  MOVF   43,F
01DC:  BNZ   01EC
01DE:  MOVFF  F81,76
01E2:  CLRF   77
01E4:  GOTO   1602
01E8:  INCF   43,F
01EA:  BRA    020E
....................         else if(bt_queue==1){button_debounce_2(PORTB,1); bt_queue++;}  
01EC:  DECFSZ 43,W
01EE:  BRA    0200
01F0:  MOVFF  F81,76
01F4:  MOVLW  01
01F6:  MOVWF  77
01F8:  GOTO   170C
01FC:  INCF   43,F
01FE:  BRA    020E
....................         else{button_debounce_3(PORTB,2); bt_queue=0;} 
0200:  MOVFF  F81,76
0204:  MOVLW  02
0206:  MOVWF  77
0208:  GOTO   177C
020C:  CLRF   43
....................      }  
....................      if(tmr1_time.tmr1_flags._2ms){ 
020E:  BTFSS  1A.0
0210:  BRA    021C
....................         tmr1_time.tmr1_flags._2ms = false;    
0212:  BCF    1A.0
....................         if(LCDW1SecFlag){      
0214:  MOVF   3C,F
0216:  BZ    021C
....................            LCD_String();                                     
0218:  GOTO   1840
....................         } 
....................      }                    
021C:  BRA    0164
....................   }   
.................... }  
....................  
021E:  SLEEP 
.................... void WDTreset(void){          
....................    #asm                   
*
1034:  CLRWDT
....................    CLRWDT                           
....................    #endasm                                  
1036:  GOTO   0168 (RETURN)
.................... }                   
....................                                         

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 061E   PUT BROWNOUT BORV21 NOWDT WDT8
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
