CCS PCH C Compiler, Version 5.015, 5967               28-Jul-23 17:15

               Filename:   C:\18F4520\CCS\1-Wire-2-ROM-D18B20-LCD\main.lst

               ROM used:   3564 bytes (11%)
                           Largest free fragment is 28542
               RAM used:   146 (10%) at main() level
                           164 (11%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   0574
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir. 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0096:  CLRF   01
0098:  CLRF   02
009A:  CLRF   00
009C:  CLRF   03
009E:  MOVF   xA2,W
00A0:  BNZ   00A6
00A2:  MOVF   xA1,W
00A4:  BZ    00D6
00A6:  MOVLW  10
00A8:  MOVWF  xA3
00AA:  BCF    FD8.0
00AC:  RLCF   x9F,F
00AE:  RLCF   xA0,F
00B0:  RLCF   00,F
00B2:  RLCF   03,F
00B4:  MOVF   xA2,W
00B6:  SUBWF  03,W
00B8:  BNZ   00BE
00BA:  MOVF   xA1,W
00BC:  SUBWF  00,W
00BE:  BNC   00CE
00C0:  MOVF   xA1,W
00C2:  SUBWF  00,F
00C4:  BTFSS  FD8.0
00C6:  DECF   03,F
00C8:  MOVF   xA2,W
00CA:  SUBWF  03,F
00CC:  BSF    FD8.0
00CE:  RLCF   01,F
00D0:  RLCF   02,F
00D2:  DECFSZ xA3,F
00D4:  BRA    00AA
00D6:  GOTO   05A6 (RETURN)
*
0402:  MOVFF  FF2,0D
0406:  BCF    FF2.7
0408:  CLRF   FF7
040A:  ADDLW  1C
040C:  MOVWF  FF6
040E:  MOVLW  04
0410:  ADDWFC FF7,F
0412:  TBLRD*+
0414:  MOVF   FF5,W
0416:  BTFSC  0D.7
0418:  BSF    FF2.7
041A:  RETURN 0
041C:  DATA 00,5E
041E:  DATA BC,E2
0420:  DATA 61,3F
0422:  DATA DD,83
0424:  DATA C2,9C
0426:  DATA 7E,20
0428:  DATA A3,FD
042A:  DATA 1F,41
042C:  DATA 9D,C3
042E:  DATA 21,7F
0430:  DATA FC,A2
0432:  DATA 40,1E
0434:  DATA 5F,01
0436:  DATA E3,BD
0438:  DATA 3E,60
043A:  DATA 82,DC
043C:  DATA 23,7D
043E:  DATA 9F,C1
0440:  DATA 42,1C
0442:  DATA FE,A0
0444:  DATA E1,BF
0446:  DATA 5D,03
0448:  DATA 80,DE
044A:  DATA 3C,62
044C:  DATA BE,E0
044E:  DATA 02,5C
0450:  DATA DF,81
0452:  DATA 63,3D
0454:  DATA 7C,22
0456:  DATA C0,9E
0458:  DATA 1D,43
045A:  DATA A1,FF
045C:  DATA 46,18
045E:  DATA FA,A4
0460:  DATA 27,79
0462:  DATA 9B,C5
0464:  DATA 84,DA
0466:  DATA 38,66
0468:  DATA E5,BB
046A:  DATA 59,07
046C:  DATA DB,85
046E:  DATA 67,39
0470:  DATA BA,E4
0472:  DATA 06,58
0474:  DATA 19,47
0476:  DATA A5,FB
0478:  DATA 78,26
047A:  DATA C4,9A
047C:  DATA 65,3B
047E:  DATA D9,87
0480:  DATA 04,5A
0482:  DATA B8,E6
0484:  DATA A7,F9
0486:  DATA 1B,45
0488:  DATA C6,98
048A:  DATA 7A,24
048C:  DATA F8,A6
048E:  DATA 44,1A
0490:  DATA 99,C7
0492:  DATA 25,7B
0494:  DATA 3A,64
0496:  DATA 86,D8
0498:  DATA 5B,05
049A:  DATA E7,B9
049C:  DATA 8C,D2
049E:  DATA 30,6E
04A0:  DATA ED,B3
04A2:  DATA 51,0F
04A4:  DATA 4E,10
04A6:  DATA F2,AC
04A8:  DATA 2F,71
04AA:  DATA 93,CD
04AC:  DATA 11,4F
04AE:  DATA AD,F3
04B0:  DATA 70,2E
04B2:  DATA CC,92
04B4:  DATA D3,8D
04B6:  DATA 6F,31
04B8:  DATA B2,EC
04BA:  DATA 0E,50
04BC:  DATA AF,F1
04BE:  DATA 13,4D
04C0:  DATA CE,90
04C2:  DATA 72,2C
04C4:  DATA 6D,33
04C6:  DATA D1,8F
04C8:  DATA 0C,52
04CA:  DATA B0,EE
04CC:  DATA 32,6C
04CE:  DATA 8E,D0
04D0:  DATA 53,0D
04D2:  DATA EF,B1
04D4:  DATA F0,AE
04D6:  DATA 4C,12
04D8:  DATA 91,CF
04DA:  DATA 2D,73
04DC:  DATA CA,94
04DE:  DATA 76,28
04E0:  DATA AB,F5
04E2:  DATA 17,49
04E4:  DATA 08,56
04E6:  DATA B4,EA
04E8:  DATA 69,37
04EA:  DATA D5,8B
04EC:  DATA 57,09
04EE:  DATA EB,B5
04F0:  DATA 36,68
04F2:  DATA 8A,D4
04F4:  DATA 95,CB
04F6:  DATA 29,77
04F8:  DATA F4,AA
04FA:  DATA 48,16
04FC:  DATA E9,B7
04FE:  DATA 55,0B
0500:  DATA 88,D6
0502:  DATA 34,6A
0504:  DATA 2B,75
0506:  DATA 97,C9
0508:  DATA 4A,14
050A:  DATA F6,A8
050C:  DATA 74,2A
050E:  DATA C8,96
0510:  DATA 15,4B
0512:  DATA A9,F7
0514:  DATA B6,E8
0516:  DATA 0A,54
0518:  DATA D7,89
051A:  DATA 6B,35
051C:  MOVFF  FF2,0D
0520:  BCF    FF2.7
0522:  CLRF   FF7
0524:  ADDLW  36
0526:  MOVWF  FF6
0528:  MOVLW  05
052A:  ADDWFC FF7,F
052C:  TBLRD*+
052E:  MOVF   FF5,W
0530:  BTFSC  0D.7
0532:  BSF    FF2.7
0534:  RETURN 0
0536:  DATA 49,4E
0538:  DATA 46,4F
053A:  DATA 52,4D
053C:  DATA 45,4C
053E:  DATA 45,4B
0540:  DATA 54,52
0542:  DATA 4F,4E
0544:  DATA 49,4B
0546:  DATA 41,52
0548:  DATA 2D,47
054A:  DATA 45,20
054C:  DATA 20,20
054E:  DATA 20,53
0550:  DATA 54,41
0552:  DATA 4A,59
0554:  DATA 45,52
0556:  DATA 00,00
0558:  DATA 4E,6F
055A:  DATA 20,64
055C:  DATA 65,76
055E:  DATA 69,63
0560:  DATA 65,73
0562:  DATA 20,66
0564:  DATA 6F,75
0566:  DATA 6E,64
0568:  DATA 0D,00
056A:  DATA 54,45
056C:  DATA 4D,50
056E:  DATA 20,3A
0570:  DATA 25,4C
0572:  DATA 64,00
*
05D4:  DATA 54,31
05D6:  DATA 20,3A
05D8:  DATA 25,4C
05DA:  DATA 64,20
05DC:  DATA 20,54
05DE:  DATA 32,3A
05E0:  DATA 20,25
05E2:  DATA 4C,64
05E4:  DATA 20,20
05E6:  DATA 20,20
05E8:  DATA 54,33
05EA:  DATA 3A,20
05EC:  DATA 25,4C
05EE:  DATA 64,20
05F0:  DATA 20,20
05F2:  DATA 20,20
05F4:  DATA 00,00
05F6:  DATA 54,31
05F8:  DATA 20,3A
05FA:  DATA 25,4C
05FC:  DATA 64,20
05FE:  DATA 20,54
0600:  DATA 32,3A
0602:  DATA 20,25
0604:  DATA 4C,64
0606:  DATA 20,20
0608:  DATA 20,20
060A:  DATA 54,33
060C:  DATA 3A,20
060E:  DATA 25,4C
0610:  DATA 64,20
0612:  DATA 20,20
0614:  DATA 20,20
0616:  DATA 00,00
0618:  DATA 54,31
061A:  DATA 20,3A
061C:  DATA 25,4C
061E:  DATA 64,20
0620:  DATA 20,54
0622:  DATA 32,3A
0624:  DATA 20,25
0626:  DATA 4C,64
0628:  DATA 20,20
062A:  DATA 20,20
062C:  DATA 54,33
062E:  DATA 3A,20
0630:  DATA 25,4C
0632:  DATA 64,20
0634:  DATA 20,20
0636:  DATA 20,20
0638:  DATA 00,00
*
095A:  TSTFSZ 01
095C:  BRA    0964
095E:  TSTFSZ 02
0960:  BRA    0966
0962:  BRA    0972
0964:  INCF   02,F
0966:  MOVFF  00,FEE
096A:  DECFSZ 01,F
096C:  BRA    0966
096E:  DECFSZ 02,F
0970:  BRA    0966
0972:  RETURN 0
*
097A:  TBLRD*+
097C:  MOVF   FF5,F
097E:  BZ    099A
0980:  MOVFF  FF6,92
0984:  MOVFF  FF7,93
0988:  MOVF   FF5,W
098A:  BTFSS  F9E.4
098C:  BRA    098A
098E:  MOVWF  FAD
0990:  MOVFF  92,FF6
0994:  MOVFF  93,FF7
0998:  BRA    097A
099A:  GOTO   0B04 (RETURN)
*
0C00:  MOVF   x9A,W
0C02:  XORWF  x9C,W
0C04:  ANDLW  80
0C06:  MOVWF  x9E
0C08:  BTFSS  x9A.7
0C0A:  BRA    0C16
0C0C:  COMF   x99,F
0C0E:  COMF   x9A,F
0C10:  INCF   x99,F
0C12:  BTFSC  FD8.2
0C14:  INCF   x9A,F
0C16:  BTFSS  x9C.7
0C18:  BRA    0C24
0C1A:  COMF   x9B,F
0C1C:  COMF   x9C,F
0C1E:  INCF   x9B,F
0C20:  BTFSC  FD8.2
0C22:  INCF   x9C,F
0C24:  CLRF   01
0C26:  CLRF   02
0C28:  CLRF   00
0C2A:  CLRF   03
0C2C:  MOVF   x9C,W
0C2E:  BNZ   0C34
0C30:  MOVF   x9B,W
0C32:  BZ    0C64
0C34:  MOVLW  10
0C36:  MOVWF  x9D
0C38:  BCF    FD8.0
0C3A:  RLCF   x99,F
0C3C:  RLCF   x9A,F
0C3E:  RLCF   00,F
0C40:  RLCF   03,F
0C42:  MOVF   x9C,W
0C44:  SUBWF  03,W
0C46:  BNZ   0C4C
0C48:  MOVF   x9B,W
0C4A:  SUBWF  00,W
0C4C:  BNC   0C5C
0C4E:  MOVF   x9B,W
0C50:  SUBWF  00,F
0C52:  BTFSS  FD8.0
0C54:  DECF   03,F
0C56:  MOVF   x9C,W
0C58:  SUBWF  03,F
0C5A:  BSF    FD8.0
0C5C:  RLCF   01,F
0C5E:  RLCF   02,F
0C60:  DECFSZ x9D,F
0C62:  BRA    0C38
0C64:  BTFSS  x9E.7
0C66:  BRA    0C72
0C68:  COMF   01,F
0C6A:  COMF   02,F
0C6C:  INCF   01,F
0C6E:  BTFSC  FD8.2
0C70:  INCF   02,F
0C72:  GOTO   0D22 (RETURN)
*
0D34:  MOVFF  90,FEA
0D38:  MOVFF  8F,FE9
0D3C:  MOVFF  9B,FEF
0D40:  INCF   FE9,F
0D42:  BTFSC  FD8.2
0D44:  INCF   FEA,F
0D46:  CLRF   FEF
0D48:  INCF   x8F,F
0D4A:  BTFSC  FD8.2
0D4C:  INCF   x90,F
0D4E:  RETURN 0
0D50:  TBLRD*+
0D52:  MOVFF  FF6,93
0D56:  MOVFF  FF7,94
0D5A:  MOVFF  FF5,9B
0D5E:  RCALL  0D34
0D60:  MOVFF  93,FF6
0D64:  MOVFF  94,FF7
0D68:  DECFSZ x92,F
0D6A:  BRA    0D50
0D6C:  RETURN 0
0D6E:  MOVFF  FEA,9A
0D72:  MOVFF  FE9,99
0D76:  BTFSS  x93.7
0D78:  BRA    0D8A
0D7A:  BSF    x99.7
0D7C:  BTFSS  x99.4
0D7E:  INCF   x99,F
0D80:  COMF   x92,F
0D82:  COMF   x93,F
0D84:  INCF   x92,F
0D86:  BTFSC  FD8.2
0D88:  INCF   x93,F
0D8A:  SWAPF  x93,W
0D8C:  IORLW  F0
0D8E:  MOVWF  x95
0D90:  ADDWF  x95,F
0D92:  ADDLW  E2
0D94:  MOVWF  x96
0D96:  ADDLW  32
0D98:  MOVWF  x98
0D9A:  MOVF   x93,W
0D9C:  ANDLW  0F
0D9E:  ADDWF  x96,F
0DA0:  ADDWF  x96,F
0DA2:  ADDWF  x98,F
0DA4:  ADDLW  E9
0DA6:  MOVWF  x97
0DA8:  ADDWF  x97,F
0DAA:  ADDWF  x97,F
0DAC:  SWAPF  x92,W
0DAE:  ANDLW  0F
0DB0:  ADDWF  x97,F
0DB2:  ADDWF  x98,F
0DB4:  RLCF   x97,F
0DB6:  RLCF   x98,F
0DB8:  COMF   x98,F
0DBA:  RLCF   x98,F
0DBC:  MOVF   x92,W
0DBE:  ANDLW  0F
0DC0:  ADDWF  x98,F
0DC2:  RLCF   x95,F
0DC4:  MOVLW  07
0DC6:  MOVWF  x94
0DC8:  MOVLW  0A
0DCA:  DECF   x97,F
0DCC:  ADDWF  x98,F
0DCE:  BNC   0DCA
0DD0:  DECF   x96,F
0DD2:  ADDWF  x97,F
0DD4:  BNC   0DD0
0DD6:  DECF   x95,F
0DD8:  ADDWF  x96,F
0DDA:  BNC   0DD6
0DDC:  DECF   x94,F
0DDE:  ADDWF  x95,F
0DE0:  BNC   0DDC
0DE2:  CLRF   FEA
0DE4:  MOVLW  94
0DE6:  MOVWF  FE9
0DE8:  MOVLW  07
0DEA:  ANDWF  x99,W
0DEC:  BCF    x99.6
0DEE:  MOVF   FED,F
0DF0:  ANDWF  x99,W
0DF2:  BNZ   0E02
0DF4:  BTFSC  x99.4
0DF6:  MOVF   FEE,F
0DF8:  BTFSC  x99.4
0DFA:  BRA    0E02
0DFC:  MOVLW  20
0DFE:  MOVWF  00
0E00:  BRA    0E42
0E02:  ADDWF  FE9,F
0E04:  MOVLW  00
0E06:  ADDWFC FEA,F
0E08:  MOVF   FE9,W
0E0A:  SUBLW  98
0E0C:  BNZ   0E14
0E0E:  MOVF   FEA,F
0E10:  BNZ   0E14
0E12:  BSF    x99.6
0E14:  MOVF   FEF,W
0E16:  MOVWF  00
0E18:  BNZ   0E2A
0E1A:  BTFSC  x99.6
0E1C:  BRA    0E2A
0E1E:  BTFSC  x99.4
0E20:  BRA    0E58
0E22:  BTFSC  x99.3
0E24:  BRA    0E2A
0E26:  MOVLW  20
0E28:  BRA    0E40
0E2A:  BTFSS  x99.7
0E2C:  BRA    0E3A
0E2E:  MOVLW  2D
0E30:  MOVWF  00
0E32:  MOVF   FED,W
0E34:  BCF    x99.6
0E36:  BCF    x99.7
0E38:  BRA    0E42
0E3A:  BSF    x99.3
0E3C:  BCF    x99.4
0E3E:  MOVLW  30
0E40:  ADDWF  00,F
0E42:  MOVFF  FEA,93
0E46:  MOVFF  FE9,92
0E4A:  MOVFF  00,9B
0E4E:  RCALL  0D34
0E50:  MOVFF  93,FEA
0E54:  MOVFF  92,FE9
0E58:  MOVF   FEE,W
0E5A:  BTFSS  x99.6
0E5C:  BRA    0E08
0E5E:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanýr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       Â· LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       Â· WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini saðlar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       Â· PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin içine yükleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       Â· PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       Â· BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       Â· INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       Â· NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */                                
....................                                                          
.................... #FUSES NOWDT, WDT8, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC  
.................... #use delay (internal=8MHz)                     
*
070A:  MOVLW  09
070C:  SUBWF  x9C,F
070E:  BNC   0726
0710:  CLRF   FEA
0712:  MOVLW  9C
0714:  MOVWF  FE9
0716:  BCF    FD8.0
0718:  RRCF   FEF,F
071A:  MOVF   FEF,W
071C:  BZ    0726
071E:  BRA    0722
0720:  NOP   
0722:  DECFSZ FEF,F
0724:  BRA    0720
0726:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7) 
.................... //#use i2c(Master, Fast=100000, sda=PIN_C4, scl=PIN_C3, SMBUS)             
....................                                             
.................... #include "definitions.h"                                                                                                       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "main.h"                                                
.................... #ifndef MAIN_H      
.................... #define MAIN_H  
.................... #define DELAY 500  
....................  
.................... void multid18b20cal(); 
.................... void WDTreset(void);   
....................                      
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"                                     
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................  
.................... //   ################   D18B20  #################  //                            
.................... #byte LATC    = 0x0F8B   
.................... #bit  LATC_0  = LATC.0   
.................... #bit  TRISC_0 = TRISC.0   
.................... #bit  PORTC_0 = PORTC.0   
....................  
....................                                                                                                      
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h"                                                                                          
.................... #ifndef INITS_H 
.................... #define INITS_H       
....................  
.................... extern uint16_t iSayac;  
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _2ms    : 1;  //bit:0, 2ms  
....................       uint8_t _20ms   : 1;  //bit:1, 20ms  
....................       uint8_t _50ms   : 1;  //bit:2, 50ms  
....................       uint8_t _100ms  : 1;  //bit:3, 100ms     
....................       uint8_t _200ms  : 1;  //bit:4, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:5, 500ms  
....................       uint8_t _1000ms : 1;  //bit:6, 1000ms  
....................       uint8_t _500us  : 1;  //bit:7, 500us 
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t tmr1_time;     
....................  
....................  
....................  
....................  
....................                                                 
.................... #endif //INIT_H                               
....................  
.................... #include "lcd.h"  
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ds1820.h"  
.................... #ifndef DS1820_H 
.................... #define DS1820_H  
.................... /*#define Input           1 
.................... #define Output          0 
.................... #define ReadROM         0x33 
.................... #define MatchROM        0x55 
.................... #define SkipROM         0xCC 
.................... #define SearchROM       0xF0 
.................... #define AlarmSearch     0xEC 
.................... #define ConvertT        0x44 
.................... #define ReadScratchpad  0xBE 
.................... #define WriteScratchpad 0x4E 
.................... #define CopyScratchpad  0x48 
.................... #define RecallEE        0xB8                                  
.................... #define ReadPowerSupply 0xB4 
.................... #define DevicesNumber   1 */      
....................  
....................                                         
.................... extern uchar_t DevicesFound; // Number of devices found  
.................... extern uchar_t queue;   
.................... void searchRom();  
....................  
....................                  
.................... void ds1820_read();  
.................... void ds1820_read_from_rom(uchar_t *); 
.................... void ds1820_configure(uchar_t TH, uchar_t TL, uchar_t config);   
.................... extern uchar_t TEMPBF[32];   
.................... extern sint16_t tempHeat;   
.................... extern sint16_t heat1,heat2,heat3;    
....................  
....................                                         
....................                                         
....................   
....................  
....................  
.................... #endif //DS1820_H 
....................                      
....................  
....................                                                              
.................... #include "lcd.c"                                  
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................  
.................... //   ################   D18B20  #################  //                            
.................... #byte LATC    = 0x0F8B   
.................... #bit  LATC_0  = LATC.0   
.................... #bit  TRISC_0 = TRISC.0   
.................... #bit  PORTC_0 = PORTC.0   
....................  
....................                                                                                                      
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "delayms.h"  
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................                  
....................                
.................... /*Hex Code   LCD Ekran Karsiligi  
....................  Initialize Lcd in 4-bit mode               0x02 
.................... 1   Function Set: 8-bit, 1 Line, 5×7 Dots   0x30   48                                              
.................... 2   Function Set: 8-bit, 2 Line, 5×7 Dots   0x38   56                            
.................... 3   Function Set: 4-bit, 1 Line, 5×7 Dots   0x20   32 
.................... 4   Function Set: 4-bit, 2 Line, 5×7 Dots   0x28   40  
.................... 0F   LCD acik, Imlec acik 
.................... 01   Ekrani Temizle                                 
.................... 02   Satir Basina Dön            
.................... 04   Imleci Sola Kaydir 
.................... 06   Imleci Saga Kaydir 
.................... 05   Ekrani Saga Kaydir 
.................... 07   Ekrani Sola Kaydir 
.................... 0E   Ekran Acik, Imleç Yanip Sonuyor 
.................... 80   Imleci Ilk Satirin Basinda Konumlandir 
.................... C0   Imleci Ikinci Satirin Basinda Konumlandir         
.................... 3C   Ikinci Satiri Etkinlestir                                                     
.................... 08   Ekran Kapali, Imleç Kapali              
.................... OC   Ekran Acik, Imlec Kapali*/   
....................                                             
.................... uchar_t strLCD[32]; 
.................... uint8_t countLCDChar; 
.................... uchar_t LCDW1SecFlag; 
....................                                          
.................... /*LCD (CHIP: HD44780), COMMAND MODE*/  
.................... void dis_cmd(uchar_t cmdout){  
....................    PORTD=cmdout;      //Send command to lcdport=PORTB 
*
00E8:  MOVFF  94,F8C
....................    PORTE_RS=0;                   
00EC:  BCF    F84.0
....................    PORTE_E=1;                
00EE:  BSF    F84.1
....................    delayUsFun(1); 
00F0:  MOVLW  01
00F2:  MOVWF  x96
00F4:  RCALL  00DA
....................    PORTE_E=0;                               
00F6:  BCF    F84.1
00F8:  RETURN 0
.................... }                                   
....................  
....................  
....................  
.................... void lcdcmd(uchar_t cmd_value){          
....................    uchar_t cmd_value1;                              
....................    cmd_value1 = (cmd_value & 0xF0);      // Mask lower nibble because RB4-RB7 pins are being used    
*
0676:  MOVF   x92,W
0678:  ANDLW  F0
067A:  MOVWF  x93
....................    dis_cmd(cmd_value1);                   // Send to LCD 
067C:  MOVFF  93,94
0680:  RCALL  00E8
....................    cmd_value1 = ((cmd_value<<4) & 0xF0);  // Shift 4-bit and mask 
0682:  SWAPF  x92,W
0684:  MOVWF  00
0686:  MOVLW  F0
0688:  ANDWF  00,F
068A:  MOVF   00,W
068C:  ANDLW  F0
068E:  MOVWF  x93
....................    dis_cmd(cmd_value1);                   // Send to LCD 
0690:  MOVFF  93,94
0694:  RCALL  00E8
0696:  RETURN 0
.................... } 
....................  // 2 lines are active.              
.................... void twoLinesBCDMode(){  
....................    lcdcmd(0x02); 
0698:  MOVLW  02
069A:  MOVWF  x92
069C:  RCALL  0676
069E:  GOTO   06D2 (RETURN)
.................... } 
....................                         
.................... // 2 lines are active. BCD MODE 
.................... void LinesActive(){  
....................    lcdcmd(0x28);                
06A2:  MOVLW  28
06A4:  MOVWF  x92
06A6:  RCALL  0676
06A8:  GOTO   06D4 (RETURN)
.................... }                          
.................... // LCD screen clear.                   
.................... void lcdClear(){ 
....................    lcdcmd(0x01);                   
*
06C0:  MOVLW  01
06C2:  MOVWF  x92
06C4:  RCALL  0676
06C6:  GOTO   06DA (RETURN)
.................... }                   
.................... // Go to first line. 
.................... void lcdGoToFirstLine(){  
....................    lcdcmd(0x80); 
*
0B0C:  MOVLW  80
0B0E:  MOVWF  x92
0B10:  RCALL  0676
0B12:  GOTO   0B5E (RETURN)
.................... }                                  
.................... // Go to second line.                        
.................... void lcdGoToSecondLine(){ 
....................    lcdcmd(0xC0); 
0B16:  MOVLW  C0
0B18:  MOVWF  x92
0B1A:  RCALL  0676
0B1C:  GOTO   0B66 (RETURN)
.................... }                        
.................... // Shift cursor to right. 
.................... void lcdShiftRight(){   
....................    lcdcmd(0x06);                                                     
*
06B6:  MOVLW  06
06B8:  MOVWF  x92
06BA:  RCALL  0676
06BC:  GOTO   06D8 (RETURN)
.................... }                                           
.................... // Display on, Cursor on              
.................... void lcdCursorOn(){                  
....................    lcdcmd(0x0E); 
.................... }                                      
.................... //Display off, Cursor off 
.................... void lcdCursorOff(){                                             
....................    lcdcmd(0x0C);                             
*
06AC:  MOVLW  0C
06AE:  MOVWF  x92
06B0:  RCALL  0676
06B2:  GOTO   06D6 (RETURN)
.................... }                              
....................   
.................... void dis_data(uchar_t dataout) {  
....................    PORTD=dataout;   //Send data to lcdport=PORTB 
*
0B20:  MOVFF  95,F8C
....................    PORTE_RS=1;                   
0B24:  BSF    F84.0
....................    PORTE_E=1;                          
0B26:  BSF    F84.1
....................    delayUsFun(1); 
0B28:  MOVLW  01
0B2A:  MOVWF  x96
0B2C:  CALL   00DA
....................    PORTE_E=0;   
0B30:  BCF    F84.1
0B32:  RETURN 0
....................    //PORTD=0x00; 
....................    //while(test_bit(PORTD,7));           
.................... }   
.................... /*DATA MODE*/   
.................... void lcddata(uchar_t text){  
....................    uchar_t data;                                                                 
....................    data=(text & 0xF0);         
0B34:  MOVF   x93,W
0B36:  ANDLW  F0
0B38:  MOVWF  x94
....................    dis_data(data);     
0B3A:  MOVFF  94,95
0B3E:  RCALL  0B20
....................    data=((text<<4)&0xF0);      
0B40:  SWAPF  x93,W
0B42:  MOVWF  00
0B44:  MOVLW  F0
0B46:  ANDWF  00,F
0B48:  MOVF   00,W
0B4A:  ANDLW  F0
0B4C:  MOVWF  x94
....................    dis_data(data);                  
0B4E:  MOVFF  94,95
0B52:  RCALL  0B20
0B54:  GOTO   0B84 (RETURN)
.................... }                                
.................... void LCD_String(){  
....................    if(countLCDChar==0)  
0B58:  MOVF   39,F
0B5A:  BNZ   0B5E
....................       lcdGoToFirstLine(); 
0B5C:  BRA    0B0C
....................    if(countLCDChar==16)   
0B5E:  MOVF   39,W
0B60:  SUBLW  10
0B62:  BNZ   0B66
....................       lcdGoToSecondLine();    
0B64:  BRA    0B16
....................    if(countLCDChar<=31){  
0B66:  MOVF   39,W
0B68:  SUBLW  1F
0B6A:  BNC   0B88
....................       lcddata(strLCD[countLCDChar]); 
0B6C:  CLRF   03
0B6E:  MOVF   39,W
0B70:  ADDLW  19
0B72:  MOVWF  FE9
0B74:  MOVLW  00
0B76:  ADDWFC 03,W
0B78:  MOVWF  FEA
0B7A:  MOVFF  FEF,92
0B7E:  MOVFF  92,93
0B82:  BRA    0B34
....................       countLCDChar++;   
0B84:  INCF   39,F
....................    }else{    
0B86:  BRA    0B8C
....................       LCDW1SecFlag=0; 
0B88:  CLRF   3A
....................       countLCDChar=0; 
0B8A:  CLRF   39
....................    }                  
0B8C:  GOTO   0156 (RETURN)
.................... }  
....................  
....................  
.................... void LCD_Custom_Char(uchar_t loc, uchar_t *msg){ 
....................     uchar_t i; 
....................     if(loc<8) 
....................     { 
....................      lcdcmd(0x40 + (loc*8));    /* Command 0x40 and onwards forces the device to point CGRAM address */ 
....................      for(i=0;i<8;i++)          /* Write 8 byte for generation of 1 character */ 
....................         lcddata(msg[i]);       
....................     }                        
.................... } 
....................  
....................                                           
....................  
....................       
....................  
.................... #include "delayms.c" 
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs){  // Delay function - generates a delay of specified msecs 
....................    uint16_t i; 
....................    uint8_t j;  
....................    for(i=0;i<=msecs;i++) 
....................    for(j=0;j<205;j++); /*This count Provide delay of 1 ms for 8MHz Frequency */                              
.................... }        
....................  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
*
00DA:  CLRF   x97
00DC:  MOVF   x97,W
00DE:  SUBWF  x96,W
00E0:  BNC   00E6
00E2:  INCF   x97,F
00E4:  BRA    00DC
....................     }                                
00E6:  RETURN 0
.................... }   
....................  
....................  
.................... #include "1wire.c" 
.................... #include "1wire.h"  
.................... #ifndef ONE_WIRE_H                                  
.................... #define ONE_WIRE_H   
....................                                                                          
....................       
.................... void onewire_reset();   
.................... void onewire_write(uchar_t);  
.................... uint8_t onewire_read();                              
.................... void OneWireLow();           
.................... void OneWireRelease();  
....................                                                 
.................... // SEARCH ROOM 
.................... const uchar_t dscrc_table[] = { //static 
.................... 0, 94,188,226, 97, 63,221,131,194,156,126, 32,163,253, 31, 65, 
.................... 157,195, 33,127,252,162, 64, 30, 95, 1,227,189, 62, 96,130,220, 
.................... 35,125,159,193, 66, 28,254,160,225,191, 93, 3,128,222, 60, 98, 
.................... 190,224, 2, 92,223,129, 99, 61,124, 34,192,158, 29, 67,161,255, 
.................... 70, 24,250,164, 39,121,155,197,132,218, 56,102,229,187, 89, 7, 
.................... 219,133,103, 57,186,228, 6, 88, 25, 71,165,251,120, 38,196,154, 
.................... 101, 59,217,135, 4, 90,184,230,167,249, 27, 69,198,152,122, 36, 
.................... 248,166, 68, 26,153,199, 37,123, 58,100,134,216, 91, 5,231,185, 
.................... 140,210, 48,110,237,179, 81, 15, 78, 16,242,172, 47,113,147,205, 
.................... 17, 79,173,243,112, 46,204,146,211,141,111, 49,178,236, 14, 80, 
.................... 175,241, 19, 77,206,144,114, 44,109, 51,209,143, 12, 82,176,238, 
.................... 50,108,142,208, 83, 13,239,177,240,174, 76, 18,145,207, 45,115, 
.................... 202,148,118, 40,171,245, 23, 73, 8, 86,180,234,105, 55,213,139, 
.................... 87, 9,235,181, 54,104,138,212,149,203, 41,119,244,170, 72, 22, 
.................... 233,183, 85, 11,136,214, 52,106, 43,117,151,201, 74, 20,246,168, 
.................... 116, 42,200,150, 21, 75,169,247,182,232, 10, 84,215,137,107, 53}; 
....................  
....................  
.................... extern uchar_t i;     
.................... extern uchar_t SlaveROM[3][9];   
....................  
.................... // global search state 
.................... extern uchar_t ROM_NO[9];                              
.................... extern uint8_t LastDiscrepancy; 
.................... extern uint8_t LastFamilyDiscrepancy; 
.................... extern uint8_t LastDeviceFlag; 
.................... extern uchar_t crc8;    
....................  
.................... uchar_t docrc8(uchar_t );   
....................  
.................... unsigned short Ow_Read_Bit(); 
.................... void Ow_Write_One();    
.................... void Ow_Write_Zero(); 
....................  
.................... uint8_t Ow_Reset(); 
....................  
.................... uint8_t Ow_Search();      
.................... uint8_t Ow_First();                
.................... uint8_t Ow_Next(); 
.................... void Ow_Target_Setup(uchar_t ); 
.................... void Ow_Family_Skip_Setup(); 
....................  
....................  
.................... #endif ONE_WIRE_H 
....................  
.................... #ifndef ONE_WIRE_C 
.................... #define ONE_WIRE_C  
....................      
....................  
.................... #define ONE_WIRE_PIN PIN_C0 
....................                                  
....................  
.................... uchar_t i;     
.................... uchar_t SlaveROM[3][9];                          
....................                        
.................... // global search state 
.................... uchar_t ROM_NO[9];                                   
.................... uint8_t LastDiscrepancy; 
.................... uint8_t LastFamilyDiscrepancy; 
.................... uint8_t LastDeviceFlag; 
.................... uchar_t crc8;                            
....................                                                                                                                                                                         
.................... /*     
....................  * onewire_reset() 
....................  * Description: Initiates the one wire bus.         
....................  */ 
.................... // OK if just using a single permanently connected device                
....................                                            
.................... void onewire_reset() {  
....................    OneWireLow();  
*
0B90:  CALL   00FA
....................    delay_us(500); 
0B94:  MOVLW  02
0B96:  MOVWF  x99
0B98:  MOVLW  F8
0B9A:  MOVWF  x9C
0B9C:  RCALL  070A
0B9E:  DECFSZ x99,F
0BA0:  BRA    0B98
....................    OneWireRelease();            
0BA2:  RCALL  0728
....................    delay_us(500);  
0BA4:  MOVLW  02
0BA6:  MOVWF  x99
0BA8:  MOVLW  F8
0BAA:  MOVWF  x9C
0BAC:  RCALL  070A
0BAE:  DECFSZ x99,F
0BB0:  BRA    0BA8
0BB2:  RETURN 0
.................... }                                          
....................           
.................... /*                                
....................  * onewire_write(int8 data) 
....................  * Arguments: a byte of data. 
....................  * Description: writes a byte of data to the device. 
....................  */ 
.................... void onewire_write(uchar_t data) {  
....................    int8 count; 
....................     for(count = 0; count < 8; ++count) { 
*
0798:  CLRF   x9B
079A:  MOVF   x9B,W
079C:  SUBLW  07
079E:  BNC   07C6
....................         OneWireLow(); 
07A0:  RCALL  00FA
....................         delay_us(2);                // pull 1-wire low to initiate write time-slot. 
07A2:  BRA    07A4
07A4:  BRA    07A6
....................         if(data & 0x01)                 
07A6:  BTFSS  x9A.0
07A8:  BRA    07AC
....................           OneWireRelease();   
07AA:  RCALL  0728
....................         delay_us(65);               // wait until end of write slot. 
07AC:  MOVLW  2A
07AE:  MOVWF  00
07B0:  DECFSZ 00,F
07B2:  BRA    07B0
07B4:  BRA    07B6
07B6:  NOP   
....................         OneWireRelease(); // set 1-wire high again, 
07B8:  RCALL  0728
....................         delay_us(2);                // for more than 1us minimum.  
07BA:  BRA    07BC
07BC:  BRA    07BE
....................         data = (data >> 1);  
07BE:  BCF    FD8.0
07C0:  RRCF   x9A,F
07C2:  INCF   x9B,F
07C4:  BRA    079A
....................     } 
07C6:  RETURN 0
.................... }                                                                  
....................                                         
.................... /* 
....................  * onewire_read()         
....................  * Description: reads and returns a byte of data from the device.                                                                  
....................  */                                   
.................... uint8_t onewire_read() {  
*
0BB4:  CLRF   x9A
....................     uint8_t count, data=0;                      
....................     for(count = 0; count < 8; ++count) { 
0BB6:  CLRF   x99
0BB8:  MOVF   x99,W
0BBA:  SUBLW  07
0BBC:  BNC   0BFA
....................         OneWireLow(); 
0BBE:  CALL   00FA
....................         delay_us(2);                // pull 1-wire low to initiate read time-slot. 
0BC2:  BRA    0BC4
0BC4:  BRA    0BC6
....................         OneWireRelease();              // now let 1-wire float high, 
0BC6:  RCALL  0728
....................         delay_us(4);                // let device state stabilise,  
0BC8:  MOVLW  02
0BCA:  MOVWF  00
0BCC:  DECFSZ 00,F
0BCE:  BRA    0BCC
0BD0:  NOP   
....................         if(PORTC_0)                 //ZATEN RELEASE KONUMUNA TEKRAR BIR AYARLAMAYA GEREK YOK          
0BD2:  BTFSS  F82.0
0BD4:  BRA    0BEC
....................            bit_set(data,count);    
0BD6:  MOVLW  01
0BD8:  MOVWF  00
0BDA:  MOVF   x99,W
0BDC:  MOVWF  01
0BDE:  BZ    0BE8
0BE0:  BCF    FD8.0
0BE2:  RLCF   00,F
0BE4:  DECFSZ 01,F
0BE6:  BRA    0BE0
0BE8:  MOVF   00,W
0BEA:  IORWF  x9A,F
....................         delay_us(120);              // wait until end of read slot. 
0BEC:  MOVLW  4F
0BEE:  MOVWF  00
0BF0:  DECFSZ 00,F
0BF2:  BRA    0BF0
0BF4:  BRA    0BF6
0BF6:  INCF   x99,F
0BF8:  BRA    0BB8
....................     }                          
....................     return data;     
0BFA:  MOVFF  9A,01
0BFE:  RETURN 0
.................... }  
....................                   
....................                
.................... void OneWireRelease(){  
....................     PORTC_0 = 1; // Set as output  BUSDIR      
*
0728:  BSF    F82.0
....................     TRISC_0 = 1; // Set high       BUSOUT else{      
072A:  BSF    F94.0
072C:  RETURN 0
.................... }  
....................  
.................... void OneWireLow(){                 
....................    PORTC_0 = 0; // Set as output  BUSDIR 
*
00FA:  BCF    F82.0
....................    TRISC_0 = 0; // Set low        BUSOUT 
00FC:  BCF    F94.0
00FE:  RETURN 0
.................... }        
....................                                                                                
....................                               
.................... uchar_t docrc8(uchar_t value){ 
....................    crc8 = dscrc_table[crc8 ^ value];    // Xor operation 
*
0804:  MOVF   x8D,W
0806:  XORWF  x9B,W
0808:  CLRF   03
080A:  MOVFF  FF2,9C
080E:  BCF    FF2.7
0810:  RCALL  0402
0812:  BTFSC  x9C.7
0814:  BSF    FF2.7
0816:  MOVWF  x8D
....................    return crc8; 
0818:  MOVFF  8D,01
081C:  GOTO   0910 (RETURN)
.................... }   
....................               
.................... uint8_t Ow_Reset(){ 
*
075C:  CLRF   x9A
....................    uint8_t OW=0;  
....................    OneWireLow();                             
075E:  RCALL  00FA
....................    delay_us(500); 
0760:  MOVLW  02
0762:  MOVWF  x9B
0764:  MOVLW  F8
0766:  MOVWF  x9C
0768:  RCALL  070A
076A:  DECFSZ x9B,F
076C:  BRA    0764
....................    OneWireRelease();  
076E:  RCALL  0728
....................    delay_us(70);        
0770:  MOVLW  2E
0772:  MOVWF  00
0774:  DECFSZ 00,F
0776:  BRA    0774
0778:  NOP   
....................    OW = Ow_Read_Bit();                 
077A:  RCALL  072E
077C:  MOVFF  01,9A
....................    delay_us(430); 
0780:  MOVLW  02
0782:  MOVWF  x9B
0784:  MOVLW  D5
0786:  MOVWF  x9C
0788:  RCALL  070A
078A:  DECFSZ x9B,F
078C:  BRA    0784
....................    OneWireRelease();  
078E:  RCALL  0728
....................    return OW;  
0790:  MOVFF  9A,01
0794:  GOTO   0836 (RETURN)
.................... }   
....................  
.................... unsigned short Ow_Read_Bit(){ 
....................    unsigned short BitValue;    // Bit to be returned 
....................    OneWireLow();               // Set pin 2 in PORT E as output 
*
072E:  RCALL  00FA
....................                                // Drive bus low   LATE.B2;   for PIC18 
....................    delay_us(2);                // Wait 2 usecs 
0730:  BRA    0732
0732:  BRA    0734
....................    OneWireRelease();                 // Release the bus 
0734:  RCALL  0728
....................    delay_us(5);                // Wait 5 usecs 
0736:  MOVLW  02
0738:  MOVWF  00
073A:  DECFSZ 00,F
073C:  BRA    073A
073E:  BRA    0740
0740:  NOP   
....................    BitValue = PORTC_0;         // Read bit value on pin 0 on PORT C 
0742:  BCF    x9B.0
0744:  BTFSC  F82.0
0746:  BSF    x9B.0
....................    delay_us(120);               // Wait 120 usecs 
0748:  MOVLW  4F
074A:  MOVWF  00
074C:  DECFSZ 00,F
074E:  BRA    074C
0750:  BRA    0752
....................    return BitValue;            // Return bit read 
0752:  MOVLW  00
0754:  BTFSC  x9B.0
0756:  MOVLW  01
0758:  MOVWF  01
075A:  RETURN 0
.................... } 
....................                                      
.................... // Sends a '1' bit to the I/O pin  See application note 126 
.................... void Ow_Write_One(){    
....................    OneWireLow();      // Set pin 2 in PORT E as output 
*
07C8:  RCALL  00FA
....................    delay_us(2);        // Drive bus low 
07CA:  BRA    07CC
07CC:  BRA    07CE
....................    OneWireRelease();   
07CE:  RCALL  0728
....................    delay_us(65);       // Wait 6 usecs        (6*4)*0.25 us 
07D0:  MOVLW  2A
07D2:  MOVWF  00
07D4:  DECFSZ 00,F
07D6:  BRA    07D4
07D8:  BRA    07DA
07DA:  NOP   
....................    OneWireRelease();  // Release the bus 
07DC:  RCALL  0728
....................    delay_us(2);      // Wait 64 usecs        (64*4)*0.25 us 
07DE:  BRA    07E0
07E0:  BRA    07E2
07E2:  GOTO   08EE (RETURN)
.................... } 
....................                        
.................... // Sends a '0' bit to the I/O pin   See application note 126 
.................... void Ow_Write_Zero(){    
....................    OneWireLow();     // Set pin 2 in PORT E as output 
07E6:  RCALL  00FA
....................                      // Drive bus low 
....................    delay_us(65);     // Wait 60 usecs 
07E8:  MOVLW  2A
07EA:  MOVWF  00
07EC:  DECFSZ 00,F
07EE:  BRA    07EC
07F0:  BRA    07F2
07F2:  NOP   
....................    OneWireRelease(); // Release the bus 
07F4:  RCALL  0728
....................    delay_us(10);     // Wait 10 usecs 
07F6:  MOVLW  06
07F8:  MOVWF  00
07FA:  DECFSZ 00,F
07FC:  BRA    07FA
07FE:  NOP   
0800:  GOTO   08EE (RETURN)
.................... } 
....................     
.................... uint8_t Ow_Search(){ 
....................    uint8_t id_bit_number; 
....................    uint8_t last_zero, rom_byte_number, search_result; 
....................    uint8_t id_bit, cmp_id_bit; 
....................    uchar_t rom_byte_mask, search_direction; 
....................  
....................    // initialize for search 
....................    id_bit_number = 1; 
*
0820:  MOVLW  01
0822:  MOVWF  x92
....................    last_zero = 0; 
0824:  CLRF   x93
....................    rom_byte_number = 0; 
0826:  CLRF   x94
....................    rom_byte_mask = 1; 
0828:  MOVWF  x98
....................    search_result = 0; 
082A:  CLRF   x95
....................    crc8 = 0;  
082C:  CLRF   x8D
....................     
....................          // if the last call was not the last one 
....................    if (!LastDeviceFlag){ 
082E:  MOVF   x8C,F
0830:  BTFSS  FD8.2
0832:  BRA    0936
....................       // check if there are 1-Wire device (s) 0 if the device(s) responded, 1 if no devices did 
....................       if (Ow_Reset()){  
0834:  BRA    075C
0836:  MOVF   01,F
0838:  BZ    0846
....................          // reset the search 
....................          LastDiscrepancy = 0; 
083A:  CLRF   x8A
....................          LastDeviceFlag = 0; 
083C:  CLRF   x8C
....................          LastFamilyDiscrepancy = 0; 
083E:  CLRF   x8B
....................          return 0;  
0840:  MOVLW  00
0842:  MOVWF  01
0844:  BRA    094A
....................       } 
....................         // Issue command Search_ROM 
....................         onewire_write(0xF0); 
0846:  MOVLW  F0
0848:  MOVWF  x9A
084A:  RCALL  0798
....................         // loop to do the search 
....................         do{// read a bit and its complement 
....................            id_bit = OW_Read_Bit(); 
084C:  RCALL  072E
084E:  MOVFF  01,96
....................            cmp_id_bit = OW_Read_Bit(); 
0852:  RCALL  072E
0854:  MOVFF  01,97
....................            // 11 no devices on the 1-wire 
....................            // check for no devices on 1-wire 
....................            if((id_bit == 1) && (cmp_id_bit == 1)) 
0858:  DECFSZ x96,W
085A:  BRA    0864
085C:  DECFSZ x97,W
085E:  BRA    0864
....................               break; 
0860:  BRA    091C
0862:  BRA    0916
....................            else{ 
....................               // all devices coupled have 0 or 1 
....................               if(id_bit != cmp_id_bit) 
0864:  MOVF   x97,W
0866:  SUBWF  x96,W
0868:  BZ    0870
....................                  search_direction = id_bit; // bit write value for search 
086A:  MOVFF  96,99
086E:  BRA    08B4
....................               else{ 
....................                  // if this discrepancy is before the Last Discrepancy 
....................                  // on a previous next then pick the same as last time 
....................                  if (id_bit_number < LastDiscrepancy)         
0870:  MOVF   x8A,W
0872:  SUBWF  x92,W
0874:  BC    0894
....................                     search_direction = ((ROM_NO[rom_byte_number] &  rom_byte_mask) > 0); 
0876:  CLRF   03
0878:  MOVF   x94,W
087A:  ADDLW  81
087C:  MOVWF  FE9
087E:  MOVLW  00
0880:  ADDWFC 03,W
0882:  MOVWF  FEA
0884:  MOVF   FEF,W
0886:  ANDWF  x98,W
0888:  BNZ   088E
088A:  MOVLW  00
088C:  BRA    0890
088E:  MOVLW  01
0890:  MOVWF  x99
0892:  BRA    08A2
....................                  else 
....................                     // if equal to last pick 1, if not then pick 0 
....................                     search_direction = (id_bit_number == LastDiscrepancy); 
0894:  MOVF   x8A,W
0896:  SUBWF  x92,W
0898:  BZ    089E
089A:  MOVLW  00
089C:  BRA    08A0
089E:  MOVLW  01
08A0:  MOVWF  x99
....................                     // if 0 was picked then record its position in LastZero 
....................                     if (search_direction == 0){  
08A2:  MOVF   x99,F
08A4:  BNZ   08B4
....................                        last_zero = id_bit_number; 
08A6:  MOVFF  92,93
....................                        // check for Last discrepancy in family 
....................                        if (last_zero < 9)  
08AA:  MOVF   x93,W
08AC:  SUBLW  08
08AE:  BNC   08B4
....................                            LastFamilyDiscrepancy = last_zero; 
08B0:  MOVFF  93,8B
....................                     } 
....................                } 
....................                // set or clear the bit in the ROM byte rom_byte_number 
....................                // with mask rom_byte_mask 
....................                if (search_direction == 1) 
08B4:  DECFSZ x99,W
08B6:  BRA    08CE
....................                   ROM_NO[rom_byte_number] |= rom_byte_mask; 
08B8:  CLRF   03
08BA:  MOVF   x94,W
08BC:  ADDLW  81
08BE:  MOVWF  FE9
08C0:  MOVLW  00
08C2:  ADDWFC 03,W
08C4:  MOVWF  FEA
08C6:  MOVF   FEF,W
08C8:  IORWF  x98,W
08CA:  MOVWF  FEF
08CC:  BRA    08E4
....................                else 
....................                   ROM_NO[rom_byte_number] &= ~rom_byte_mask; 
08CE:  CLRF   03
08D0:  MOVF   x94,W
08D2:  ADDLW  81
08D4:  MOVWF  FE9
08D6:  MOVLW  00
08D8:  ADDWFC 03,W
08DA:  MOVWF  FEA
08DC:  MOVF   x98,W
08DE:  XORLW  FF
08E0:  ANDWF  FEF,W
08E2:  MOVWF  FEF
....................                // serial number search direction write bit 
....................                if (search_direction) 
08E4:  MOVF   x99,F
08E6:  BZ    08EC
....................                   Ow_Write_One(); 
08E8:  BRA    07C8
08EA:  BRA    08EE
....................                else 
....................                   Ow_Write_Zero(); 
08EC:  BRA    07E6
....................                // increment the byte counter id_bit_number 
....................                // and shift the mask rom_byte_mask 
....................  
....................                id_bit_number++; 
08EE:  INCF   x92,F
....................                rom_byte_mask <<= 1; 
08F0:  BCF    FD8.0
08F2:  RLCF   x98,F
....................  
....................                // if the mask is 0 then go to new SerialNum byte rom_byte_number 
....................                //and reset mask 
....................                if (rom_byte_mask == 0){ 
08F4:  MOVF   x98,F
08F6:  BNZ   0916
....................                   docrc8(ROM_NO[rom_byte_number]); // accumulate the CRC 
08F8:  CLRF   03
08FA:  MOVF   x94,W
08FC:  ADDLW  81
08FE:  MOVWF  FE9
0900:  MOVLW  00
0902:  ADDWFC 03,W
0904:  MOVWF  FEA
0906:  MOVFF  FEF,9A
090A:  MOVFF  9A,9B
090E:  BRA    0804
....................                   rom_byte_number++; 
0910:  INCF   x94,F
....................                   rom_byte_mask = 1; 
0912:  MOVLW  01
0914:  MOVWF  x98
....................                } 
....................            }                               
....................         }   // End of search loop                  
....................         while(rom_byte_number < 8); // loop until through all ROM bytes 0-7 
0916:  MOVF   x94,W
0918:  SUBLW  07
091A:  BC    084C
....................         // if the search was successful then 
....................         if (!((id_bit_number < 65) || (crc8 != 0))){ 
091C:  MOVF   x92,W
091E:  SUBLW  40
0920:  BC    0936
0922:  MOVF   x8D,F
0924:  BNZ   0936
....................            // search successful so set LastDiscrepancy,LastDeviceFlag,search_result 
....................            LastDiscrepancy = last_zero; 
0926:  MOVFF  93,8A
....................            // check for last device 
....................            if (LastDiscrepancy == 0) 
092A:  MOVF   x8A,F
092C:  BNZ   0932
....................               LastDeviceFlag = 1; 
092E:  MOVLW  01
0930:  MOVWF  x8C
....................            search_result = 1; 
0932:  MOVLW  01
0934:  MOVWF  x95
....................         } 
....................    } 
....................    // if no device found then reset counters so next 'search' will be 
....................    // like a first 
....................    if (!search_result || !ROM_NO[0]){ 
0936:  MOVF   x95,F
0938:  BZ    093E
093A:  MOVF   x81,F
093C:  BNZ   0946
....................             LastDiscrepancy = 0;  
093E:  CLRF   x8A
....................             LastDeviceFlag = 0; 
0940:  CLRF   x8C
....................             LastFamilyDiscrepancy = 0; 
0942:  CLRF   x8B
....................             search_result = 0;    
0944:  CLRF   x95
....................    } 
....................    return search_result; 
0946:  MOVFF  95,01
094A:  RETURN 0
.................... }   // End of Ow-Search function 
....................  
.................... // Finds the first device 
.................... uint8_t Ow_First(){ 
....................    LastDiscrepancy = 0; 
094C:  CLRF   x8A
....................    LastDeviceFlag = 0; 
094E:  CLRF   x8C
....................    LastFamilyDiscrepancy = 0; 
0950:  CLRF   x8B
....................    return Ow_Search(); 
0952:  RCALL  0820
0954:  MOVF   01,W
0956:  GOTO   09B4 (RETURN)
.................... } 
....................  
....................  
.................... // Finds any other devices after the first one 
.................... uint8_t Ow_Next(){ 
....................    return Ow_Search(); 
*
0974:  RCALL  0820
0976:  MOVF   01,W
0978:  RETURN 0
.................... }  
....................  
.................... // Set up search to look for a certain device family code 
.................... void Ow_Target_Setup(uchar_t family_code){ 
....................    uint8_t i; 
....................    // set the search state to find SearchFamily type devices 
....................    ROM_NO[0] = family_code; 
....................    for (i = 1; i < 8; i++) 
....................    ROM_NO[i] = 0; 
....................    LastDiscrepancy = 64; 
....................    LastFamilyDiscrepancy = 0; 
....................    LastDeviceFlag = 0; 
.................... } 
....................                                                     
.................... void Ow_Family_Skip_Setup(){ 
....................    // set the Last discrepancy to last family discrepancy 
....................    LastDiscrepancy = LastFamilyDiscrepancy; 
....................    LastFamilyDiscrepancy = 0; 
....................    // check for end of list 
....................    if (LastDiscrepancy == 0) 
....................       LastDeviceFlag = 1; 
.................... } 
....................                      
.................... #endif /*ONE_WIRE_C*/ 
....................  
.................... #include "ds1820.c"  
.................... #ifndef DS1820_C                                                                  
.................... #define DS1820_C   
....................  
.................... #include "ds1820.h" 
.................... #ifndef DS1820_H 
.................... #define DS1820_H  
.................... /*#define Input           1 
.................... #define Output          0 
.................... #define ReadROM         0x33 
.................... #define MatchROM        0x55 
.................... #define SkipROM         0xCC 
.................... #define SearchROM       0xF0 
.................... #define AlarmSearch     0xEC 
.................... #define ConvertT        0x44 
.................... #define ReadScratchpad  0xBE 
.................... #define WriteScratchpad 0x4E 
.................... #define CopyScratchpad  0x48 
.................... #define RecallEE        0xB8                                  
.................... #define ReadPowerSupply 0xB4 
.................... #define DevicesNumber   1 */      
....................  
....................                                         
.................... extern uchar_t DevicesFound; // Number of devices found  
.................... extern uchar_t queue;   
.................... void searchRom();  
....................  
....................                  
.................... void ds1820_read();  
.................... void ds1820_read_from_rom(uchar_t *); 
.................... void ds1820_configure(uchar_t TH, uchar_t TL, uchar_t config);   
.................... extern uchar_t TEMPBF[32];   
.................... extern sint16_t tempHeat;   
.................... extern sint16_t heat1,heat2,heat3;    
....................  
....................                                         
....................                                         
....................   
....................  
....................  
.................... #endif //DS1820_H 
....................                      
....................  
.................... #include "1wire.h"   
.................... #ifndef ONE_WIRE_H                                  
.................... #define ONE_WIRE_H   
....................                                                                          
....................       
.................... void onewire_reset();   
.................... void onewire_write(uchar_t);  
.................... uint8_t onewire_read();                              
.................... void OneWireLow();           
.................... void OneWireRelease();  
....................                                                 
.................... // SEARCH ROOM 
.................... const uchar_t dscrc_table[] = { //static 
.................... 0, 94,188,226, 97, 63,221,131,194,156,126, 32,163,253, 31, 65, 
.................... 157,195, 33,127,252,162, 64, 30, 95, 1,227,189, 62, 96,130,220, 
.................... 35,125,159,193, 66, 28,254,160,225,191, 93, 3,128,222, 60, 98, 
.................... 190,224, 2, 92,223,129, 99, 61,124, 34,192,158, 29, 67,161,255, 
.................... 70, 24,250,164, 39,121,155,197,132,218, 56,102,229,187, 89, 7, 
.................... 219,133,103, 57,186,228, 6, 88, 25, 71,165,251,120, 38,196,154, 
.................... 101, 59,217,135, 4, 90,184,230,167,249, 27, 69,198,152,122, 36, 
.................... 248,166, 68, 26,153,199, 37,123, 58,100,134,216, 91, 5,231,185, 
.................... 140,210, 48,110,237,179, 81, 15, 78, 16,242,172, 47,113,147,205, 
.................... 17, 79,173,243,112, 46,204,146,211,141,111, 49,178,236, 14, 80, 
.................... 175,241, 19, 77,206,144,114, 44,109, 51,209,143, 12, 82,176,238, 
.................... 50,108,142,208, 83, 13,239,177,240,174, 76, 18,145,207, 45,115, 
.................... 202,148,118, 40,171,245, 23, 73, 8, 86,180,234,105, 55,213,139, 
.................... 87, 9,235,181, 54,104,138,212,149,203, 41,119,244,170, 72, 22, 
.................... 233,183, 85, 11,136,214, 52,106, 43,117,151,201, 74, 20,246,168, 
.................... 116, 42,200,150, 21, 75,169,247,182,232, 10, 84,215,137,107, 53}; 
....................  
....................  
.................... extern uchar_t i;     
.................... extern uchar_t SlaveROM[3][9];   
....................  
.................... // global search state 
.................... extern uchar_t ROM_NO[9];                              
.................... extern uint8_t LastDiscrepancy; 
.................... extern uint8_t LastFamilyDiscrepancy; 
.................... extern uint8_t LastDeviceFlag; 
.................... extern uchar_t crc8;    
....................  
.................... uchar_t docrc8(uchar_t );   
....................  
.................... unsigned short Ow_Read_Bit(); 
.................... void Ow_Write_One();    
.................... void Ow_Write_Zero(); 
....................  
.................... uint8_t Ow_Reset(); 
....................  
.................... uint8_t Ow_Search();      
.................... uint8_t Ow_First();                
.................... uint8_t Ow_Next(); 
.................... void Ow_Target_Setup(uchar_t ); 
.................... void Ow_Family_Skip_Setup(); 
....................  
....................  
.................... #endif ONE_WIRE_H 
....................  
.................... #include "1wire.c"  
.................... #include "1wire.h"  
.................... #ifndef ONE_WIRE_H                                  
.................... #define ONE_WIRE_H   
....................                                                                          
....................       
.................... void onewire_reset();   
.................... void onewire_write(uchar_t);  
.................... uint8_t onewire_read();                              
.................... void OneWireLow();           
.................... void OneWireRelease();  
....................                                                 
.................... // SEARCH ROOM 
.................... const uchar_t dscrc_table[] = { //static 
.................... 0, 94,188,226, 97, 63,221,131,194,156,126, 32,163,253, 31, 65, 
.................... 157,195, 33,127,252,162, 64, 30, 95, 1,227,189, 62, 96,130,220, 
.................... 35,125,159,193, 66, 28,254,160,225,191, 93, 3,128,222, 60, 98, 
.................... 190,224, 2, 92,223,129, 99, 61,124, 34,192,158, 29, 67,161,255, 
.................... 70, 24,250,164, 39,121,155,197,132,218, 56,102,229,187, 89, 7, 
.................... 219,133,103, 57,186,228, 6, 88, 25, 71,165,251,120, 38,196,154, 
.................... 101, 59,217,135, 4, 90,184,230,167,249, 27, 69,198,152,122, 36, 
.................... 248,166, 68, 26,153,199, 37,123, 58,100,134,216, 91, 5,231,185, 
.................... 140,210, 48,110,237,179, 81, 15, 78, 16,242,172, 47,113,147,205, 
.................... 17, 79,173,243,112, 46,204,146,211,141,111, 49,178,236, 14, 80, 
.................... 175,241, 19, 77,206,144,114, 44,109, 51,209,143, 12, 82,176,238, 
.................... 50,108,142,208, 83, 13,239,177,240,174, 76, 18,145,207, 45,115, 
.................... 202,148,118, 40,171,245, 23, 73, 8, 86,180,234,105, 55,213,139, 
.................... 87, 9,235,181, 54,104,138,212,149,203, 41,119,244,170, 72, 22, 
.................... 233,183, 85, 11,136,214, 52,106, 43,117,151,201, 74, 20,246,168, 
.................... 116, 42,200,150, 21, 75,169,247,182,232, 10, 84,215,137,107, 53}; 
....................  
....................  
.................... extern uchar_t i;     
.................... extern uchar_t SlaveROM[3][9];   
....................  
.................... // global search state 
.................... extern uchar_t ROM_NO[9];                              
.................... extern uint8_t LastDiscrepancy; 
.................... extern uint8_t LastFamilyDiscrepancy; 
.................... extern uint8_t LastDeviceFlag; 
.................... extern uchar_t crc8;    
....................  
.................... uchar_t docrc8(uchar_t );   
....................  
.................... unsigned short Ow_Read_Bit(); 
.................... void Ow_Write_One();    
.................... void Ow_Write_Zero(); 
....................  
.................... uint8_t Ow_Reset(); 
....................  
.................... uint8_t Ow_Search();      
.................... uint8_t Ow_First();                
.................... uint8_t Ow_Next(); 
.................... void Ow_Target_Setup(uchar_t ); 
.................... void Ow_Family_Skip_Setup(); 
....................  
....................  
.................... #endif ONE_WIRE_H 
....................  
.................... #ifndef ONE_WIRE_C 
.................... #define ONE_WIRE_C  
....................      
....................  
.................... #define ONE_WIRE_PIN PIN_C0 
....................                                  
....................  
.................... uchar_t i;     
.................... uchar_t SlaveROM[3][9];                          
....................                        
.................... // global search state 
.................... uchar_t ROM_NO[9];                                   
.................... uint8_t LastDiscrepancy; 
.................... uint8_t LastFamilyDiscrepancy; 
.................... uint8_t LastDeviceFlag; 
.................... uchar_t crc8;                            
....................                                                                                                                                                                         
.................... /*     
....................  * onewire_reset() 
....................  * Description: Initiates the one wire bus.         
....................  */ 
.................... // OK if just using a single permanently connected device                
....................                                            
.................... void onewire_reset() {  
....................    OneWireLow();  
....................    delay_us(500); 
....................    OneWireRelease();            
....................    delay_us(500);  
.................... }                                          
....................           
.................... /*                                
....................  * onewire_write(int8 data) 
....................  * Arguments: a byte of data. 
....................  * Description: writes a byte of data to the device. 
....................  */ 
.................... void onewire_write(uchar_t data) {  
....................    int8 count; 
....................     for(count = 0; count < 8; ++count) { 
....................         OneWireLow(); 
....................         delay_us(2);                // pull 1-wire low to initiate write time-slot. 
....................         if(data & 0x01)                 
....................           OneWireRelease();   
....................         delay_us(65);               // wait until end of write slot. 
....................         OneWireRelease(); // set 1-wire high again, 
....................         delay_us(2);                // for more than 1us minimum.  
....................         data = (data >> 1);  
....................     } 
.................... }                                                                  
....................                                         
.................... /* 
....................  * onewire_read()         
....................  * Description: reads and returns a byte of data from the device.                                                                  
....................  */                                   
.................... uint8_t onewire_read() {  
....................     uint8_t count, data=0;                      
....................     for(count = 0; count < 8; ++count) { 
....................         OneWireLow(); 
....................         delay_us(2);                // pull 1-wire low to initiate read time-slot. 
....................         OneWireRelease();              // now let 1-wire float high, 
....................         delay_us(4);                // let device state stabilise,  
....................         if(PORTC_0)                 //ZATEN RELEASE KONUMUNA TEKRAR BIR AYARLAMAYA GEREK YOK          
....................            bit_set(data,count);    
....................         delay_us(120);              // wait until end of read slot. 
....................     }                          
....................     return data;     
.................... }  
....................                   
....................                
.................... void OneWireRelease(){  
....................     PORTC_0 = 1; // Set as output  BUSDIR      
....................     TRISC_0 = 1; // Set high       BUSOUT else{      
.................... }  
....................  
.................... void OneWireLow(){                 
....................    PORTC_0 = 0; // Set as output  BUSDIR 
....................    TRISC_0 = 0; // Set low        BUSOUT 
.................... }        
....................                                                                                
....................                               
.................... uchar_t docrc8(uchar_t value){ 
....................    crc8 = dscrc_table[crc8 ^ value];    // Xor operation 
....................    return crc8; 
.................... }   
....................               
.................... uint8_t Ow_Reset(){ 
....................    uint8_t OW=0;  
....................    OneWireLow();                             
....................    delay_us(500); 
....................    OneWireRelease();  
....................    delay_us(70);        
....................    OW = Ow_Read_Bit();                 
....................    delay_us(430); 
....................    OneWireRelease();  
....................    return OW;  
.................... }   
....................  
.................... unsigned short Ow_Read_Bit(){ 
....................    unsigned short BitValue;    // Bit to be returned 
....................    OneWireLow();               // Set pin 2 in PORT E as output 
....................                                // Drive bus low   LATE.B2;   for PIC18 
....................    delay_us(2);                // Wait 2 usecs 
....................    OneWireRelease();                 // Release the bus 
....................    delay_us(5);                // Wait 5 usecs 
....................    BitValue = PORTC_0;         // Read bit value on pin 0 on PORT C 
....................    delay_us(120);               // Wait 120 usecs 
....................    return BitValue;            // Return bit read 
.................... } 
....................                                      
.................... // Sends a '1' bit to the I/O pin  See application note 126 
.................... void Ow_Write_One(){    
....................    OneWireLow();      // Set pin 2 in PORT E as output 
....................    delay_us(2);        // Drive bus low 
....................    OneWireRelease();   
....................    delay_us(65);       // Wait 6 usecs        (6*4)*0.25 us 
....................    OneWireRelease();  // Release the bus 
....................    delay_us(2);      // Wait 64 usecs        (64*4)*0.25 us 
.................... } 
....................                        
.................... // Sends a '0' bit to the I/O pin   See application note 126 
.................... void Ow_Write_Zero(){    
....................    OneWireLow();     // Set pin 2 in PORT E as output 
....................                      // Drive bus low 
....................    delay_us(65);     // Wait 60 usecs 
....................    OneWireRelease(); // Release the bus 
....................    delay_us(10);     // Wait 10 usecs 
.................... } 
....................     
.................... uint8_t Ow_Search(){ 
....................    uint8_t id_bit_number; 
....................    uint8_t last_zero, rom_byte_number, search_result; 
....................    uint8_t id_bit, cmp_id_bit; 
....................    uchar_t rom_byte_mask, search_direction; 
....................  
....................    // initialize for search 
....................    id_bit_number = 1; 
....................    last_zero = 0; 
....................    rom_byte_number = 0; 
....................    rom_byte_mask = 1; 
....................    search_result = 0; 
....................    crc8 = 0;  
....................     
....................          // if the last call was not the last one 
....................    if (!LastDeviceFlag){ 
....................       // check if there are 1-Wire device (s) 0 if the device(s) responded, 1 if no devices did 
....................       if (Ow_Reset()){  
....................          // reset the search 
....................          LastDiscrepancy = 0; 
....................          LastDeviceFlag = 0; 
....................          LastFamilyDiscrepancy = 0; 
....................          return 0;  
....................       } 
....................         // Issue command Search_ROM 
....................         onewire_write(0xF0); 
....................         // loop to do the search 
....................         do{// read a bit and its complement 
....................            id_bit = OW_Read_Bit(); 
....................            cmp_id_bit = OW_Read_Bit(); 
....................            // 11 no devices on the 1-wire 
....................            // check for no devices on 1-wire 
....................            if((id_bit == 1) && (cmp_id_bit == 1)) 
....................               break; 
....................            else{ 
....................               // all devices coupled have 0 or 1 
....................               if(id_bit != cmp_id_bit) 
....................                  search_direction = id_bit; // bit write value for search 
....................               else{ 
....................                  // if this discrepancy is before the Last Discrepancy 
....................                  // on a previous next then pick the same as last time 
....................                  if (id_bit_number < LastDiscrepancy)         
....................                     search_direction = ((ROM_NO[rom_byte_number] &  rom_byte_mask) > 0); 
....................                  else 
....................                     // if equal to last pick 1, if not then pick 0 
....................                     search_direction = (id_bit_number == LastDiscrepancy); 
....................                     // if 0 was picked then record its position in LastZero 
....................                     if (search_direction == 0){  
....................                        last_zero = id_bit_number; 
....................                        // check for Last discrepancy in family 
....................                        if (last_zero < 9)  
....................                            LastFamilyDiscrepancy = last_zero; 
....................                     } 
....................                } 
....................                // set or clear the bit in the ROM byte rom_byte_number 
....................                // with mask rom_byte_mask 
....................                if (search_direction == 1) 
....................                   ROM_NO[rom_byte_number] |= rom_byte_mask; 
....................                else 
....................                   ROM_NO[rom_byte_number] &= ~rom_byte_mask; 
....................                // serial number search direction write bit 
....................                if (search_direction) 
....................                   Ow_Write_One(); 
....................                else 
....................                   Ow_Write_Zero(); 
....................                // increment the byte counter id_bit_number 
....................                // and shift the mask rom_byte_mask 
....................  
....................                id_bit_number++; 
....................                rom_byte_mask <<= 1; 
....................  
....................                // if the mask is 0 then go to new SerialNum byte rom_byte_number 
....................                //and reset mask 
....................                if (rom_byte_mask == 0){ 
....................                   docrc8(ROM_NO[rom_byte_number]); // accumulate the CRC 
....................                   rom_byte_number++; 
....................                   rom_byte_mask = 1; 
....................                } 
....................            }                               
....................         }   // End of search loop                  
....................         while(rom_byte_number < 8); // loop until through all ROM bytes 0-7 
....................         // if the search was successful then 
....................         if (!((id_bit_number < 65) || (crc8 != 0))){ 
....................            // search successful so set LastDiscrepancy,LastDeviceFlag,search_result 
....................            LastDiscrepancy = last_zero; 
....................            // check for last device 
....................            if (LastDiscrepancy == 0) 
....................               LastDeviceFlag = 1; 
....................            search_result = 1; 
....................         } 
....................    } 
....................    // if no device found then reset counters so next 'search' will be 
....................    // like a first 
....................    if (!search_result || !ROM_NO[0]){ 
....................             LastDiscrepancy = 0;  
....................             LastDeviceFlag = 0; 
....................             LastFamilyDiscrepancy = 0; 
....................             search_result = 0;    
....................    } 
....................    return search_result; 
.................... }   // End of Ow-Search function 
....................  
.................... // Finds the first device 
.................... uint8_t Ow_First(){ 
....................    LastDiscrepancy = 0; 
....................    LastDeviceFlag = 0; 
....................    LastFamilyDiscrepancy = 0; 
....................    return Ow_Search(); 
.................... } 
....................  
....................  
.................... // Finds any other devices after the first one 
.................... uint8_t Ow_Next(){ 
....................    return Ow_Search(); 
.................... }  
....................  
.................... // Set up search to look for a certain device family code 
.................... void Ow_Target_Setup(uchar_t family_code){ 
....................    uint8_t i; 
....................    // set the search state to find SearchFamily type devices 
....................    ROM_NO[0] = family_code; 
....................    for (i = 1; i < 8; i++) 
....................    ROM_NO[i] = 0; 
....................    LastDiscrepancy = 64; 
....................    LastFamilyDiscrepancy = 0; 
....................    LastDeviceFlag = 0; 
.................... } 
....................                                                     
.................... void Ow_Family_Skip_Setup(){ 
....................    // set the Last discrepancy to last family discrepancy 
....................    LastDiscrepancy = LastFamilyDiscrepancy; 
....................    LastFamilyDiscrepancy = 0; 
....................    // check for end of list 
....................    if (LastDiscrepancy == 0) 
....................       LastDeviceFlag = 1; 
.................... } 
....................                      
.................... #endif /*ONE_WIRE_C*/ 
....................  
....................  
....................  
.................... uchar_t TEMPBF[32];     
.................... uchar_t DevicesFound; // Number of devices found    
.................... uchar_t queue;     
....................  
.................... sint16_t tempHeat;   
.................... sint16_t heat1,heat2,heat3;   
.................... uchar_t countt=0; 
....................                                    
.................... void searchRom(){   
....................    //onewire_reset();  
....................    //onewire_write(0xF0); 
....................    switch(queue){  
*
099E:  MOVF   3C,W
09A0:  XORLW  00
09A2:  BZ    09B0
09A4:  XORLW  01
09A6:  BZ    0A20
09A8:  XORLW  03
09AA:  BTFSC  FD8.2
09AC:  BRA    0A8E
09AE:  BRA    0AF6
....................    case 0:  
....................         DevicesFound = 0;  // Reset device counter     
09B0:  CLRF   3B
....................         if(Ow_First()){    // Check for the first device  
09B2:  BRA    094C
09B4:  MOVF   01,F
09B6:  BZ    0A1C
....................           DevicesFound++;  // Increment the device found counter 
09B8:  INCF   3B,F
....................           for(i=0; i<8; i++){     
09BA:  CLRF   65
09BC:  MOVF   65,W
09BE:  SUBLW  07
09C0:  BNC   0A08
....................               SlaveROM[queue][i]=ROM_NO[i];   
09C2:  MOVF   3C,W
09C4:  MULLW  09
09C6:  MOVF   FF3,W
09C8:  CLRF   x93
09CA:  MOVWF  x92
09CC:  CLRF   03
09CE:  MOVF   65,W
09D0:  ADDWF  x92,W
09D2:  MOVWF  01
09D4:  MOVF   x93,W
09D6:  ADDWFC 03,F
09D8:  MOVF   01,W
09DA:  ADDLW  66
09DC:  MOVWF  01
09DE:  MOVLW  00
09E0:  ADDWFC 03,F
09E2:  MOVFF  03,93
09E6:  CLRF   03
09E8:  MOVF   65,W
09EA:  ADDLW  81
09EC:  MOVWF  FE9
09EE:  MOVLW  00
09F0:  ADDWFC 03,W
09F2:  MOVWF  FEA
09F4:  MOVFF  FEF,94
09F8:  MOVFF  93,FEA
09FC:  MOVFF  01,FE9
0A00:  MOVFF  94,FEF
0A04:  INCF   65,F
0A06:  BRA    09BC
....................           }      
....................           memset(ROM_NO,0,8);  
0A08:  CLRF   FEA
0A0A:  MOVLW  81
0A0C:  MOVWF  FE9
0A0E:  CLRF   00
0A10:  CLRF   02
0A12:  MOVLW  08
0A14:  MOVWF  01
0A16:  RCALL  095A
....................           queue++; 
0A18:  INCF   3C,F
....................           }else 
0A1A:  BRA    0A1E
....................              queue=0;   
0A1C:  CLRF   3C
....................    break; 
0A1E:  BRA    0AF6
....................     
....................    case 1: 
....................         if(Ow_Next()){    // Check for the first device  
0A20:  RCALL  0974
0A22:  MOVF   01,F
0A24:  BZ    0A8A
....................           DevicesFound++;  // Increment the device found counter 
0A26:  INCF   3B,F
....................           for(i=0; i<8; i++){     
0A28:  CLRF   65
0A2A:  MOVF   65,W
0A2C:  SUBLW  07
0A2E:  BNC   0A76
....................              SlaveROM[queue][i]=ROM_NO[i];   
0A30:  MOVF   3C,W
0A32:  MULLW  09
0A34:  MOVF   FF3,W
0A36:  CLRF   x93
0A38:  MOVWF  x92
0A3A:  CLRF   03
0A3C:  MOVF   65,W
0A3E:  ADDWF  x92,W
0A40:  MOVWF  01
0A42:  MOVF   x93,W
0A44:  ADDWFC 03,F
0A46:  MOVF   01,W
0A48:  ADDLW  66
0A4A:  MOVWF  01
0A4C:  MOVLW  00
0A4E:  ADDWFC 03,F
0A50:  MOVFF  03,93
0A54:  CLRF   03
0A56:  MOVF   65,W
0A58:  ADDLW  81
0A5A:  MOVWF  FE9
0A5C:  MOVLW  00
0A5E:  ADDWFC 03,W
0A60:  MOVWF  FEA
0A62:  MOVFF  FEF,94
0A66:  MOVFF  93,FEA
0A6A:  MOVFF  01,FE9
0A6E:  MOVFF  94,FEF
0A72:  INCF   65,F
0A74:  BRA    0A2A
....................           }      
....................           memset(ROM_NO,0,8);  
0A76:  CLRF   FEA
0A78:  MOVLW  81
0A7A:  MOVWF  FE9
0A7C:  CLRF   00
0A7E:  CLRF   02
0A80:  MOVLW  08
0A82:  MOVWF  01
0A84:  RCALL  095A
....................           queue++; 
0A86:  INCF   3C,F
....................         }else 
0A88:  BRA    0A8C
....................           queue=0;    
0A8A:  CLRF   3C
....................    break;  
0A8C:  BRA    0AF6
....................     
....................    case 2: 
....................         if(Ow_Next()){    // Check for the first device  
0A8E:  RCALL  0974
0A90:  MOVF   01,F
0A92:  BZ    0AF4
....................           DevicesFound++;  // Increment the device found counter 
0A94:  INCF   3B,F
....................           for(i=0; i<8; i++){     
0A96:  CLRF   65
0A98:  MOVF   65,W
0A9A:  SUBLW  07
0A9C:  BNC   0AE4
....................              SlaveROM[queue][i]=ROM_NO[i];    
0A9E:  MOVF   3C,W
0AA0:  MULLW  09
0AA2:  MOVF   FF3,W
0AA4:  CLRF   x93
0AA6:  MOVWF  x92
0AA8:  CLRF   03
0AAA:  MOVF   65,W
0AAC:  ADDWF  x92,W
0AAE:  MOVWF  01
0AB0:  MOVF   x93,W
0AB2:  ADDWFC 03,F
0AB4:  MOVF   01,W
0AB6:  ADDLW  66
0AB8:  MOVWF  01
0ABA:  MOVLW  00
0ABC:  ADDWFC 03,F
0ABE:  MOVFF  03,93
0AC2:  CLRF   03
0AC4:  MOVF   65,W
0AC6:  ADDLW  81
0AC8:  MOVWF  FE9
0ACA:  MOVLW  00
0ACC:  ADDWFC 03,W
0ACE:  MOVWF  FEA
0AD0:  MOVFF  FEF,94
0AD4:  MOVFF  93,FEA
0AD8:  MOVFF  01,FE9
0ADC:  MOVFF  94,FEF
0AE0:  INCF   65,F
0AE2:  BRA    0A98
....................           }      
....................           memset(ROM_NO,0,8);  
0AE4:  CLRF   FEA
0AE6:  MOVLW  81
0AE8:  MOVWF  FE9
0AEA:  CLRF   00
0AEC:  CLRF   02
0AEE:  MOVLW  08
0AF0:  MOVWF  01
0AF2:  RCALL  095A
....................         }                                                                                                                                   
....................         queue=0; 
0AF4:  CLRF   3C
....................          //printf("\fROM1: %02X %02X %02X  %02X  %02X  %02X  %02X  %02X\r",SlaveROM1[0],SlaveROM1[1],SlaveROM1[2],SlaveROM1[3],SlaveROM1[4],SlaveROM1[5],SlaveROM1[6],SlaveROM1[7]);  
....................          //printf("ROM2: %02X %02X %02X  %02X  %02X  %02X  %02X  %02X\r",SlaveROM2[0],SlaveROM2[1],SlaveROM2[2],SlaveROM2[3],SlaveROM2[4],SlaveROM2[5],SlaveROM2[6],SlaveROM2[7]);   
....................          //printf("ROM2: %02X %02X %02X  %02X  %02X  %02X  %02X  %02X\r",SlaveROM3[0],SlaveROM3[1],SlaveROM3[2],SlaveROM3[3],SlaveROM3[4],SlaveROM3[5],SlaveROM3[6],SlaveROM3[7]);   
....................    break;  
....................    }                              
....................      
....................    if (DevicesFound == 0)              
0AF6:  MOVF   3B,F
0AF8:  BNZ   0B04
....................       printf("No devices found\r");                       
0AFA:  MOVLW  58
0AFC:  MOVWF  FF6
0AFE:  MOVLW  05
0B00:  MOVWF  FF7
0B02:  BRA    097A
0B04:  RETURN 0
....................         
.................... }       
....................                                    
....................  
....................                                                   
....................                                                   
.................... void ds1820_read_from_rom(uchar_t * SlaveROM11){  
....................    if(countt==0){ 
*
0C76:  MOVF   x8E,F
0C78:  BNZ   0CB0
....................    countt++; 
0C7A:  INCF   x8E,F
....................    
....................    onewire_reset();              // Onewire reset signal 
0C7C:  RCALL  0B90
....................    onewire_write(0x55);          // Issue command Match_ROM  
0C7E:  MOVLW  55
0C80:  MOVWF  x9A
0C82:  RCALL  0798
....................    for(i=0;i<8;i++){ 
0C84:  CLRF   65
0C86:  MOVF   65,W
0C88:  SUBLW  07
0C8A:  BNC   0CA8
....................       onewire_write(SlaveROM11[i]); 
0C8C:  CLRF   03
0C8E:  MOVF   65,W
0C90:  ADDWF  x92,W
0C92:  MOVWF  FE9
0C94:  MOVF   x93,W
0C96:  ADDWFC 03,W
0C98:  MOVWF  FEA
0C9A:  MOVFF  FEF,99
0C9E:  MOVFF  99,9A
0CA2:  RCALL  0798
0CA4:  INCF   65,F
0CA6:  BRA    0C86
....................    }                            
....................    onewire_write(0x44); 
0CA8:  MOVLW  44
0CAA:  MOVWF  x9A
0CAC:  RCALL  0798
....................    }else{  
0CAE:  BRA    0D32
....................    countt=0;  
0CB0:  CLRF   x8E
....................    uint8_t busy=0, temp1, temp2; 
....................    sint16_t temp3;  
0CB2:  CLRF   x94
....................    //while(busy == 0)                //Wait while busy (bus is low) 
....................      //   busy = onewire_read();  
....................    onewire_reset(); 
0CB4:  RCALL  0B90
....................    onewire_write(0x55);           
0CB6:  MOVLW  55
0CB8:  MOVWF  x9A
0CBA:  RCALL  0798
....................    for(i=0;i<8;i++){           
0CBC:  CLRF   65
0CBE:  MOVF   65,W
0CC0:  SUBLW  07
0CC2:  BNC   0CE0
....................       onewire_write(SlaveROM11[i]); 
0CC4:  CLRF   03
0CC6:  MOVF   65,W
0CC8:  ADDWF  x92,W
0CCA:  MOVWF  FE9
0CCC:  MOVF   x93,W
0CCE:  ADDWFC 03,W
0CD0:  MOVWF  FEA
0CD2:  MOVFF  FEF,99
0CD6:  MOVFF  99,9A
0CDA:  RCALL  0798
0CDC:  INCF   65,F
0CDE:  BRA    0CBE
....................    }  
....................    onewire_write(0xBE);   
0CE0:  MOVLW  BE
0CE2:  MOVWF  x9A
0CE4:  RCALL  0798
....................    temp1 = onewire_read();          
0CE6:  RCALL  0BB4
0CE8:  MOVFF  01,95
....................    temp2 = onewire_read();     
0CEC:  RCALL  0BB4
0CEE:  MOVFF  01,96
....................    temp3 = temp2;                  
0CF2:  CLRF   03
0CF4:  MOVFF  96,97
0CF8:  MOVFF  03,98
....................    temp3 = temp1 + (temp3 << 8); 
0CFC:  MOVFF  97,03
0D00:  MOVLW  00
0D02:  ADDWF  x95,W
0D04:  MOVWF  01
0D06:  MOVLW  00
0D08:  ADDWFC 03,F
0D0A:  MOVFF  01,97
0D0E:  MOVFF  03,98
....................    temp3 = (sint16_t) temp3 / 16; 
0D12:  MOVFF  98,9A
0D16:  MOVFF  97,99
0D1A:  CLRF   x9C
0D1C:  MOVLW  10
0D1E:  MOVWF  x9B
0D20:  BRA    0C00
0D22:  MOVFF  02,98
0D26:  MOVFF  01,97
....................    //result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
....................    tempHeat =temp3;  
0D2A:  MOVFF  98,5E
0D2E:  MOVFF  97,5D
....................    } 
0D32:  RETURN 0
.................... } 
....................                                                   
.................... /*                                              
....................  * ds1820_read()              
....................  * Description: reads the ds18x20 device on the 1-wire bus and returns 
....................  *              the temperature                                                   
....................  */ 
....................  
.................... void ds1820_read() {                                        
....................     uint8_t busy=0, temp1, temp2; 
....................     sint16_t temp3;  
....................                   
....................     //ds1820_configure(0x00, 0x00, 0x00);     //9 bit resolution 
....................  
....................     onewire_reset();                      
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
....................     onewire_write(0x44);            //Start temperature conversion 
....................  
....................     while(busy == 0)                //Wait while busy (bus is low) 
....................         busy = onewire_read();     
....................                    
....................     onewire_reset(); 
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
....................     onewire_write(0xBE);            //Read scratchpad      
....................      
....................        
....................     temp1 = onewire_read();          
....................     temp2 = onewire_read();  
....................                          
....................     temp3 = temp2; 
....................     temp3 = temp1 + (temp3 << 8); 
....................     temp3 = (sint16_t) temp3 / 16;                      
....................     //result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
....................     sprintf(TEMPBF,"TEMP :%Ld",temp3);  
....................     memset(strLCD,0,32); 
....................     memcpy(strLCD,TEMPBF,9);  
....................                     
.................... } 
....................      
.................... /* 
....................  * ds1820_configure(int8 TH, int8 LH, int8 config) 
....................  * Description: writes configuration data to the DS18x20 device 
....................  * Arguments: alarm trigger high, alarm trigger low, configuration 
....................  */                                                                                
....................  
.................... void ds1820_configure(int8 TH, int8 TL, int8 config) { 
....................     onewire_reset(); 
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
....................     onewire_write(0x4E);            //Write to scratchpad 
....................     onewire_write(TH); 
....................     onewire_write(TL); 
....................     onewire_write(config); 
.................... } 
....................  
....................  
.................... #endif /*DS1820_C*/                               
....................  
....................                     
....................  
....................                               
....................                                     
.................... //TIMER1 UNION STRUCTURE AND COUNT MS 
.................... tmr1_time_t tmr1_time;  
.................... uint16_t iSayac;  
.................... uchar_t period;  
....................  
.................... void setupTimerIOSC(void){          
....................    //Setup Osilator 
....................    IRCF2 = 1;   
*
063A:  BSF    FD3.6
....................    IRCF1 = 1; 
063C:  BSF    FD3.5
....................    IRCF0 = 1;                    
063E:  BSF    FD3.4
....................                          
....................    //D ve P portlari cikis olarak ayarlanip sifirlandi. 
....................    TRISB = 0x00;                  
0640:  CLRF   F93
....................    TRISD = 0x00; 
0642:  CLRF   F95
....................    TRISE = 0x00;       
0644:  CLRF   F96
....................    PORTB = 0x00;                                                       
0646:  CLRF   F81
....................    PORTD = 0x00; 
0648:  CLRF   F8C
....................    PORTE = 0x00;   
064A:  CLRF   F84
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
064C:  CLRF   18
....................  
....................    // Kesmelere izin verildi 
....................    RCON_IPEN = 1;                                               
064E:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 0;  
0650:  BCF    FF2.7
....................    INTCON_PEIE = 1;           
0652:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
0654:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
0656:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
0658:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit  
065A:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
065C:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
065E:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
0660:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
0662:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
0664:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
0666:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
0668:  MOVLW  F8
066A:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.     
066C:  MOVLW  30
066E:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit                                            
0670:  BSF    FCD.0
0672:  GOTO   0132 (RETURN)
.................... }           
....................                       
.................... void printOn2x16(){                   
....................    delayUsFun(40);                                                                                                                                       
*
06CA:  MOVLW  28
06CC:  MOVWF  x96
06CE:  RCALL  00DA
....................    twoLinesBCDMode();    
06D0:  BRA    0698
....................    LinesActive();   
06D2:  BRA    06A2
....................    lcdCursorOff(); 
06D4:  BRA    06AC
....................    lcdShiftRight();                      
06D6:  BRA    06B6
....................    lcdClear();                                                    
06D8:  BRA    06C0
....................    memcpy(strLCD, "INFORMELEKTRONIKAR-GE    STAJYER", 32);  
06DA:  CLRF   FEA
06DC:  MOVLW  19
06DE:  MOVWF  FE9
06E0:  MOVFF  FF2,92
06E4:  BCF    FF2.7
06E6:  MOVLW  20
06E8:  MOVWF  01
06EA:  CLRF   FF7
06EC:  MOVLW  00
06EE:  RCALL  051C
06F0:  TBLRD*-
06F2:  TBLRD*+
06F4:  MOVFF  FF5,FEE
06F8:  DECFSZ 01,F
06FA:  BRA    06F2
06FC:  BTFSC  x92.7
06FE:  BSF    FF2.7
....................    countLCDChar=0;    
0700:  CLRF   39
....................    LCDW1SecFlag=1; 
0702:  MOVLW  01
0704:  MOVWF  3A
0706:  GOTO   0134 (RETURN)
....................    // LCD_Custom_CHAR(7, legrandLCDCharacter); 
....................    //LCD_Custom_CHAR(6, stickManLCDCharacter);                                
.................... }                           
....................                                 
.................... void I2C_Init() {     
....................    SCL_DIR = 1;     //Set as a digital input 
....................    SDA_DIR = 1;     //Set as a digital input 
....................    SSPADD  = 19;  
....................    SSPCON1 = 0x28;  // enable I2C pins SCL and SDA for serial communication 
....................    //SSPCON2 = 0x00;   
....................    SSPSTAT = 0x80;  //slew rate disabled for high speed control       
.................... }                                               
....................  
....................  
.................... #INT_TIMER1                                                            
.................... void timer1_interrupt(){  
....................    TMR1H = 0xF8; //Tasma saayci| 
*
0574:  MOVLW  F8
0576:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.   
0578:  MOVLW  30
057A:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor.    
057C:  BCF    F9E.0
....................    iSayac++; 
057E:  INCF   16,F
0580:  BTFSC  FD8.2
0582:  INCF   17,F
....................  
....................    if (iSayac % 2 == 0)  //5ms   
0584:  MOVF   16,W
0586:  ANDLW  01
0588:  MOVWF  x9F
058A:  CLRF   xA0
058C:  MOVF   x9F,F
058E:  BNZ   0596
0590:  MOVF   xA0,F
0592:  BNZ   0596
....................       tmr1_time.tmr1_flags._2ms = true;   
0594:  BSF    18.0
....................    if (iSayac % 50 == 0)//50ms        
0596:  MOVFF  17,A0
059A:  MOVFF  16,9F
059E:  CLRF   xA2
05A0:  MOVLW  32
05A2:  MOVWF  xA1
05A4:  BRA    0096
05A6:  MOVFF  00,9F
05AA:  MOVFF  03,A0
05AE:  MOVF   x9F,F
05B0:  BNZ   05B8
05B2:  MOVF   xA0,F
05B4:  BNZ   05B8
....................       tmr1_time.tmr1_flags._20ms = true; 
05B6:  BSF    18.1
....................    if(iSayac >= 1000){    //1 Second 
05B8:  MOVF   17,W
05BA:  SUBLW  02
05BC:  BC    05CE
05BE:  XORLW  FF
05C0:  BNZ   05C8
05C2:  MOVF   16,W
05C4:  SUBLW  E7
05C6:  BC    05CE
....................       tmr1_time.tmr1_flags._1000ms = true;  
05C8:  BSF    18.6
....................       iSayac = 0;              
05CA:  CLRF   17
05CC:  CLRF   16
....................    }                                         
.................... }                              
....................                                    
05CE:  BCF    F9E.0
05D0:  GOTO   0054
.................... #ORG 0x0100,0x0400                                                                     
.................... void main(){           
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  MOVLW  70
0108:  MOVWF  FD3
010A:  MOVF   FD3,W
010C:  BCF    FB8.3
010E:  MOVLW  0C
0110:  MOVWF  FAF
0112:  MOVLW  A2
0114:  MOVWF  FAC
0116:  MOVLW  90
0118:  MOVWF  FAB
011A:  NOP   
011C:  NOP   
011E:  CLRF   x8E
0120:  CLRF   x90
0122:  CLRF   x8F
0124:  MOVF   FC1,W
0126:  ANDLW  C0
0128:  IORLW  0F
012A:  MOVWF  FC1
012C:  MOVLW  07
012E:  MOVWF  FB4
....................    setupTimerIOSC();                                                      
0130:  BRA    063A
....................    printOn2x16();                                                     
0132:  BRA    06CA
....................    //ds1820_read();   
....................    //I2C_Init();  
....................    //DS1307_Init();  
....................    period=0;  
0134:  CLRF   x91
....................    searchRom();   
0136:  CALL   099E
....................    searchRom(); 
013A:  CALL   099E
....................    searchRom();   
013E:  CALL   099E
....................    INTCON_GIE_GIEH = 1;  
0142:  BSF    FF2.7
....................    while (TRUE){                         
....................      WDTreset();          
0144:  GOTO   0B06
....................     
....................      if(tmr1_time.tmr1_flags._2ms){ 
0148:  BTFSS  18.0
014A:  BRA    0156
....................         tmr1_time.tmr1_flags._2ms = false;                                                                                               
014C:  BCF    18.0
....................         if(LCDW1SecFlag){      
014E:  MOVF   3A,F
0150:  BZ    0156
....................            LCD_String();                               
0152:  GOTO   0B58
....................         }                  
....................      }                  
....................      if(tmr1_time.tmr1_flags._20ms){ 
0156:  BTFSS  18.1
0158:  BRA    015C
....................         tmr1_time.tmr1_flags._20ms = false;      
015A:  BCF    18.1
....................         //ds1307_run(27,7,23,2,14,59,10); 
....................      }                                         
....................      if(tmr1_time.tmr1_flags._1000ms){                       
015C:  BTFSS  18.6
015E:  BRA    016C
....................         tmr1_time.tmr1_flags._1000ms = false;                                  
0160:  BCF    18.6
....................         PORTB_7=~PORTB_7;                          
0162:  BTG    F81.7
....................         multid18b20cal(); 
0164:  GOTO   0E60
....................         LCDW1SecFlag=1; 
0168:  MOVLW  01
016A:  MOVWF  3A
....................      }                  
016C:  BRA    0144
....................   }   
.................... }  
....................                            
016E:  SLEEP 
.................... void multid18b20cal(){              
....................    if(period<=5){                                        
*
0E60:  MOVF   x91,W
0E62:  SUBLW  05
0E64:  BTFSS  FD8.0
0E66:  BRA    1074
....................       INTCON_GIE_GIEH = 0;   
0E68:  BCF    FF2.7
....................       if(period==0||period==1){ 
0E6A:  MOVF   x91,F
0E6C:  BZ    0E72
0E6E:  DECFSZ x91,W
0E70:  BRA    0F18
....................          ds1820_read_from_rom(&SlaveROM[0]); 
0E72:  CLRF   x93
0E74:  MOVLW  66
0E76:  MOVWF  x92
0E78:  RCALL  0C76
....................          heat1 = tempHeat;  
0E7A:  MOVFF  5E,60
0E7E:  MOVFF  5D,5F
....................          if(period==1){   
0E82:  DECFSZ x91,W
0E84:  BRA    0F16
....................          sprintf(TEMPBF,"T1 :%Ld  T2: %Ld    T3: %Ld     ",heat1,heat2,heat3);  
0E86:  CLRF   x90
0E88:  MOVLW  3D
0E8A:  MOVWF  x8F
0E8C:  MOVLW  D4
0E8E:  MOVWF  FF6
0E90:  MOVLW  05
0E92:  MOVWF  FF7
0E94:  MOVLW  04
0E96:  MOVWF  x92
0E98:  RCALL  0D50
0E9A:  MOVLW  10
0E9C:  MOVWF  FE9
0E9E:  MOVFF  60,93
0EA2:  MOVFF  5F,92
0EA6:  RCALL  0D6E
0EA8:  MOVLW  DB
0EAA:  MOVWF  FF6
0EAC:  MOVLW  05
0EAE:  MOVWF  FF7
0EB0:  MOVLW  06
0EB2:  MOVWF  x92
0EB4:  RCALL  0D50
0EB6:  MOVLW  10
0EB8:  MOVWF  FE9
0EBA:  MOVFF  62,93
0EBE:  MOVFF  61,92
0EC2:  RCALL  0D6E
0EC4:  MOVLW  E4
0EC6:  MOVWF  FF6
0EC8:  MOVLW  05
0ECA:  MOVWF  FF7
0ECC:  MOVLW  08
0ECE:  MOVWF  x92
0ED0:  RCALL  0D50
0ED2:  MOVLW  10
0ED4:  MOVWF  FE9
0ED6:  MOVFF  64,93
0EDA:  MOVFF  63,92
0EDE:  RCALL  0D6E
0EE0:  MOVLW  EF
0EE2:  MOVWF  FF6
0EE4:  MOVLW  05
0EE6:  MOVWF  FF7
0EE8:  MOVLW  05
0EEA:  MOVWF  x92
0EEC:  RCALL  0D50
....................          memset(strLCD,0,32); 
0EEE:  CLRF   FEA
0EF0:  MOVLW  19
0EF2:  MOVWF  FE9
0EF4:  CLRF   00
0EF6:  CLRF   02
0EF8:  MOVLW  20
0EFA:  MOVWF  01
0EFC:  RCALL  095A
....................          memcpy(strLCD,TEMPBF,32);} 
0EFE:  CLRF   FEA
0F00:  MOVLW  19
0F02:  MOVWF  FE9
0F04:  CLRF   FE2
0F06:  MOVLW  3D
0F08:  MOVWF  FE1
0F0A:  MOVLW  20
0F0C:  MOVWF  01
0F0E:  MOVFF  FE6,FEE
0F12:  DECFSZ 01,F
0F14:  BRA    0F0E
....................       }else if(period==2||period==3){ 
0F16:  BRA    1072
0F18:  MOVF   x91,W
0F1A:  SUBLW  02
0F1C:  BZ    0F24
0F1E:  MOVF   x91,W
0F20:  SUBLW  03
0F22:  BNZ   0FCC
....................          ds1820_read_from_rom(&SlaveROM[1]);  
0F24:  CLRF   x93
0F26:  MOVLW  6F
0F28:  MOVWF  x92
0F2A:  RCALL  0C76
....................          heat2 = tempHeat;            
0F2C:  MOVFF  5E,62
0F30:  MOVFF  5D,61
....................          if(period==3){   
0F34:  MOVF   x91,W
0F36:  SUBLW  03
0F38:  BNZ   0FCA
....................          sprintf(TEMPBF,"T1 :%Ld  T2: %Ld    T3: %Ld     ",heat1,heat2,heat3);  
0F3A:  CLRF   x90
0F3C:  MOVLW  3D
0F3E:  MOVWF  x8F
0F40:  MOVLW  F6
0F42:  MOVWF  FF6
0F44:  MOVLW  05
0F46:  MOVWF  FF7
0F48:  MOVLW  04
0F4A:  MOVWF  x92
0F4C:  RCALL  0D50
0F4E:  MOVLW  10
0F50:  MOVWF  FE9
0F52:  MOVFF  60,93
0F56:  MOVFF  5F,92
0F5A:  RCALL  0D6E
0F5C:  MOVLW  FD
0F5E:  MOVWF  FF6
0F60:  MOVLW  05
0F62:  MOVWF  FF7
0F64:  MOVLW  06
0F66:  MOVWF  x92
0F68:  RCALL  0D50
0F6A:  MOVLW  10
0F6C:  MOVWF  FE9
0F6E:  MOVFF  62,93
0F72:  MOVFF  61,92
0F76:  RCALL  0D6E
0F78:  MOVLW  06
0F7A:  MOVWF  FF6
0F7C:  MOVLW  06
0F7E:  MOVWF  FF7
0F80:  MOVLW  08
0F82:  MOVWF  x92
0F84:  RCALL  0D50
0F86:  MOVLW  10
0F88:  MOVWF  FE9
0F8A:  MOVFF  64,93
0F8E:  MOVFF  63,92
0F92:  RCALL  0D6E
0F94:  MOVLW  11
0F96:  MOVWF  FF6
0F98:  MOVLW  06
0F9A:  MOVWF  FF7
0F9C:  MOVLW  05
0F9E:  MOVWF  x92
0FA0:  RCALL  0D50
....................          memset(strLCD,0,32); 
0FA2:  CLRF   FEA
0FA4:  MOVLW  19
0FA6:  MOVWF  FE9
0FA8:  CLRF   00
0FAA:  CLRF   02
0FAC:  MOVLW  20
0FAE:  MOVWF  01
0FB0:  RCALL  095A
....................          memcpy(strLCD,TEMPBF,32);}  
0FB2:  CLRF   FEA
0FB4:  MOVLW  19
0FB6:  MOVWF  FE9
0FB8:  CLRF   FE2
0FBA:  MOVLW  3D
0FBC:  MOVWF  FE1
0FBE:  MOVLW  20
0FC0:  MOVWF  01
0FC2:  MOVFF  FE6,FEE
0FC6:  DECFSZ 01,F
0FC8:  BRA    0FC2
....................       }else{ 
0FCA:  BRA    1072
....................          ds1820_read_from_rom(&SlaveROM[2]);  
0FCC:  CLRF   x93
0FCE:  MOVLW  78
0FD0:  MOVWF  x92
0FD2:  RCALL  0C76
....................          heat3 = tempHeat;    
0FD4:  MOVFF  5E,64
0FD8:  MOVFF  5D,63
....................          if(period==5){   
0FDC:  MOVF   x91,W
0FDE:  SUBLW  05
0FE0:  BNZ   1072
....................          sprintf(TEMPBF,"T1 :%Ld  T2: %Ld    T3: %Ld     ",heat1,heat2,heat3);  
0FE2:  CLRF   x90
0FE4:  MOVLW  3D
0FE6:  MOVWF  x8F
0FE8:  MOVLW  18
0FEA:  MOVWF  FF6
0FEC:  MOVLW  06
0FEE:  MOVWF  FF7
0FF0:  MOVLW  04
0FF2:  MOVWF  x92
0FF4:  RCALL  0D50
0FF6:  MOVLW  10
0FF8:  MOVWF  FE9
0FFA:  MOVFF  60,93
0FFE:  MOVFF  5F,92
1002:  RCALL  0D6E
1004:  MOVLW  1F
1006:  MOVWF  FF6
1008:  MOVLW  06
100A:  MOVWF  FF7
100C:  MOVLW  06
100E:  MOVWF  x92
1010:  RCALL  0D50
1012:  MOVLW  10
1014:  MOVWF  FE9
1016:  MOVFF  62,93
101A:  MOVFF  61,92
101E:  RCALL  0D6E
1020:  MOVLW  28
1022:  MOVWF  FF6
1024:  MOVLW  06
1026:  MOVWF  FF7
1028:  MOVLW  08
102A:  MOVWF  x92
102C:  RCALL  0D50
102E:  MOVLW  10
1030:  MOVWF  FE9
1032:  MOVFF  64,93
1036:  MOVFF  63,92
103A:  RCALL  0D6E
103C:  MOVLW  33
103E:  MOVWF  FF6
1040:  MOVLW  06
1042:  MOVWF  FF7
1044:  MOVLW  05
1046:  MOVWF  x92
1048:  RCALL  0D50
....................          memset(strLCD,0,32); 
104A:  CLRF   FEA
104C:  MOVLW  19
104E:  MOVWF  FE9
1050:  CLRF   00
1052:  CLRF   02
1054:  MOVLW  20
1056:  MOVWF  01
1058:  RCALL  095A
....................          memcpy(strLCD,TEMPBF,32);}  
105A:  CLRF   FEA
105C:  MOVLW  19
105E:  MOVWF  FE9
1060:  CLRF   FE2
1062:  MOVLW  3D
1064:  MOVWF  FE1
1066:  MOVLW  20
1068:  MOVWF  01
106A:  MOVFF  FE6,FEE
106E:  DECFSZ 01,F
1070:  BRA    106A
....................       }                        
....................       INTCON_GIE_GIEH = 1;   
1072:  BSF    FF2.7
....................       } period++; 
1074:  INCF   x91,F
....................    if(period>=60) 
1076:  MOVF   x91,W
1078:  SUBLW  3B
107A:  BC    107E
....................       period=0;                                 
107C:  CLRF   x91
107E:  GOTO   0168 (RETURN)
.................... } 
....................  
.................... void WDTreset(void){          
....................    #asm                   
*
0B06:  CLRWDT
....................    CLRWDT                           
....................    #endasm                                  
0B08:  GOTO   0148 (RETURN)
.................... }            
....................                                         

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 061E   PUT BROWNOUT BORV21 NOWDT WDT8
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
