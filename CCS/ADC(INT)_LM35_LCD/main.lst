CCS PCH C Compiler, Version 5.015, 5967               19-Jul-23 08:56

               Filename:   C:\18F4520\CCS\ADC_LM35-LCD\main.lst

               ROM used:   2416 bytes (7%)
                           Largest free fragment is 30158
               RAM used:   200 (13%) at main() level
                           220 (14%) worst case
               Stack used: 9 locations (5 in main + 4 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   0484
0054:  BTFSS  F9D.6
0056:  GOTO   0060
005A:  BTFSC  F9E.6
005C:  GOTO   00E6
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir. 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
00A2:  MOVFF  FF2,0D
00A6:  BCF    FF2.7
00A8:  CLRF   FF7
00AA:  ADDLW  BC
00AC:  MOVWF  FF6
00AE:  MOVLW  00
00B0:  ADDWFC FF7,F
00B2:  TBLRD*+
00B4:  MOVF   FF5,W
00B6:  BTFSC  0D.7
00B8:  BSF    FF2.7
00BA:  RETURN 0
00BC:  DATA 0C,4D
00BE:  DATA 45,56
00C0:  DATA 43,55
00C2:  DATA 54,20
00C4:  DATA 59,41
00C6:  DATA 5A,49
00C8:  DATA 3A,20
00CA:  DATA 00,00
00CC:  TSTFSZ 01
00CE:  BRA    00D6
00D0:  TSTFSZ 02
00D2:  BRA    00D8
00D4:  BRA    00E4
00D6:  INCF   02,F
00D8:  MOVFF  00,FEE
00DC:  DECFSZ 01,F
00DE:  BRA    00D8
00E0:  DECFSZ 02,F
00E2:  BRA    00D8
00E4:  RETURN 0
*
0202:  MOVFF  FF2,0D
0206:  BCF    FF2.7
0208:  CLRF   FF7
020A:  ADDLW  1C
020C:  MOVWF  FF6
020E:  MOVLW  02
0210:  ADDWFC FF7,F
0212:  TBLRD*+
0214:  MOVF   FF5,W
0216:  BTFSC  0D.7
0218:  BSF    FF2.7
021A:  RETURN 0
021C:  DATA 0D,4C
021E:  DATA 75,74
0220:  DATA 66,65
0222:  DATA 6E,20
0224:  DATA 62,69
0226:  DATA 72,20
0228:  DATA 79,61
022A:  DATA 7A,69
022C:  DATA 20,67
022E:  DATA 69,72
0230:  DATA 69,6E
0232:  DATA 69,7A
0234:  DATA 3A,20
0236:  DATA 00,00
0238:  MOVFF  FF2,0D
023C:  BCF    FF2.7
023E:  CLRF   FF7
0240:  ADDLW  52
0242:  MOVWF  FF6
0244:  MOVLW  02
0246:  ADDWFC FF7,F
0248:  TBLRD*+
024A:  MOVF   FF5,W
024C:  BTFSC  0D.7
024E:  BSF    FF2.7
0250:  RETURN 0
0252:  DATA 0D,4C
0254:  DATA 69,6D
0256:  DATA 69,74
0258:  DATA 20,41
025A:  DATA 73,69
025C:  DATA 6C,64
025E:  DATA 69,21
0260:  DATA 21,21
0262:  DATA 00,00
0264:  MOVFF  FF2,0D
0268:  BCF    FF2.7
026A:  CLRF   FF7
026C:  ADDLW  7E
026E:  MOVWF  FF6
0270:  MOVLW  02
0272:  ADDWFC FF7,F
0274:  TBLRD*+
0276:  MOVF   FF5,W
0278:  BTFSC  0D.7
027A:  BSF    FF2.7
027C:  RETURN 0
027E:  DATA 49,4E
0280:  DATA 46,4F
0282:  DATA 52,4D
0284:  DATA 45,4C
0286:  DATA 45,4B
0288:  DATA 54,52
028A:  DATA 4F,4E
028C:  DATA 49,4B
028E:  DATA 41,52
0290:  DATA 2D,47
0292:  DATA 45,20
0294:  DATA 20,20
0296:  DATA 20,53
0298:  DATA 54,41
029A:  DATA 4A,59
029C:  DATA 45,52
029E:  DATA 00,00
02A0:  DATA 54,45
02A2:  DATA 4D,50
02A4:  DATA 3A,25
02A6:  DATA 4C,75
02A8:  DATA 25,63
02AA:  DATA 43,20
02AC:  DATA 00,00
02AE:  MOVF   xD2,W
02B0:  MULWF  xD4
02B2:  MOVFF  FF3,01
02B6:  MOVFF  FF4,00
02BA:  MULWF  xD5
02BC:  MOVF   FF3,W
02BE:  ADDWF  00,F
02C0:  MOVF   xD3,W
02C2:  MULWF  xD4
02C4:  MOVF   FF3,W
02C6:  ADDWFC 00,W
02C8:  MOVWF  02
02CA:  GOTO   03F4 (RETURN)
02CE:  MOVFF  C7,FEA
02D2:  MOVFF  C6,FE9
02D6:  MOVFF  DB,FEF
02DA:  INCF   FE9,F
02DC:  BTFSC  FD8.2
02DE:  INCF   FEA,F
02E0:  CLRF   FEF
02E2:  INCF   xC6,F
02E4:  BTFSC  FD8.2
02E6:  INCF   xC7,F
02E8:  RETURN 0
02EA:  TBLRD*+
02EC:  MOVFF  FF6,D3
02F0:  MOVFF  FF7,D4
02F4:  MOVFF  FF5,DB
02F8:  RCALL  02CE
02FA:  MOVFF  D3,FF6
02FE:  MOVFF  D4,FF7
0302:  DECFSZ xD2,F
0304:  BRA    02EA
0306:  GOTO   041E (RETURN)
030A:  MOVFF  FEA,DA
030E:  MOVFF  FE9,D9
0312:  SWAPF  xD3,W
0314:  IORLW  F0
0316:  MOVWF  xD5
0318:  ADDWF  xD5,F
031A:  ADDLW  E2
031C:  MOVWF  xD6
031E:  ADDLW  32
0320:  MOVWF  xD8
0322:  MOVF   xD3,W
0324:  ANDLW  0F
0326:  ADDWF  xD6,F
0328:  ADDWF  xD6,F
032A:  ADDWF  xD8,F
032C:  ADDLW  E9
032E:  MOVWF  xD7
0330:  ADDWF  xD7,F
0332:  ADDWF  xD7,F
0334:  SWAPF  xD2,W
0336:  ANDLW  0F
0338:  ADDWF  xD7,F
033A:  ADDWF  xD8,F
033C:  RLCF   xD7,F
033E:  RLCF   xD8,F
0340:  COMF   xD8,F
0342:  RLCF   xD8,F
0344:  MOVF   xD2,W
0346:  ANDLW  0F
0348:  ADDWF  xD8,F
034A:  RLCF   xD5,F
034C:  MOVLW  07
034E:  MOVWF  xD4
0350:  MOVLW  0A
0352:  DECF   xD7,F
0354:  ADDWF  xD8,F
0356:  BNC   0352
0358:  DECF   xD6,F
035A:  ADDWF  xD7,F
035C:  BNC   0358
035E:  DECF   xD5,F
0360:  ADDWF  xD6,F
0362:  BNC   035E
0364:  DECF   xD4,F
0366:  ADDWF  xD5,F
0368:  BNC   0364
036A:  CLRF   FEA
036C:  MOVLW  D4
036E:  MOVWF  FE9
0370:  MOVLW  07
0372:  ANDWF  xD9,W
0374:  BCF    xD9.6
0376:  ADDWF  FE9,F
0378:  MOVLW  00
037A:  ADDWFC FEA,F
037C:  MOVF   FE9,W
037E:  SUBLW  D8
0380:  BNZ   0388
0382:  MOVF   FEA,F
0384:  BNZ   0388
0386:  BSF    xD9.6
0388:  MOVF   FEF,W
038A:  MOVWF  00
038C:  BNZ   039E
038E:  BTFSC  xD9.6
0390:  BRA    039E
0392:  BTFSC  xD9.4
0394:  BRA    03BC
0396:  BTFSC  xD9.3
0398:  BRA    039E
039A:  MOVLW  20
039C:  BRA    03A4
039E:  BSF    xD9.3
03A0:  BCF    xD9.4
03A2:  MOVLW  30
03A4:  ADDWF  00,F
03A6:  MOVFF  FEA,D3
03AA:  MOVFF  FE9,D2
03AE:  MOVFF  00,DB
03B2:  RCALL  02CE
03B4:  MOVFF  D3,FEA
03B8:  MOVFF  D2,FE9
03BC:  MOVF   FEE,W
03BE:  BTFSS  xD9.6
03C0:  BRA    037C
03C2:  GOTO   042C (RETURN)
*
0442:  CLRF   01
0444:  CLRF   02
0446:  CLRF   00
0448:  CLRF   03
044A:  MOVF   xD1,W
044C:  BNZ   0452
044E:  MOVF   xD0,W
0450:  BZ    0482
0452:  MOVLW  10
0454:  MOVWF  xD2
0456:  BCF    FD8.0
0458:  RLCF   xCE,F
045A:  RLCF   xCF,F
045C:  RLCF   00,F
045E:  RLCF   03,F
0460:  MOVF   xD1,W
0462:  SUBWF  03,W
0464:  BNZ   046A
0466:  MOVF   xD0,W
0468:  SUBWF  00,W
046A:  BNC   047A
046C:  MOVF   xD0,W
046E:  SUBWF  00,F
0470:  BTFSS  FD8.0
0472:  DECF   03,F
0474:  MOVF   xD1,W
0476:  SUBWF  03,F
0478:  BSF    FD8.0
047A:  RLCF   01,F
047C:  RLCF   02,F
047E:  DECFSZ xD2,F
0480:  BRA    0456
0482:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanýr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       Â· LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       Â· WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini saðlar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       Â· PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin içine yükleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       Â· PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       Â· BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       Â· INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       Â· NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */                          
....................                                           
.................... #FUSES WDT, WDT4, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC  
....................                               
....................                                                             
....................                                      
.................... #include "definitions.h"                                                                                                       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "main.h"                  
.................... #ifndef MAIN_H      
.................... #define MAIN_H  
.................... #define DELAY 500  
....................                             
.................... extern uint16_t iSayac;                             
....................                      
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"                                     
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0  
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6 
.................... #bit  TRISC_7=TRISC.7   
....................  
.................... #bit  DS1820=PORTC.0   
.................... #bit  DS1820_DIR=TRISC.0   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  // 
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6 
.................... #bit  ADIF   = PIR1.6 
....................  
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h"                                       
.................... #ifndef INITS_H 
.................... #define INITS_H       
....................  
.................... extern uint16_t iSayac;                          
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _1ms    : 1;  //bit:0, 1ms  
....................       uint8_t _20ms   : 1;  //bit:2, 20ms  
....................       uint8_t _50ms   : 1;  //bit:3, 50ms  
....................       uint8_t _100ms  : 1;  //bit:4, 100ms     
....................       uint8_t _200ms  : 1;  //bit:5, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:6, 500ms  
....................       uint8_t _1000ms : 1;  //bit:7, 1000ms  
....................       uint8_t reserved     : 1; 
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t   tmr1_time;    
....................  
....................                                                 
.................... #endif //INIT_H                               
....................  
.................... #include "button.h"                   
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS;  
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t); 
....................    
.................... #endif            
....................  
.................... #include "usart_rs232.h"                          
.................... #ifndef USART_RS232_H                                                                                                
.................... #define USART_RS232_H    
....................   
.................... extern uchar_t rxData[32]; 
.................... extern uchar_t txData[32]; 
.................... extern uchar_t data_in; 
.................... extern uint8_t rxData_count; 
.................... extern uchar_t terminal_text1[15];                 
.................... extern uchar_t terminal_text2[27];                               
.................... extern uchar_t terminal_text3[17];       
.................... extern uint8_t terminal_text1_Count,terminal_text2_Count,terminal_text3_Count,terminal_text4_Count; 
.................... extern uint8_t terminal_text1_size,terminal_text2_size ,terminal_text3_size,terminal_text4_size;  
.................... extern uint8_t noKbHit_count;   
.................... extern uint8_t switchTerminal_position;   
.................... extern uint8_t UART_BUSY; 
....................  
....................                                    
.................... typedef union{                  
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{  
....................       uint8_t noKbhit              : 1;  //bit:0, no data for 5 seconds   
....................       uint8_t enter_flag           : 1;  //bit:1, Text executed / Texts are cleared,                                     
....................       uint8_t recieve_exceed       : 1;  //bit:2, LCD- character exceed / 1-Exceed 
....................       uint8_t terminal_text1_flag  : 1;  //bit:3, Text 1 write / 1-DONE  //MEVCUT YAZI  
....................       uint8_t terminal_text2_flag  : 1;  //bit:4, Text 2 write / 1-DONE  //Lutfen bir yazi giriniz:             
....................       uint8_t terminal_text3_flag  : 1;  //bit:5, Text 3 write / 1-DONE  //Limit Asildi!!! 
....................       uint8_t terminal_text4_flag  : 1;  //bit:6, Text 4 write / 1-DONE  //LCD 
....................       uint8_t terminal_text_done   : 1;  //bit:6, Texts are DONE / 1-DONE      
....................    }stUSARTF;                                       
.................... }unUSARTF_t;    
.................... extern unUSARTF_t unUSARTF;     
....................  
.................... uchar_t USART_RxCharBuffer(); 
.................... void USART_TxCharBuffer(); 
.................... void USART_Init(); 
.................... void rs232t();     
....................                                                    
.................... #endif  //USART_RS232_H 
....................                   
....................  
....................                             
.................... #include "lcd.h"   
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "lcd.c"                         
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0  
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6 
.................... #bit  TRISC_7=TRISC.7   
....................  
.................... #bit  DS1820=PORTC.0   
.................... #bit  DS1820_DIR=TRISC.0   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  // 
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6 
.................... #bit  ADIF   = PIR1.6 
....................  
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "button.h" 
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS;  
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t); 
....................    
.................... #endif            
....................  
.................... #include "delayms.h"  
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................  
....................                
.................... /*Hex Code   LCD Ekran Karsiligi  
....................  Initialize Lcd in 4-bit mode               0x02 
.................... 1   Function Set: 8-bit, 1 Line, 5×7 Dots   0x30   48                                              
.................... 2   Function Set: 8-bit, 2 Line, 5×7 Dots   0x38   56                            
.................... 3   Function Set: 4-bit, 1 Line, 5×7 Dots   0x20   32 
.................... 4   Function Set: 4-bit, 2 Line, 5×7 Dots   0x28   40  
.................... 0F   LCD acik, Imlec acik 
.................... 01   Ekrani Temizle                                 
.................... 02   Satir Basina Dön            
.................... 04   Imleci Sola Kaydir 
.................... 06   Imleci Saga Kaydir 
.................... 05   Ekrani Saga Kaydir 
.................... 07   Ekrani Sola Kaydir 
.................... 0E   Ekran Acik, Imleç Yanip Sonuyor 
.................... 80   Imleci Ilk Satirin Basinda Konumlandir 
.................... C0   Imleci Ikinci Satirin Basinda Konumlandir         
.................... 3C   Ikinci Satiri Etkinlestir                                                     
.................... 08   Ekran Kapali, Imleç Kapali              
.................... OC   Ekran Acik, Imlec Kapali*/   
....................                                             
.................... uchar_t strLCD[32]; 
.................... uint8_t countLCDChar; 
....................                                          
.................... /*LCD (CHIP: HD44780), COMMAND MODE*/  
.................... void dis_cmd(uchar_t cmdout){  
....................    PORTD=cmdout;      //Send command to lcdport=PORTB 
*
057C:  MOVFF  CA,F8C
....................    PORTE_RS=0;                   
0580:  BCF    F84.0
....................    PORTE_E=1;                
0582:  BSF    F84.1
....................    delayUsFun(1); 
0584:  MOVLW  01
0586:  MOVWF  xCC
0588:  RCALL  056E
....................    PORTE_E=0;                               
058A:  BCF    F84.1
058C:  RETURN 0
.................... }                                   
....................  
....................  
....................  
.................... void lcdcmd(uchar_t cmd_value){          
....................    uchar_t cmd_value1;                              
....................    cmd_value1 = (cmd_value & 0xF0);      // Mask lower nibble because RB4-RB7 pins are being used    
058E:  MOVF   xC8,W
0590:  ANDLW  F0
0592:  MOVWF  xC9
....................    dis_cmd(cmd_value1);                   // Send to LCD 
0594:  MOVFF  C9,CA
0598:  RCALL  057C
....................    cmd_value1 = ((cmd_value<<4) & 0xF0);  // Shift 4-bit and mask 
059A:  SWAPF  xC8,W
059C:  MOVWF  00
059E:  MOVLW  F0
05A0:  ANDWF  00,F
05A2:  MOVF   00,W
05A4:  ANDLW  F0
05A6:  MOVWF  xC9
....................    dis_cmd(cmd_value1);                   // Send to LCD 
05A8:  MOVFF  C9,CA
05AC:  RCALL  057C
05AE:  RETURN 0
.................... } 
....................  // 2 lines are active.              
.................... void twoLinesBCDMode(){  
....................    lcdcmd(0x02); 
05B0:  MOVLW  02
05B2:  MOVWF  xC8
05B4:  RCALL  058E
05B6:  GOTO   05EA (RETURN)
.................... } 
....................                         
.................... // 2 lines are active. BCD MODE 
.................... void LinesActive(){  
....................    lcdcmd(0x28);                
05BA:  MOVLW  28
05BC:  MOVWF  xC8
05BE:  RCALL  058E
05C0:  GOTO   05EC (RETURN)
.................... }                          
.................... // LCD screen clear.                   
.................... void lcdClear(){ 
....................    lcdcmd(0x01);                   
*
05D8:  MOVLW  01
05DA:  MOVWF  xC8
05DC:  RCALL  058E
05DE:  GOTO   05F2 (RETURN)
.................... }                   
.................... // Go to first line. 
.................... void lcdGoToFirstLine(){  
....................    lcdcmd(0x80); 
*
073C:  MOVLW  80
073E:  MOVWF  xC8
0740:  RCALL  058E
0742:  GOTO   078C (RETURN)
.................... }                                  
.................... // Go to second line.                        
.................... void lcdGoToSecondLine(){ 
....................    lcdcmd(0xC0); 
0746:  MOVLW  C0
0748:  MOVWF  xC8
074A:  RCALL  058E
074C:  GOTO   0794 (RETURN)
.................... }                        
.................... // Shift cursor to right. 
.................... void lcdShiftRight(){   
....................    lcdcmd(0x06);                                                     
*
05CE:  MOVLW  06
05D0:  MOVWF  xC8
05D2:  RCALL  058E
05D4:  GOTO   05F0 (RETURN)
.................... }                                           
.................... // Display on, Cursor on              
.................... void lcdCursorOn(){                  
....................    lcdcmd(0x0E); 
.................... }                                      
.................... //Display off, Cursor off 
.................... void lcdCursorOff(){                                             
....................    lcdcmd(0x0C);                             
*
05C4:  MOVLW  0C
05C6:  MOVWF  xC8
05C8:  RCALL  058E
05CA:  GOTO   05EE (RETURN)
.................... }                              
....................   
.................... void dis_data(uchar_t dataout) {  
....................    PORTD=dataout;   //Send data to lcdport=PORTB 
*
0750:  MOVFF  CB,F8C
....................    PORTE_RS=1;                   
0754:  BSF    F84.0
....................    PORTE_E=1;                          
0756:  BSF    F84.1
....................    delayUsFun(1); 
0758:  MOVLW  01
075A:  MOVWF  xCC
075C:  RCALL  056E
....................    PORTE_E=0;   
075E:  BCF    F84.1
0760:  RETURN 0
....................    //PORTD=0x00; 
....................    //while(test_bit(PORTD,7));           
.................... }   
.................... /*DATA MODE*/   
.................... void lcddata(uchar_t text){  
....................    uchar_t data;                                                                 
....................    data=(text & 0xF0);         
0762:  MOVF   xC9,W
0764:  ANDLW  F0
0766:  MOVWF  xCA
....................    dis_data(data);     
0768:  MOVFF  CA,CB
076C:  RCALL  0750
....................    data=((text<<4)&0xF0);      
076E:  SWAPF  xC9,W
0770:  MOVWF  00
0772:  MOVLW  F0
0774:  ANDWF  00,F
0776:  MOVF   00,W
0778:  ANDLW  F0
077A:  MOVWF  xCA
....................    dis_data(data);                  
077C:  MOVFF  CA,CB
0780:  RCALL  0750
0782:  GOTO   07B2 (RETURN)
.................... }                                
.................... void LCD_String(){  
....................    if(countLCDChar==0)  
0786:  MOVF   xC5,F
0788:  BNZ   078C
....................       lcdGoToFirstLine(); 
078A:  BRA    073C
....................    if(countLCDChar==16)   
078C:  MOVF   xC5,W
078E:  SUBLW  10
0790:  BNZ   0794
....................       lcdGoToSecondLine();    
0792:  BRA    0746
....................    if(countLCDChar<=31){  
0794:  MOVF   xC5,W
0796:  SUBLW  1F
0798:  BNC   07B6
....................       lcddata(strLCD[countLCDChar]); 
079A:  CLRF   03
079C:  MOVF   xC5,W
079E:  ADDLW  A5
07A0:  MOVWF  FE9
07A2:  MOVLW  00
07A4:  ADDWFC 03,W
07A6:  MOVWF  FEA
07A8:  MOVFF  FEF,C8
07AC:  MOVFF  C8,C9
07B0:  BRA    0762
....................       countLCDChar++;   
07B2:  INCF   xC5,F
....................    }else{ 
07B4:  BRA    07B8
....................       countLCDChar=0; 
07B6:  CLRF   xC5
....................    }                  
07B8:  GOTO   0142 (RETURN)
.................... }  
....................  
....................  
.................... void LCD_Custom_Char(uchar_t loc, uchar_t *msg){ 
....................     uchar_t i; 
....................     if(loc<8) 
....................     { 
....................      lcdcmd(0x40 + (loc*8));    /* Command 0x40 and onwards forces the device to point CGRAM address */ 
....................      for(i=0;i<8;i++)          /* Write 8 byte for generation of 1 character */ 
....................         lcddata(msg[i]);       
....................     }                        
.................... } 
....................  
....................                                           
....................  
....................       
....................  
.................... #include "button.c"           
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "button.h" 
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS;  
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t); 
....................    
.................... #endif            
....................  
.................... uint8_t BUTTON_PRESSED_RELEASED; 
.................... uint8_t STATUS=0;             
....................  
.................... uint8_t test_bit(uint8_t valueOfInput, uint8_t bits){  
....................    return ((valueOfInput & (1<<bits)) != 0); 
*
06D4:  MOVLW  01
06D6:  MOVWF  00
06D8:  MOVF   xCB,W
06DA:  MOVWF  01
06DC:  BZ    06E6
06DE:  BCF    FD8.0
06E0:  RLCF   00,F
06E2:  DECFSZ 01,F
06E4:  BRA    06DE
06E6:  MOVF   00,W
06E8:  ANDWF  xCA,W
06EA:  BNZ   06F0
06EC:  MOVLW  00
06EE:  BRA    06F2
06F0:  MOVLW  01
06F2:  MOVWF  01
06F4:  GOTO   0702 (RETURN)
.................... }                             
....................   
.................... uint8_t button_debounce(uint8_t valueOfInput, uint8_t bit){ 
....................    if(!test_bit(valueOfInput,bit)){ 
06F8:  MOVFF  C8,CA
06FC:  MOVFF  C9,CB
0700:  BRA    06D4
0702:  MOVF   01,F
0704:  BNZ   070C
....................       BUTTON_PRESSED_RELEASED<<=1; 
0706:  BCF    FD8.0
0708:  RLCF   1A,F
....................    }else{                        
070A:  BRA    0712
....................       BUTTON_PRESSED_RELEASED<<=1;                        
070C:  BCF    FD8.0
070E:  RLCF   1A,F
....................       BUTTON_PRESSED_RELEASED|=1;           
0710:  BSF    1A.0
....................    }   
....................    if((BUTTON_PRESSED_RELEASED & 0x07)==0x07){  
0712:  MOVF   1A,W
0714:  ANDLW  07
0716:  SUBLW  07
0718:  BNZ   0724
....................       STATUS = 1; 
071A:  MOVLW  01
071C:  MOVWF  1B
....................       return true;   
071E:  MOVWF  01
0720:  BRA    0738
....................    }else if((BUTTON_PRESSED_RELEASED  & 0x07)==0x00){  
0722:  BRA    0738
0724:  MOVF   1A,W
0726:  ANDLW  07
0728:  BNZ   0734
....................       STATUS = 0; 
072A:  CLRF   1B
....................       return false; 
072C:  MOVLW  00
072E:  MOVWF  01
0730:  BRA    0738
....................    }else{  
0732:  BRA    0738
....................       return STATUS; 
0734:  MOVFF  1B,01
....................    } 
0738:  GOTO   013A (RETURN)
.................... }         
....................  
....................  
.................... #include "delayms.c"         
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs){  // Delay function - generates a delay of specified msecs 
....................    unsigned int i,j; 
....................    for(i=0;i<=msecs;i++) 
....................    for(j=0;j<81;j++); /*This count Provide delay of 1 ms for 8MHz Frequency */                              
.................... }        
....................  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
*
056E:  CLRF   xCD
0570:  MOVF   xCD,W
0572:  SUBWF  xCC,W
0574:  BNC   057A
0576:  INCF   xCD,F
0578:  BRA    0570
....................     }                                
057A:  RETURN 0
.................... }   
....................  
....................  
.................... #include "usart_rs232.c"        
.................... #include "ucregisters.h"                                                                                              
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0  
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6 
.................... #bit  TRISC_7=TRISC.7   
....................  
.................... #bit  DS1820=PORTC.0   
.................... #bit  DS1820_DIR=TRISC.0   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  // 
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6 
.................... #bit  ADIF   = PIR1.6 
....................  
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "usart_rs232.h" 
.................... #ifndef USART_RS232_H                                                                                                
.................... #define USART_RS232_H    
....................   
.................... extern uchar_t rxData[32]; 
.................... extern uchar_t txData[32]; 
.................... extern uchar_t data_in; 
.................... extern uint8_t rxData_count; 
.................... extern uchar_t terminal_text1[15];                 
.................... extern uchar_t terminal_text2[27];                               
.................... extern uchar_t terminal_text3[17];       
.................... extern uint8_t terminal_text1_Count,terminal_text2_Count,terminal_text3_Count,terminal_text4_Count; 
.................... extern uint8_t terminal_text1_size,terminal_text2_size ,terminal_text3_size,terminal_text4_size;  
.................... extern uint8_t noKbHit_count;   
.................... extern uint8_t switchTerminal_position;   
.................... extern uint8_t UART_BUSY; 
....................  
....................                                    
.................... typedef union{                  
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{  
....................       uint8_t noKbhit              : 1;  //bit:0, no data for 5 seconds   
....................       uint8_t enter_flag           : 1;  //bit:1, Text executed / Texts are cleared,                                     
....................       uint8_t recieve_exceed       : 1;  //bit:2, LCD- character exceed / 1-Exceed 
....................       uint8_t terminal_text1_flag  : 1;  //bit:3, Text 1 write / 1-DONE  //MEVCUT YAZI  
....................       uint8_t terminal_text2_flag  : 1;  //bit:4, Text 2 write / 1-DONE  //Lutfen bir yazi giriniz:             
....................       uint8_t terminal_text3_flag  : 1;  //bit:5, Text 3 write / 1-DONE  //Limit Asildi!!! 
....................       uint8_t terminal_text4_flag  : 1;  //bit:6, Text 4 write / 1-DONE  //LCD 
....................       uint8_t terminal_text_done   : 1;  //bit:6, Texts are DONE / 1-DONE      
....................    }stUSARTF;                                       
.................... }unUSARTF_t;    
.................... extern unUSARTF_t unUSARTF;     
....................  
.................... uchar_t USART_RxCharBuffer(); 
.................... void USART_TxCharBuffer(); 
.................... void USART_Init(); 
.................... void rs232t();     
....................                                                    
.................... #endif  //USART_RS232_H 
....................                   
....................  
....................  
.................... uchar_t rxData[32]; 
.................... uchar_t txData[32]; 
.................... uchar_t data_in; 
.................... uint8_t rxData_count;  
.................... unUSARTF_t unUSARTF;        
.................... uchar_t terminal_text1[15];  
.................... uchar_t terminal_text2[27];                               
.................... uchar_t terminal_text3[17];    
.................... uint8_t terminal_text1_Count,terminal_text2_Count ,terminal_text3_Count,terminal_text4_Count;  
.................... uint8_t terminal_text1_size,terminal_text2_size ,terminal_text3_size,terminal_text4_size;  
.................... uint8_t noKbHit_count;     
.................... uint8_t switchTerminal_position;   
.................... uint8_t UART_BUSY;  
....................  
....................   
....................                
.................... void USART_Init(){  
....................  
....................    TRISC_6=0;        // Make Tx pin as output    
*
061E:  BCF    F94.6
....................    TRISC_7=1;        // Make Rx pin as input                                                                   
0620:  BSF    F94.7
....................    //Baud rate=9600, SPBRG = (F_CPU /(64*9600))-1         
....................    SPBRG = 0x0C;                       
0622:  MOVLW  0C
0624:  MOVWF  FAF
....................    TXSTA = 0x20;     // Enable Transmit(TX)   
0626:  MOVLW  20
0628:  MOVWF  FAC
....................    RCSTA = 0x90;     // Enable Receive(RX) & Serial 
062A:  MOVLW  90
062C:  MOVWF  FAB
....................         
....................    terminal_text1_size=sizeof(terminal_text1)/sizeof(terminal_text1[0]); 
062E:  MOVLW  0F
0630:  MOVWF  x9D
....................    terminal_text2_size=sizeof(terminal_text2)/sizeof(terminal_text2[0]);   
0632:  MOVLW  1B
0634:  MOVWF  x9E
....................    terminal_text3_size=sizeof(terminal_text3)/sizeof(terminal_text3[0]); 
0636:  MOVLW  11
0638:  MOVWF  x9F
....................    terminal_text4_size=32;                             
063A:  MOVLW  20
063C:  MOVWF  xA0
....................    memcpy(terminal_text1,"\fMEVCUT YAZI: ",terminal_text1_size);   
063E:  CLRF   FEA
0640:  MOVLW  5E
0642:  MOVWF  FE9
0644:  MOVFF  FF2,C8
0648:  BCF    FF2.7
064A:  MOVF   x9D,W
064C:  MOVWF  01
064E:  BZ    0666
0650:  CLRF   FF7
0652:  MOVLW  00
0654:  RCALL  00A2
0656:  TBLRD*-
0658:  TBLRD*+
065A:  MOVFF  FF5,FEE
065E:  DECFSZ 01,F
0660:  BRA    0658
0662:  BTFSC  xC8.7
0664:  BSF    FF2.7
....................    memcpy(terminal_text2,"\rLutfen bir yazi giriniz: ",terminal_text2_size);   
0666:  CLRF   FEA
0668:  MOVLW  6D
066A:  MOVWF  FE9
066C:  MOVFF  FF2,C8
0670:  BCF    FF2.7
0672:  MOVF   x9E,W
0674:  MOVWF  01
0676:  BZ    068E
0678:  CLRF   FF7
067A:  MOVLW  00
067C:  RCALL  0202
067E:  TBLRD*-
0680:  TBLRD*+
0682:  MOVFF  FF5,FEE
0686:  DECFSZ 01,F
0688:  BRA    0680
068A:  BTFSC  xC8.7
068C:  BSF    FF2.7
....................    memcpy(terminal_text3,"\rLimit Asildi!!!",terminal_text3_size);   
068E:  CLRF   FEA
0690:  MOVLW  88
0692:  MOVWF  FE9
0694:  MOVFF  FF2,C8
0698:  BCF    FF2.7
069A:  MOVF   x9F,W
069C:  MOVWF  01
069E:  BZ    06B6
06A0:  CLRF   FF7
06A2:  MOVLW  00
06A4:  RCALL  0238
06A6:  TBLRD*-
06A8:  TBLRD*+
06AA:  MOVFF  FF5,FEE
06AE:  DECFSZ 01,F
06B0:  BRA    06A8
06B2:  BTFSC  xC8.7
06B4:  BSF    FF2.7
06B6:  GOTO   0120 (RETURN)
.................... }       
....................      
....................  
.................... uchar_t USART_RxCharBuffer(){ 
....................     if(RCIF_PIR1==1){         //wait for receive interrupt flag    
*
07BC:  BTFSS  F9E.5
07BE:  BRA    07C4
....................     return(RCREG);           //received in RCREG register and return to main program  
07C0:  MOVFF  FAE,01
....................     } 
07C4:  GOTO   07CE (RETURN)
.................... }                           
....................                                            
.................... void USART_TxCharBuffer(uint8_t textIndex_charIndex){                 
....................    if(OERR_RCSTA){               
*
085A:  BTFSS  FAB.1
085C:  BRA    0864
....................       CREN_RCSTA = 0;         
085E:  BCF    FAB.4
....................       #ASM NOP #ENDASM 
0860:  NOP   
....................       CREN_RCSTA=1; 
0862:  BSF    FAB.4
....................    }                                    
....................    TXREG = txData[textIndex_charIndex];             //Write char data to transmit register 
0864:  CLRF   03
0866:  MOVF   xCA,W
0868:  ADDLW  3C
086A:  MOVWF  FE9
086C:  MOVLW  00
086E:  ADDWFC 03,W
0870:  MOVWF  FEA
0872:  MOVFF  FEF,FAD
....................    TXIF_PIR1=0; 
0876:  BCF    F9E.4
0878:  GOTO   0914 (RETURN)
.................... }                    
....................                                                          
.................... void rs232t_txText(uint8_t text_index, uint8_t textIndex_charIndex){ 
....................     if(text_index==0&&textIndex_charIndex==0){                                    
087C:  MOVF   xC8,F
087E:  BNZ   08A0
0880:  MOVF   xC9,F
0882:  BNZ   08A0
....................       memcpy(txData, terminal_text1, terminal_text1_size);   
0884:  CLRF   FEA
0886:  MOVLW  3C
0888:  MOVWF  FE9
088A:  CLRF   FE2
088C:  MOVLW  5E
088E:  MOVWF  FE1
0890:  MOVF   x9D,W
0892:  MOVWF  01
0894:  BZ    089E
0896:  MOVFF  FE6,FEE
089A:  DECFSZ 01,F
089C:  BRA    0896
....................     }else if(text_index==1&&textIndex_charIndex==0){ 
089E:  BRA    090E
08A0:  DECFSZ xC8,W
08A2:  BRA    08C4
08A4:  MOVF   xC9,F
08A6:  BNZ   08C4
....................       memcpy(txData, terminal_text2, terminal_text2_size);    
08A8:  CLRF   FEA
08AA:  MOVLW  3C
08AC:  MOVWF  FE9
08AE:  CLRF   FE2
08B0:  MOVLW  6D
08B2:  MOVWF  FE1
08B4:  MOVF   x9E,W
08B6:  MOVWF  01
08B8:  BZ    08C2
08BA:  MOVFF  FE6,FEE
08BE:  DECFSZ 01,F
08C0:  BRA    08BA
....................     }else if(text_index==2&&textIndex_charIndex==0){             
08C2:  BRA    090E
08C4:  MOVF   xC8,W
08C6:  SUBLW  02
08C8:  BNZ   08EA
08CA:  MOVF   xC9,F
08CC:  BNZ   08EA
....................       memcpy(txData, terminal_text3, terminal_text3_size);   
08CE:  CLRF   FEA
08D0:  MOVLW  3C
08D2:  MOVWF  FE9
08D4:  CLRF   FE2
08D6:  MOVLW  88
08D8:  MOVWF  FE1
08DA:  MOVF   x9F,W
08DC:  MOVWF  01
08DE:  BZ    08E8
08E0:  MOVFF  FE6,FEE
08E4:  DECFSZ 01,F
08E6:  BRA    08E0
....................     }else if(text_index==3&&textIndex_charIndex==0){              
08E8:  BRA    090E
08EA:  MOVF   xC8,W
08EC:  SUBLW  03
08EE:  BNZ   090E
08F0:  MOVF   xC9,F
08F2:  BNZ   090E
....................       memcpy(txData, strLCD, terminal_text4_size);    
08F4:  CLRF   FEA
08F6:  MOVLW  3C
08F8:  MOVWF  FE9
08FA:  CLRF   FE2
08FC:  MOVLW  A5
08FE:  MOVWF  FE1
0900:  MOVF   xA0,W
0902:  MOVWF  01
0904:  BZ    090E
0906:  MOVFF  FE6,FEE
090A:  DECFSZ 01,F
090C:  BRA    0906
....................     }                                        
....................     USART_TxCharBuffer(textIndex_charIndex);   
090E:  MOVFF  C9,CA
0912:  BRA    085A
0914:  RETURN 0
....................                                                                                                                   
.................... }                                                
....................                                  
.................... void rs232t(){    
....................       unUSARTF.stUSARTF.noKbhit=0; 
*
07C8:  BCF    xA4.0
....................       noKbHit_count=0;                        
07CA:  CLRF   xA1
....................       data_in=USART_RxCharBuffer();                  
07CC:  BRA    07BC
07CE:  MOVFF  01,5C
....................       if(data_in==8 && rxData_count>0){                                                  
07D2:  MOVF   5C,W
07D4:  SUBLW  08
07D6:  BNZ   07F0
07D8:  MOVF   5D,F
07DA:  BZ    07F0
....................          rxData_count--;                                                           
07DC:  DECF   5D,F
....................          rxData[rxData_count]=0;                                                           
07DE:  CLRF   03
07E0:  MOVF   5D,W
07E2:  ADDLW  1C
07E4:  MOVWF  FE9
07E6:  MOVLW  00
07E8:  ADDWFC 03,W
07EA:  MOVWF  FEA
07EC:  CLRF   FEF
....................       }else if(data_in==13){ 
07EE:  BRA    0856
07F0:  MOVF   5C,W
07F2:  SUBLW  0D
07F4:  BNZ   0830
....................           
....................          unUSARTF.all=0;      
07F6:  CLRF   xA4
....................          unUSARTF.stUSARTF.enter_flag=1;  
07F8:  BSF    xA4.1
....................          terminal_text1_Count=0,terminal_text2_Count=0,terminal_text3_Count=0,terminal_text4_Count=0;  
07FA:  CLRF   x99
07FC:  CLRF   x9A
07FE:  CLRF   x9B
0800:  CLRF   x9C
....................          memcpy(strLCD, rxData, 32); 
0802:  CLRF   FEA
0804:  MOVLW  A5
0806:  MOVWF  FE9
0808:  CLRF   FE2
080A:  MOVLW  1C
080C:  MOVWF  FE1
080E:  MOVLW  20
0810:  MOVWF  01
0812:  MOVFF  FE6,FEE
0816:  DECFSZ 01,F
0818:  BRA    0812
....................          memset(rxData, 0, sizeof(rxData));                        
081A:  CLRF   FEA
081C:  MOVLW  1C
081E:  MOVWF  FE9
0820:  CLRF   00
0822:  CLRF   02
0824:  MOVLW  20
0826:  MOVWF  01
0828:  RCALL  00CC
....................          rxData_count=0;     
082A:  CLRF   5D
....................          switchTerminal_position=0;  
082C:  CLRF   xA2
....................       }else if(rxData_count>31){  
082E:  BRA    0856
0830:  MOVF   5D,W
0832:  SUBLW  1F
0834:  BC    0842
....................          switchTerminal_position=4; 
0836:  MOVLW  04
0838:  MOVWF  xA2
....................          unUSARTF.stUSARTF.recieve_exceed=1; 
083A:  BSF    xA4.2
....................          unUSARTF.stUSARTF.terminal_text3_flag=0; 
083C:  BCF    xA4.5
....................          terminal_text3_Count=0;   
083E:  CLRF   x9B
....................       }else {                         
0840:  BRA    0856
....................          rxData[rxData_count] = data_in;  
0842:  CLRF   03
0844:  MOVF   5D,W
0846:  ADDLW  1C
0848:  MOVWF  FE9
084A:  MOVLW  00
084C:  ADDWFC 03,W
084E:  MOVWF  FEA
0850:  MOVFF  5C,FEF
....................          rxData_count++;             
0854:  INCF   5D,F
....................       }   
0856:  GOTO   091C (RETURN)
.................... }                                               
....................  
....................  
....................                            
....................                      
.................... uint16_t iSayac;           
.................... tmr1_time_t tmr1_time;                     
....................                           
.................... void setupTimerIOSC(void){  
....................  
....................    //Setup Osilator 
....................    IRCF2 = 1; 
*
051C:  BSF    FD3.6
....................    IRCF1 = 1; 
051E:  BSF    FD3.5
....................    IRCF0 = 1;               
0520:  BSF    FD3.4
....................                          
....................    //D ve P portlari cikis olarak ayarlanip sifirlandi. 
....................    TRISB = 0x01;                  
0522:  MOVLW  01
0524:  MOVWF  F93
....................    TRISD = 0x00; 
0526:  CLRF   F95
....................    TRISE = 0x00; 
0528:  CLRF   F96
....................    PORTB = 0x00;                                                       
052A:  CLRF   F81
....................    PORTD = 0x00; 
052C:  CLRF   F8C
....................    PORTE = 0x00;  
052E:  CLRF   F84
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
0530:  CLRF   19
....................  
....................    // Kesmelere izin verildi 
....................    RCON_IPEN = 1;                                               
0532:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 1; 
0534:  BSF    FF2.7
....................    INTCON_PEIE = 1; 
0536:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
0538:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
053A:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
053C:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit 
053E:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
0540:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
0542:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
0544:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
0546:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
0548:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
054A:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
054C:  MOVLW  F8
054E:  MOVWF  FCF
....................    TMR1L = 0x30; // |||65436 decimal sayisina esit. 
0550:  MOVLW  30
0552:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit                                            
0554:  BSF    FCD.0
0556:  GOTO   011A (RETURN)
.................... } 
....................                             
.................... void adcSetup(){                                         
....................    //A0 giris olarak ayarlandi          
....................    PORTA_DIR_0 =1; 
055A:  BSF    F92.0
....................    PORTA_0 =0;   
055C:  BCF    F80.0
....................    ADCON1 = 0x0E; 
055E:  MOVLW  0E
0560:  MOVWF  FC1
....................    PCFG0=0;                        
0562:  BCF    FC1.0
....................    //AD kesiciye izin verildi. 
....................    ADIE=1; 
0564:  BSF    F9D.6
....................    //We use default value for +/- Vref 
....................    //VCFG0=0,VCFG1=0 
....................    //That means +Vref = Vdd (5v) and -Vref=GEN 
....................    //ADCON1=0x00;                       
....................    //ADC Result Right Justified.   
....................    //Acquisition Time = 1TAD  
....................    //Conversion Clock = 16 Tosc                  
....................    ADCON2=0x89;                 
0566:  MOVLW  89
0568:  MOVWF  FC0
056A:  GOTO   011C (RETURN)
.................... }                                     
....................  
.................... void ADC_Read(uint8_t CHANNEL){ 
....................    ADCON0=0x00;        // ADC modul deactive ve AN0 Anlog kanal oalrak secildi    
*
06C0:  CLRF   FC2
....................    ADCON0=(CHANNEL<<2);//Sola 2 kaydir ondan sonra CHANNEL degerini diger bitlere yazdir.    
06C2:  RLCF   xC8,W
06C4:  MOVWF  FC2
06C6:  RLCF   FC2,F
06C8:  MOVLW  FC
06CA:  ANDWF  FC2,F
....................    ADON=1;  //ADC yi aktif et.          
06CC:  BSF    FC2.0
....................    GODONE=1;//Cevrime basla               
06CE:  BSF    FC2.1
06D0:  GOTO   012C (RETURN)
....................    //while(GODONE); //wait for the conversion to finish  
....................    //ADON=0;  //switch off adc   
....................    //previusAdress=((ADRESH<<8)+ADRESL); 
....................    //return ((ADRESH<<8)+ADRESL);    
.................... }                            
....................                                                                                                                         
....................                                                                                                                  
.................... void printOn2x16(){                   
....................    delayUsFun(40);                                                                             
*
05E2:  MOVLW  28
05E4:  MOVWF  xCC
05E6:  RCALL  056E
....................    twoLinesBCDMode(); 
05E8:  BRA    05B0
....................    LinesActive();   
05EA:  BRA    05BA
....................    lcdCursorOff(); 
05EC:  BRA    05C4
....................    lcdShiftRight();                      
05EE:  BRA    05CE
....................    lcdClear();       
05F0:  BRA    05D8
....................    memcpy(strLCD, "INFORMELEKTRONIKAR-GE    STAJYER", 32); 
05F2:  CLRF   FEA
05F4:  MOVLW  A5
05F6:  MOVWF  FE9
05F8:  MOVFF  FF2,C8
05FC:  BCF    FF2.7
05FE:  MOVLW  20
0600:  MOVWF  01
0602:  CLRF   FF7
0604:  MOVLW  00
0606:  RCALL  0264
0608:  TBLRD*-
060A:  TBLRD*+
060C:  MOVFF  FF5,FEE
0610:  DECFSZ 01,F
0612:  BRA    060A
0614:  BTFSC  xC8.7
0616:  BSF    FF2.7
....................    countLCDChar=0;  
0618:  CLRF   xC5
061A:  GOTO   011E (RETURN)
....................    // LCD_Custom_CHAR(7, legrandLCDCharacter); 
....................    //LCD_Custom_CHAR(6, stickManLCDCharacter);                                
.................... }                
....................  
.................... void WDTreset(void){          
....................    #asm                   
*
06BA:  CLRWDT
....................    CLRWDT                          
....................    #endasm                                  
06BC:  GOTO   0122 (RETURN)
.................... }                                       
....................                  
.................... void lm35Calculate(){     //((float32_t)adresValue*(float32_t)0.4887) ((adresValue*125)+128)>>8   
....................    memset(strLCD, 0, terminal_text4_size);  //LCD buffer temizlendi                  
*
03C6:  CLRF   FEA
03C8:  MOVLW  A5
03CA:  MOVWF  FE9
03CC:  CLRF   00
03CE:  CLRF   02
03D0:  MOVFF  A0,01
03D4:  RCALL  00CC
....................    uint16_t adresValue = ADRESH<<8; //16 bit deger ADC ADRESH ve ADRESL bitlerinden cekildi  
03D6:  MOVFF  FC4,CF
03DA:  CLRF   xCE
....................    adresValue=adresValue+ADRESL;           
03DC:  MOVF   FC3,W
03DE:  ADDWF  xCE,F
03E0:  MOVLW  00
03E2:  ADDWFC xCF,F
....................    uint16_t value= (((adresValue*125)+128)>>8); //(((adresValue*125)+128)>>8); 128 yuvarlama 
03E4:  MOVFF  CF,D3
03E8:  MOVFF  CE,D2
03EC:  CLRF   xD5
03EE:  MOVLW  7D
03F0:  MOVWF  xD4
03F2:  BRA    02AE
03F4:  MOVFF  02,D3
03F8:  MOVFF  01,D2
03FC:  MOVLW  80
03FE:  ADDWF  xD2,F
0400:  MOVLW  00
0402:  ADDWFC xD3,F
0404:  MOVFF  D3,D0
0408:  CLRF   xD1
....................    sprintf(strLCD, "TEMP:%Lu%cC ", value , 0xdf); // 5000mV/1024(ADC=10)/10mv  10mv = 1 Derece 
040A:  CLRF   xC7
040C:  MOVLW  A5
040E:  MOVWF  xC6
0410:  MOVLW  A0
0412:  MOVWF  FF6
0414:  MOVLW  02
0416:  MOVWF  FF7
0418:  MOVLW  05
041A:  MOVWF  xD2
041C:  BRA    02EA
041E:  MOVLW  10
0420:  MOVWF  FE9
0422:  MOVFF  D1,D3
0426:  MOVFF  D0,D2
042A:  BRA    030A
042C:  MOVLW  DF
042E:  MOVWF  xDB
0430:  RCALL  02CE
0432:  MOVLW  43
0434:  MOVWF  xDB
0436:  RCALL  02CE
0438:  MOVLW  20
043A:  MOVWF  xDB
043C:  RCALL  02CE
043E:  GOTO   00F0 (RETURN)
.................... }                                              
....................                                                      
....................                              
.................... void rs232Case(){                                    
....................    if(RCIF_PIR1)  
*
0916:  BTFSS  F9E.5
0918:  BRA    091C
....................       rs232t();                                                         
091A:  BRA    07C8
....................    if(noKbHit_count>=1)    
091C:  MOVF   xA1,W
091E:  SUBLW  00
0920:  BC    0924
....................       unUSARTF.stUSARTF.noKbhit=1;                                                                         
0922:  BSF    xA4.0
....................                                                                             
....................    switch (switchTerminal_position){   
0924:  MOVF   xA2,W
0926:  BZ    093A
0928:  XORLW  01
092A:  BZ    0948
092C:  XORLW  03
092E:  BZ    097E
0930:  XORLW  01
0932:  BZ    09B6
0934:  XORLW  07
0936:  BZ    09EE
0938:  BRA    0A2C
....................       case 0: //              
....................       if(unUSARTF.stUSARTF.enter_flag && unUSARTF.stUSARTF.noKbhit){  
093A:  BTFSS  xA4.1
093C:  BRA    0946
093E:  BTFSS  xA4.0
0940:  BRA    0946
....................          switchTerminal_position=1;                                                               
0942:  MOVLW  01
0944:  MOVWF  xA2
....................       }    
....................       break;                                   
0946:  BRA    0A2E
....................       case 1: // MEVCUT METIN:                                                      
....................       if(TXIF_PIR1 && unUSARTF.stUSARTF.terminal_text1_flag==0){  
0948:  BTFSS  F9E.4
094A:  BRA    097C
094C:  BTFSC  xA4.3
094E:  BRA    097C
....................          rs232t_txText(0,terminal_text1_Count);                                        
0950:  CLRF   xC8
0952:  MOVFF  99,C9
0956:  RCALL  087C
....................          if(terminal_text1_Count>=terminal_text1_size-1){ 
0958:  MOVLW  01
095A:  SUBWF  x9D,W
095C:  SUBWF  x99,W
095E:  BNC   097A
....................             unUSARTF.stUSARTF.terminal_text1_flag=1; 
0960:  BSF    xA4.3
....................             switchTerminal_position=2; 
0962:  MOVLW  02
0964:  MOVWF  xA2
....................             memset(txData, 0, sizeof(txData));  
0966:  CLRF   FEA
0968:  MOVLW  3C
096A:  MOVWF  FE9
096C:  CLRF   00
096E:  CLRF   02
0970:  MOVLW  20
0972:  MOVWF  01
0974:  CALL   00CC
....................          }else{    
0978:  BRA    097C
....................            terminal_text1_Count++;           
097A:  INCF   x99,F
....................          }  
....................       }                                 
....................       break; 
097C:  BRA    0A2E
....................       case 2: // Lutfen bir yazi giriniz                                          
....................       if(TXIF_PIR1 && unUSARTF.stUSARTF.terminal_text4_flag==0){  
097E:  BTFSS  F9E.4
0980:  BRA    09B4
0982:  BTFSC  xA4.6
0984:  BRA    09B4
....................          rs232t_txText(3,terminal_text4_Count);                                        
0986:  MOVLW  03
0988:  MOVWF  xC8
098A:  MOVFF  9C,C9
098E:  RCALL  087C
....................          if(terminal_text4_Count>=terminal_text4_size-1){ 
0990:  MOVLW  01
0992:  SUBWF  xA0,W
0994:  SUBWF  x9C,W
0996:  BNC   09B2
....................             unUSARTF.stUSARTF.terminal_text4_flag=1; 
0998:  BSF    xA4.6
....................             switchTerminal_position=3; 
099A:  MOVLW  03
099C:  MOVWF  xA2
....................             memset(txData, 0, sizeof(txData)); 
099E:  CLRF   FEA
09A0:  MOVLW  3C
09A2:  MOVWF  FE9
09A4:  CLRF   00
09A6:  CLRF   02
09A8:  MOVLW  20
09AA:  MOVWF  01
09AC:  CALL   00CC
....................          }else{    
09B0:  BRA    09B4
....................             terminal_text4_Count++;               
09B2:  INCF   x9C,F
....................          }                
....................       }  
....................       break;           
09B4:  BRA    0A2E
....................       case 3: // LCD TEXT   
....................       if(TXIF_PIR1 && unUSARTF.stUSARTF.terminal_text2_flag==0){  
09B6:  BTFSS  F9E.4
09B8:  BRA    09EC
09BA:  BTFSC  xA4.4
09BC:  BRA    09EC
....................          rs232t_txText(1,terminal_text2_Count);                                        
09BE:  MOVLW  01
09C0:  MOVWF  xC8
09C2:  MOVFF  9A,C9
09C6:  RCALL  087C
....................          if(terminal_text2_Count>=terminal_text2_size-1){ 
09C8:  MOVLW  01
09CA:  SUBWF  x9E,W
09CC:  SUBWF  x9A,W
09CE:  BNC   09EA
....................             unUSARTF.stUSARTF.terminal_text2_flag=1; 
09D0:  BSF    xA4.4
....................             switchTerminal_position=0;    
09D2:  CLRF   xA2
....................             unUSARTF.stUSARTF.enter_flag=0;           
09D4:  BCF    xA4.1
....................             memset(txData, 0, sizeof(txData));     
09D6:  CLRF   FEA
09D8:  MOVLW  3C
09DA:  MOVWF  FE9
09DC:  CLRF   00
09DE:  CLRF   02
09E0:  MOVLW  20
09E2:  MOVWF  01
09E4:  CALL   00CC
....................          }else{  
09E8:  BRA    09EC
....................             terminal_text2_Count++;  
09EA:  INCF   x9A,F
....................          }                                             
....................       }                                                
....................       break;    
09EC:  BRA    0A2E
....................                                                                 
....................       case 4: // Limit Asildi                                                                
....................       if(TXIF_PIR1 && unUSARTF.stUSARTF.terminal_text3_flag==0 && unUSARTF.stUSARTF.recieve_exceed){  
09EE:  BTFSS  F9E.4
09F0:  BRA    0A2A
09F2:  BTFSC  xA4.5
09F4:  BRA    0A2A
09F6:  BTFSS  xA4.2
09F8:  BRA    0A2A
....................          rs232t_txText(2,terminal_text3_Count);                                        
09FA:  MOVLW  02
09FC:  MOVWF  xC8
09FE:  MOVFF  9B,C9
0A02:  RCALL  087C
....................          if(terminal_text3_Count>=terminal_text3_size-1){       
0A04:  MOVLW  01
0A06:  SUBWF  x9F,W
0A08:  SUBWF  x9B,W
0A0A:  BNC   0A28
....................             unUSARTF.stUSARTF.terminal_text3_flag=1; 
0A0C:  BSF    xA4.5
....................             unUSARTF.stUSARTF.recieve_exceed=0;       
0A0E:  BCF    xA4.2
....................             memset(txData, 0, sizeof(txData));                                                                                         
0A10:  CLRF   FEA
0A12:  MOVLW  3C
0A14:  MOVWF  FE9
0A16:  CLRF   00
0A18:  CLRF   02
0A1A:  MOVLW  20
0A1C:  MOVWF  01
0A1E:  CALL   00CC
....................             terminal_text3_Count=0;  
0A22:  CLRF   x9B
....................             switchTerminal_position=0;                  
0A24:  CLRF   xA2
....................          }else{    
0A26:  BRA    0A2A
....................             terminal_text3_Count++; 
0A28:  INCF   x9B,F
....................          }                     
....................       }    
....................       break;                                                
0A2A:  BRA    0A2E
....................     
....................       default:           
....................       switchTerminal_position=0; 
0A2C:  CLRF   xA2
....................    } 
0A2E:  GOTO   0144 (RETURN)
.................... }                                  
....................                                                
.................... #INT_AD  
.................... void AD_comp_interrupt(){  
....................    if(ADIF&&!GODONE){            //ADC kesici bayragi 
*
00E6:  BTFSS  F9E.6
00E8:  BRA    00F4
00EA:  BTFSC  FC2.1
00EC:  BRA    00F4
....................       lm35Calculate();     //GO/DONE islemi tamamlandigi icin dereceyi hesapla 
00EE:  BRA    03C6
....................       ADIF=0;              //Bayragi sifirla  
00F0:  BCF    F9E.6
....................    }else{ADIF=0;} 
00F2:  BRA    00F6
00F4:  BCF    F9E.6
.................... }                      
....................                  
00F6:  BCF    F9E.6
00F8:  GOTO   0060
.................... #INT_TIMER1                                                            
.................... void timer1_interrupt(){  
....................    TMR1H = 0xF8; //Tasma saayci| 
*
0484:  MOVLW  F8
0486:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.  
0488:  MOVLW  30
048A:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor. 
048C:  BCF    F9E.0
....................    iSayac++;                                
048E:  INCF   17,F
0490:  BTFSC  FD8.2
0492:  INCF   18,F
....................    if (iSayac % 20 == 0) //20ms 
0494:  MOVFF  18,CF
0498:  MOVFF  17,CE
049C:  CLRF   xD1
049E:  MOVLW  14
04A0:  MOVWF  xD0
04A2:  RCALL  0442
04A4:  MOVFF  00,CE
04A8:  MOVFF  03,CF
04AC:  MOVF   xCE,F
04AE:  BNZ   04B6
04B0:  MOVF   xCF,F
04B2:  BNZ   04B6
....................       tmr1_time.tmr1_flags._20ms = true;              
04B4:  BSF    19.1
....................    if(iSayac % 50 == 0) //50ms         
04B6:  MOVFF  18,CF
04BA:  MOVFF  17,CE
04BE:  CLRF   xD1
04C0:  MOVLW  32
04C2:  MOVWF  xD0
04C4:  RCALL  0442
04C6:  MOVFF  00,CE
04CA:  MOVFF  03,CF
04CE:  MOVF   xCE,F
04D0:  BNZ   04D8
04D2:  MOVF   xCF,F
04D4:  BNZ   04D8
....................       tmr1_time.tmr1_flags._50ms = true;  
04D6:  BSF    19.2
....................    if(iSayac % 1000 == 0) 
04D8:  MOVFF  18,CF
04DC:  MOVFF  17,CE
04E0:  MOVLW  03
04E2:  MOVWF  xD1
04E4:  MOVLW  E8
04E6:  MOVWF  xD0
04E8:  RCALL  0442
04EA:  MOVFF  00,CE
04EE:  MOVFF  03,CF
04F2:  MOVF   xCE,F
04F4:  BNZ   04FC
04F6:  MOVF   xCF,F
04F8:  BNZ   04FC
....................       tmr1_time.tmr1_flags._500ms = true;  
04FA:  BSF    19.5
....................    if(iSayac > 1000&&STATUS){   // 1 Saniye   
04FC:  MOVF   18,W
04FE:  SUBLW  02
0500:  BC    0516
0502:  XORLW  FF
0504:  BNZ   050C
0506:  MOVF   17,W
0508:  SUBLW  E8
050A:  BC    0516
050C:  MOVF   1B,F
050E:  BZ    0516
....................       iSayac = 0;                                            
0510:  CLRF   18
0512:  CLRF   17
....................       noKbHit_count++;   
0514:  INCF   xA1,F
....................    }                                 
.................... }                              
....................                                      
0516:  BCF    F9E.0
0518:  GOTO   0060
.................... #ORG 0x0100,0x0200                                                                     
.................... void main(){                                  
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  CLRF   1B
0108:  CLRF   xC7
010A:  CLRF   xC6
010C:  MOVF   FC1,W
010E:  ANDLW  C0
0110:  IORLW  0F
0112:  MOVWF  FC1
0114:  MOVLW  07
0116:  MOVWF  FB4
....................    setupTimerIOSC();    
0118:  BRA    051C
....................    adcSetup();                                 
011A:  BRA    055A
....................    printOn2x16();                                                         
011C:  BRA    05E2
....................    USART_Init();                                                        
011E:  BRA    061E
....................      while (TRUE){                                 
....................       WDTreset();                        
0120:  BRA    06BA
....................       if(tmr1_time.tmr1_flags._500ms){                       
0122:  BTFSS  19.5
0124:  BRA    012C
....................          tmr1_time.tmr1_flags._500ms = false;  
0126:  BCF    19.5
....................          ADC_Read(0);   
0128:  CLRF   xC8
012A:  BRA    06C0
....................       } 
....................       if(tmr1_time.tmr1_flags._50ms){           
012C:  BTFSS  19.2
012E:  BRA    013A
....................          tmr1_time.tmr1_flags._50ms = false; 
0130:  BCF    19.2
....................          button_debounce (PORTB, 0);  
0132:  MOVFF  F81,C8
0136:  CLRF   xC9
0138:  BRA    06F8
....................       }                                 
....................       if(tmr1_time.tmr1_flags._20ms){ 
013A:  BTFSS  19.1
013C:  BRA    0142
....................          tmr1_time.tmr1_flags._20ms = false;  
013E:  BCF    19.1
....................          LCD_String();                
0140:  BRA    0786
....................       }  
....................       rs232Case();     
0142:  BRA    0916
0144:  BRA    0120
....................    }                                                      
.................... }  
....................                     
0146:  SLEEP 

Configuration Fuses:
   Word  1: C900   INTRC FCMEN IESO
   Word  2: 051E   PUT BROWNOUT BORV21 WDT WDT4
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
