CCS PCH C Compiler, Version 5.015, 5967               24-Jul-23 17:40

               Filename:   C:\18F4520\CCS\I2C-RTCDS1307-LCD_Software\main.lst

               ROM used:   3012 bytes (9%)
                           Largest free fragment is 29304
               RAM used:   109 (7%) at main() level
                           148 (10%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   0402
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir. 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  CLRF   FF7
009E:  ADDLW  B0
00A0:  MOVWF  FF6
00A2:  MOVLW  00
00A4:  ADDWFC FF7,F
00A6:  TBLRD*+
00A8:  MOVF   FF5,W
00AA:  BTFSC  0D.7
00AC:  BSF    FF2.7
00AE:  RETURN 0
00B0:  DATA 49,4E
00B2:  DATA 46,4F
00B4:  DATA 52,4D
00B6:  DATA 45,4C
00B8:  DATA 45,4B
00BA:  DATA 54,52
00BC:  DATA 4F,4E
00BE:  DATA 49,4B
00C0:  DATA 41,52
00C2:  DATA 2D,47
00C4:  DATA 45,20
00C6:  DATA 20,20
00C8:  DATA 20,53
00CA:  DATA 54,41
00CC:  DATA 4A,59
00CE:  DATA 45,52
00D0:  DATA 00,00
00D2:  DATA 20,20
00D4:  DATA 25,30
00D6:  DATA 32,64
00D8:  DATA 20,3A
00DA:  DATA 20,25
00DC:  DATA 30,32
00DE:  DATA 64,20
00E0:  DATA 3A,20
00E2:  DATA 25,30
00E4:  DATA 32,64
00E6:  DATA 20,20
00E8:  DATA 20,25
00EA:  DATA 73,20
00EC:  DATA 2D,20
00EE:  DATA 25,30
00F0:  DATA 32,64
00F2:  DATA 2F,25
00F4:  DATA 30,32
00F6:  DATA 64,2F
00F8:  DATA 25,30
00FA:  DATA 32,64
00FC:  DATA 00,00
*
0440:  DATA 25,30
0442:  DATA 32,64
0444:  DATA 2F,25
0446:  DATA 30,32
0448:  DATA 64,2F
044A:  DATA 25,30
044C:  DATA 32,64
044E:  DATA 20,2D
0450:  DATA 2D,3E
0452:  DATA 25,73
0454:  DATA 00,00
*
0758:  CLRF   01
075A:  CLRF   02
075C:  CLRF   00
075E:  CLRF   03
0760:  MOVF   x90,W
0762:  BNZ   0768
0764:  MOVF   x8F,W
0766:  BZ    0798
0768:  MOVLW  10
076A:  MOVWF  x91
076C:  BCF    FD8.0
076E:  RLCF   x8D,F
0770:  RLCF   x8E,F
0772:  RLCF   00,F
0774:  RLCF   03,F
0776:  MOVF   x90,W
0778:  SUBWF  03,W
077A:  BNZ   0780
077C:  MOVF   x8F,W
077E:  SUBWF  00,W
0780:  BNC   0790
0782:  MOVF   x8F,W
0784:  SUBWF  00,F
0786:  BTFSS  FD8.0
0788:  DECF   03,F
078A:  MOVF   x90,W
078C:  SUBWF  03,F
078E:  BSF    FD8.0
0790:  RLCF   01,F
0792:  RLCF   02,F
0794:  DECFSZ x91,F
0796:  BRA    076C
0798:  RETURN 0
*
0970:  MOVFF  69,FEA
0974:  MOVFF  68,FE9
0978:  MOVFF  70,FEF
097C:  INCF   FE9,F
097E:  BTFSC  FD8.2
0980:  INCF   FEA,F
0982:  CLRF   FEF
0984:  INCF   68,F
0986:  BTFSC  FD8.2
0988:  INCF   69,F
098A:  RETURN 0
098C:  MOVF   74,W
098E:  CLRF   01
0990:  SUBWF  73,W
0992:  BC    099A
0994:  MOVFF  73,00
0998:  BRA    09B2
099A:  CLRF   00
099C:  MOVLW  08
099E:  MOVWF  75
09A0:  RLCF   73,F
09A2:  RLCF   00,F
09A4:  MOVF   74,W
09A6:  SUBWF  00,W
09A8:  BTFSC  FD8.0
09AA:  MOVWF  00
09AC:  RLCF   01,F
09AE:  DECFSZ 75,F
09B0:  BRA    09A0
09B2:  RETURN 0
09B4:  MOVLW  20
09B6:  BTFSS  6B.4
09B8:  MOVLW  30
09BA:  MOVWF  6C
09BC:  MOVFF  6A,00
09C0:  BTFSS  6A.7
09C2:  BRA    09D4
09C4:  COMF   00,F
09C6:  INCF   00,F
09C8:  MOVFF  00,6A
09CC:  MOVLW  2D
09CE:  MOVWF  6C
09D0:  BSF    6B.7
09D2:  BSF    6B.0
09D4:  MOVF   01,W
09D6:  MOVFF  6A,73
09DA:  MOVLW  64
09DC:  MOVWF  74
09DE:  RCALL  098C
09E0:  MOVFF  00,6A
09E4:  MOVLW  30
09E6:  ADDWF  01,W
09E8:  MOVWF  6D
09EA:  MOVFF  6A,73
09EE:  MOVLW  0A
09F0:  MOVWF  74
09F2:  RCALL  098C
09F4:  MOVLW  30
09F6:  ADDWF  00,W
09F8:  MOVWF  6F
09FA:  MOVLW  30
09FC:  ADDWF  01,W
09FE:  MOVWF  6E
0A00:  MOVFF  6C,00
0A04:  MOVLW  30
0A06:  SUBWF  6D,W
0A08:  BZ    0A12
0A0A:  BSF    6B.1
0A0C:  BTFSC  6B.7
0A0E:  BSF    6B.2
0A10:  BRA    0A36
0A12:  BTFSC  6B.2
0A14:  BRA    0A36
0A16:  MOVFF  6C,6D
0A1A:  BTFSC  6B.1
0A1C:  BRA    0A26
0A1E:  MOVLW  30
0A20:  SUBWF  6E,W
0A22:  BZ    0A2C
0A24:  BSF    6B.0
0A26:  BTFSC  6B.7
0A28:  BSF    6B.1
0A2A:  BRA    0A36
0A2C:  BTFSS  FD8.2
0A2E:  BSF    6B.0
0A30:  BTFSC  FD8.2
0A32:  MOVFF  6D,6E
0A36:  BTFSC  6B.2
0A38:  BRA    0A44
0A3A:  BTFSC  6B.1
0A3C:  BRA    0A4A
0A3E:  BTFSC  6B.0
0A40:  BRA    0A50
0A42:  BRA    0A56
0A44:  MOVFF  6C,70
0A48:  RCALL  0970
0A4A:  MOVFF  6D,70
0A4E:  RCALL  0970
0A50:  MOVFF  6E,70
0A54:  RCALL  0970
0A56:  MOVFF  6F,70
0A5A:  RCALL  0970
0A5C:  RETURN 0
0A5E:  TBLRD*+
0A60:  MOVFF  FF6,6B
0A64:  MOVFF  FF7,6C
0A68:  MOVFF  FF5,70
0A6C:  RCALL  0970
0A6E:  MOVFF  6B,FF6
0A72:  MOVFF  6C,FF7
0A76:  DECFSZ 6A,F
0A78:  BRA    0A5E
0A7A:  RETURN 0
0A7C:  MOVF   FEF,F
0A7E:  BZ    0A9E
0A80:  MOVFF  FEA,6B
0A84:  MOVFF  FE9,6A
0A88:  MOVFF  FEF,70
0A8C:  RCALL  0970
0A8E:  MOVFF  6B,FEA
0A92:  MOVFF  6A,FE9
0A96:  INCF   FE9,F
0A98:  BTFSC  FD8.2
0A9A:  INCF   FEA,F
0A9C:  BRA    0A7C
0A9E:  GOTO   0B88 (RETURN)
0AA2:  TSTFSZ 01
0AA4:  BRA    0AAC
0AA6:  TSTFSZ 02
0AA8:  BRA    0AAE
0AAA:  BRA    0ABA
0AAC:  INCF   02,F
0AAE:  MOVFF  00,FEE
0AB2:  DECFSZ 01,F
0AB4:  BRA    0AAE
0AB6:  DECFSZ 02,F
0AB8:  BRA    0AAE
0ABA:  GOTO   0BD0 (RETURN)
*
0C04:  MOVLW  20
0C06:  BTFSS  6E.4
0C08:  MOVLW  30
0C0A:  MOVWF  6F
0C0C:  MOVFF  6D,00
0C10:  BTFSS  6D.7
0C12:  BRA    0C24
0C14:  COMF   00,F
0C16:  INCF   00,F
0C18:  MOVFF  00,6D
0C1C:  MOVLW  2D
0C1E:  MOVWF  6F
0C20:  BSF    6E.7
0C22:  BSF    6E.0
0C24:  MOVF   01,W
0C26:  MOVFF  6D,73
0C2A:  MOVLW  64
0C2C:  MOVWF  74
0C2E:  RCALL  098C
0C30:  MOVFF  00,6D
0C34:  MOVLW  30
0C36:  ADDWF  01,W
0C38:  MOVWF  70
0C3A:  MOVFF  6D,73
0C3E:  MOVLW  0A
0C40:  MOVWF  74
0C42:  RCALL  098C
0C44:  MOVLW  30
0C46:  ADDWF  00,W
0C48:  MOVWF  72
0C4A:  MOVLW  30
0C4C:  ADDWF  01,W
0C4E:  MOVWF  71
0C50:  MOVFF  6F,00
0C54:  MOVLW  30
0C56:  SUBWF  70,W
0C58:  BZ    0C62
0C5A:  BSF    6E.1
0C5C:  BTFSC  6E.7
0C5E:  BSF    6E.2
0C60:  BRA    0C86
0C62:  BTFSC  6E.2
0C64:  BRA    0C86
0C66:  MOVFF  6F,70
0C6A:  BTFSC  6E.1
0C6C:  BRA    0C76
0C6E:  MOVLW  30
0C70:  SUBWF  71,W
0C72:  BZ    0C7C
0C74:  BSF    6E.0
0C76:  BTFSC  6E.7
0C78:  BSF    6E.1
0C7A:  BRA    0C86
0C7C:  BTFSS  FD8.2
0C7E:  BSF    6E.0
0C80:  BTFSC  FD8.2
0C82:  MOVFF  70,71
0C86:  BTFSC  6E.2
0C88:  BRA    0C94
0C8A:  BTFSC  6E.1
0C8C:  BRA    0C9C
0C8E:  BTFSC  6E.0
0C90:  BRA    0CA4
0C92:  BRA    0CAC
0C94:  MOVF   6F,W
0C96:  BTFSS  F9E.4
0C98:  BRA    0C96
0C9A:  MOVWF  FAD
0C9C:  MOVF   70,W
0C9E:  BTFSS  F9E.4
0CA0:  BRA    0C9E
0CA2:  MOVWF  FAD
0CA4:  MOVF   71,W
0CA6:  BTFSS  F9E.4
0CA8:  BRA    0CA6
0CAA:  MOVWF  FAD
0CAC:  MOVF   72,W
0CAE:  BTFSS  F9E.4
0CB0:  BRA    0CAE
0CB2:  MOVWF  FAD
0CB4:  RETURN 0
0CB6:  TBLRD*+
0CB8:  MOVFF  FF6,6D
0CBC:  MOVFF  FF7,6E
0CC0:  MOVF   FF5,W
0CC2:  BTFSS  F9E.4
0CC4:  BRA    0CC2
0CC6:  MOVWF  FAD
0CC8:  MOVFF  6D,FF6
0CCC:  MOVFF  6E,FF7
0CD0:  DECFSZ 6C,F
0CD2:  BRA    0CB6
0CD4:  GOTO   0228 (RETURN)
0CD8:  MOVF   FEF,F
0CDA:  BZ    0CFC
0CDC:  MOVFF  FEA,6D
0CE0:  MOVFF  FE9,6C
0CE4:  MOVF   FEF,W
0CE6:  BTFSS  F9E.4
0CE8:  BRA    0CE6
0CEA:  MOVWF  FAD
0CEC:  MOVFF  6D,FEA
0CF0:  MOVFF  6C,FE9
0CF4:  INCF   FE9,F
0CF6:  BTFSC  FD8.2
0CF8:  INCF   FEA,F
0CFA:  BRA    0CD8
0CFC:  GOTO   0232 (RETURN)
....................  
.................... #list 
....................  
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanýr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       Â· LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       Â· WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini saðlar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       Â· PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin içine yükleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       Â· PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       Â· BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       Â· INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       Â· NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */                                
....................                                                          
.................... #FUSES NOWDT, WDT8, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC  
.................... #use delay (internal=8MHz)                   
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7) 
.................... //#use I2C(master, sda=PIN_C4, scl=PIN_C3) 
....................                                             
.................... #include "definitions.h"                                                                                                       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "main.h"                  
.................... #ifndef MAIN_H      
.................... #define MAIN_H  
.................... #define DELAY 500  
....................                             
.................... void WDTreset(void);   
....................                      
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"                                     
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //  
.................... #bit  SCL_DIR=TRISC.3  
.................... #bit  SDA_DIR=TRISC.4  
.................... #bit  SCL=PORTC.3  
.................... #bit  SDA=PORTC.4     
....................  
.................... #byte PIR2    = 0x0FA1  
.................... #bit BCLIF    = PIR2.3 
....................                           
.................... #byte SSPSTAT = 0x0FC7         
.................... #bit  BF      = SSPSTAT.0 
.................... #bit  RW      = SSPSTAT.2  
.................... #bit  S       = SSPSTAT.3   
.................... #bit  P       = SSPSTAT.4 
.................... #bit  CKE     = SSPSTAT.6 
.................... #bit  SMP     = SSPSTAT.7 
....................  
.................... #byte SSPCON1 = 0x0FC6  
.................... #bit  SSPM0   = SSPCON1.0 
.................... #bit  SSPM1   = SSPCON1.1 
.................... #bit  SSPM2   = SSPCON1.2 
.................... #bit  SSPM3   = SSPCON1.3 
.................... #bit  SSPEN   = SSPCON1.5  
....................  
.................... #byte SSPCON2 = 0x0FC5  
.................... #bit  SEN     = SSPCON2.0 
.................... #bit  RSEN    = SSPCON2.1  
.................... #bit  PEN     = SSPCON2.2  
.................... #bit  RCEN    = SSPCON2.3  
.................... #bit  ACKEN   = SSPCON2.4 
.................... #bit  ACKDT   = SSPCON2.5           
.................... #bit  ACKSTAT = SSPCON2.6  
....................  
.................... #byte SSPBUF  = 0x0FC9  
.................... #byte SSPADD  = 0x0FC8 
.................... #bit  SSPIE   = PIE1.3 
.................... #bit  SSPIF   = PIR1.3  
....................  
....................                        
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h"                                                                                          
.................... #ifndef INITS_H 
.................... #define INITS_H       
....................  
.................... extern uint16_t iSayac;  
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _2ms    : 1;  //bit:0, 2ms  
....................       uint8_t _20ms   : 1;  //bit:2, 20ms  
....................       uint8_t _50ms   : 1;  //bit:3, 50ms  
....................       uint8_t _100ms  : 1;  //bit:4, 100ms     
....................       uint8_t _200ms  : 1;  //bit:5, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:6, 500ms  
....................       uint8_t _1000ms : 1;  //bit:7, 1000ms  
....................       uint8_t _200msKEYPAD     : 1; 
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t tmr1_time;     
....................  
....................  
....................  
....................  
....................                                                 
.................... #endif //INIT_H                               
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
....................                                  
....................                   
.................... #include "lcd.c"                                 
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //  
.................... #bit  SCL_DIR=TRISC.3  
.................... #bit  SDA_DIR=TRISC.4  
.................... #bit  SCL=PORTC.3  
.................... #bit  SDA=PORTC.4     
....................  
.................... #byte PIR2    = 0x0FA1  
.................... #bit BCLIF    = PIR2.3 
....................                           
.................... #byte SSPSTAT = 0x0FC7         
.................... #bit  BF      = SSPSTAT.0 
.................... #bit  RW      = SSPSTAT.2  
.................... #bit  S       = SSPSTAT.3   
.................... #bit  P       = SSPSTAT.4 
.................... #bit  CKE     = SSPSTAT.6 
.................... #bit  SMP     = SSPSTAT.7 
....................  
.................... #byte SSPCON1 = 0x0FC6  
.................... #bit  SSPM0   = SSPCON1.0 
.................... #bit  SSPM1   = SSPCON1.1 
.................... #bit  SSPM2   = SSPCON1.2 
.................... #bit  SSPM3   = SSPCON1.3 
.................... #bit  SSPEN   = SSPCON1.5  
....................  
.................... #byte SSPCON2 = 0x0FC5  
.................... #bit  SEN     = SSPCON2.0 
.................... #bit  RSEN    = SSPCON2.1  
.................... #bit  PEN     = SSPCON2.2  
.................... #bit  RCEN    = SSPCON2.3  
.................... #bit  ACKEN   = SSPCON2.4 
.................... #bit  ACKDT   = SSPCON2.5           
.................... #bit  ACKSTAT = SSPCON2.6  
....................  
.................... #byte SSPBUF  = 0x0FC9  
.................... #byte SSPADD  = 0x0FC8 
.................... #bit  SSPIE   = PIE1.3 
.................... #bit  SSPIF   = PIR1.3  
....................  
....................                        
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "delayms.h"  
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................                  
....................                
.................... /*Hex Code   LCD Ekran Karsiligi  
....................  Initialize Lcd in 4-bit mode               0x02 
.................... 1   Function Set: 8-bit, 1 Line, 5×7 Dots   0x30   48                                              
.................... 2   Function Set: 8-bit, 2 Line, 5×7 Dots   0x38   56                            
.................... 3   Function Set: 4-bit, 1 Line, 5×7 Dots   0x20   32 
.................... 4   Function Set: 4-bit, 2 Line, 5×7 Dots   0x28   40  
.................... 0F   LCD acik, Imlec acik 
.................... 01   Ekrani Temizle                                 
.................... 02   Satir Basina Dön            
.................... 04   Imleci Sola Kaydir 
.................... 06   Imleci Saga Kaydir 
.................... 05   Ekrani Saga Kaydir 
.................... 07   Ekrani Sola Kaydir 
.................... 0E   Ekran Acik, Imleç Yanip Sonuyor 
.................... 80   Imleci Ilk Satirin Basinda Konumlandir 
.................... C0   Imleci Ikinci Satirin Basinda Konumlandir         
.................... 3C   Ikinci Satiri Etkinlestir                                                     
.................... 08   Ekran Kapali, Imleç Kapali              
.................... OC   Ekran Acik, Imlec Kapali*/   
....................                                             
.................... uchar_t strLCD[32]; 
.................... uint8_t countLCDChar; 
.................... uchar_t LCDW1SecFlag; 
....................                                          
.................... /*LCD (CHIP: HD44780), COMMAND MODE*/  
.................... void dis_cmd(uchar_t cmdout){  
....................    PORTD=cmdout;      //Send command to lcdport=PORTB 
*
04A4:  MOVFF  6C,F8C
....................    PORTE_RS=0;                   
04A8:  BCF    F84.0
....................    PORTE_E=1;                
04AA:  BSF    F84.1
....................    delayUsFun(1); 
04AC:  MOVLW  01
04AE:  MOVWF  6E
04B0:  RCALL  0496
....................    PORTE_E=0;                               
04B2:  BCF    F84.1
04B4:  RETURN 0
.................... }                                   
....................  
....................  
....................  
.................... void lcdcmd(uchar_t cmd_value){          
....................    uchar_t cmd_value1;                              
....................    cmd_value1 = (cmd_value & 0xF0);      // Mask lower nibble because RB4-RB7 pins are being used    
04B6:  MOVF   6A,W
04B8:  ANDLW  F0
04BA:  MOVWF  6B
....................    dis_cmd(cmd_value1);                   // Send to LCD 
04BC:  MOVFF  6B,6C
04C0:  RCALL  04A4
....................    cmd_value1 = ((cmd_value<<4) & 0xF0);  // Shift 4-bit and mask 
04C2:  SWAPF  6A,W
04C4:  MOVWF  00
04C6:  MOVLW  F0
04C8:  ANDWF  00,F
04CA:  MOVF   00,W
04CC:  ANDLW  F0
04CE:  MOVWF  6B
....................    dis_cmd(cmd_value1);                   // Send to LCD 
04D0:  MOVFF  6B,6C
04D4:  RCALL  04A4
04D6:  RETURN 0
.................... } 
....................  // 2 lines are active.              
.................... void twoLinesBCDMode(){  
....................    lcdcmd(0x02); 
04D8:  MOVLW  02
04DA:  MOVWF  6A
04DC:  RCALL  04B6
04DE:  GOTO   0512 (RETURN)
.................... } 
....................                         
.................... // 2 lines are active. BCD MODE 
.................... void LinesActive(){  
....................    lcdcmd(0x28);                
04E2:  MOVLW  28
04E4:  MOVWF  6A
04E6:  RCALL  04B6
04E8:  GOTO   0514 (RETURN)
.................... }                          
.................... // LCD screen clear.                   
.................... void lcdClear(){ 
....................    lcdcmd(0x01);                   
*
0500:  MOVLW  01
0502:  MOVWF  6A
0504:  RCALL  04B6
0506:  GOTO   051A (RETURN)
.................... }                   
.................... // Go to first line. 
.................... void lcdGoToFirstLine(){  
....................    lcdcmd(0x80); 
*
0D00:  MOVLW  80
0D02:  MOVWF  6A
0D04:  CALL   04B6
0D08:  GOTO   0D56 (RETURN)
.................... }                                  
.................... // Go to second line.                        
.................... void lcdGoToSecondLine(){ 
....................    lcdcmd(0xC0); 
0D0C:  MOVLW  C0
0D0E:  MOVWF  6A
0D10:  CALL   04B6
0D14:  GOTO   0D5E (RETURN)
.................... }                        
.................... // Shift cursor to right. 
.................... void lcdShiftRight(){   
....................    lcdcmd(0x06);                                                     
*
04F6:  MOVLW  06
04F8:  MOVWF  6A
04FA:  RCALL  04B6
04FC:  GOTO   0518 (RETURN)
.................... }                                           
.................... // Display on, Cursor on              
.................... void lcdCursorOn(){                  
....................    lcdcmd(0x0E); 
.................... }                                      
.................... //Display off, Cursor off 
.................... void lcdCursorOff(){                                             
....................    lcdcmd(0x0C);                             
*
04EC:  MOVLW  0C
04EE:  MOVWF  6A
04F0:  RCALL  04B6
04F2:  GOTO   0516 (RETURN)
.................... }                              
....................   
.................... void dis_data(uchar_t dataout) {  
....................    PORTD=dataout;   //Send data to lcdport=PORTB 
*
0D18:  MOVFF  6D,F8C
....................    PORTE_RS=1;                   
0D1C:  BSF    F84.0
....................    PORTE_E=1;                          
0D1E:  BSF    F84.1
....................    delayUsFun(1); 
0D20:  MOVLW  01
0D22:  MOVWF  6E
0D24:  CALL   0496
....................    PORTE_E=0;   
0D28:  BCF    F84.1
0D2A:  RETURN 0
....................    //PORTD=0x00; 
....................    //while(test_bit(PORTD,7));           
.................... }   
.................... /*DATA MODE*/   
.................... void lcddata(uchar_t text){  
....................    uchar_t data;                                                                 
....................    data=(text & 0xF0);         
0D2C:  MOVF   6B,W
0D2E:  ANDLW  F0
0D30:  MOVWF  6C
....................    dis_data(data);     
0D32:  MOVFF  6C,6D
0D36:  RCALL  0D18
....................    data=((text<<4)&0xF0);      
0D38:  SWAPF  6B,W
0D3A:  MOVWF  00
0D3C:  MOVLW  F0
0D3E:  ANDWF  00,F
0D40:  MOVF   00,W
0D42:  ANDLW  F0
0D44:  MOVWF  6C
....................    dis_data(data);                  
0D46:  MOVFF  6C,6D
0D4A:  RCALL  0D18
0D4C:  GOTO   0D7C (RETURN)
.................... }                                
.................... void LCD_String(){  
....................    if(countLCDChar==0)  
0D50:  MOVF   39,F
0D52:  BNZ   0D56
....................       lcdGoToFirstLine(); 
0D54:  BRA    0D00
....................    if(countLCDChar==16)   
0D56:  MOVF   39,W
0D58:  SUBLW  10
0D5A:  BNZ   0D5E
....................       lcdGoToSecondLine();    
0D5C:  BRA    0D0C
....................    if(countLCDChar<=31){  
0D5E:  MOVF   39,W
0D60:  SUBLW  1F
0D62:  BNC   0D80
....................       lcddata(strLCD[countLCDChar]); 
0D64:  CLRF   03
0D66:  MOVF   39,W
0D68:  ADDLW  19
0D6A:  MOVWF  FE9
0D6C:  MOVLW  00
0D6E:  ADDWFC 03,W
0D70:  MOVWF  FEA
0D72:  MOVFF  FEF,6A
0D76:  MOVFF  6A,6B
0D7A:  BRA    0D2C
....................       countLCDChar++;   
0D7C:  INCF   39,F
....................    }else{    
0D7E:  BRA    0D84
....................       LCDW1SecFlag=0; 
0D80:  CLRF   3A
....................       countLCDChar=0; 
0D82:  CLRF   39
....................    }                  
0D84:  GOTO   0240 (RETURN)
.................... }  
....................  
....................  
.................... void LCD_Custom_Char(uchar_t loc, uchar_t *msg){ 
....................     uchar_t i; 
....................     if(loc<8) 
....................     { 
....................      lcdcmd(0x40 + (loc*8));    /* Command 0x40 and onwards forces the device to point CGRAM address */ 
....................      for(i=0;i<8;i++)          /* Write 8 byte for generation of 1 character */ 
....................         lcddata(msg[i]);       
....................     }                        
.................... } 
....................  
....................                                           
....................  
....................       
....................  
.................... #include "delayms.c"     
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs){  // Delay function - generates a delay of specified msecs 
....................    uint16_t i; 
....................    uint8_t j;  
....................    for(i=0;i<=msecs;i++) 
....................    for(j=0;j<205;j++); /*This count Provide delay of 1 ms for 8MHz Frequency */                              
.................... }        
....................  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
*
0496:  CLRF   6F
0498:  MOVF   6F,W
049A:  SUBWF  6E,W
049C:  BNC   04A2
049E:  INCF   6F,F
04A0:  BRA    0498
....................     }                                
04A2:  RETURN 0
.................... }   
....................  
....................  
.................... #include "DS1307.c"                                          
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                   /// 
.................... ///                     Driver for Real Time Clock                           /// 
.................... ///                                                                          /// 
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -/// 
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     /// 
.................... ///               - Disable squarewave output                                /// 
.................... ///                                                                          /// 
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             /// 
.................... ///                                                                          /// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#use i2c(master, sda=PIN_C4, scl=PIN_C3)                                                                                                
.................... #include "binbcdconv.c"   
.................... #include "binbcdconv.h" 
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef BINBCDCONV_H         
.................... #define BINBCDCONV_H   
....................  
.................... uchar_t bin2bcd(uchar_t binary_value); 
.................... uchar_t bcd2bin(uchar_t bcd_value); 
....................                          
.................... #endif //BINBCDCONV_H      
....................  
....................                                                      
.................... uchar_t bin2bcd(uchar_t binary_value){ 
....................   uchar_t retval;                     
....................   retval = 0;                                                
*
05E6:  CLRF   72
....................   while(1){ 
....................     if(binary_value >= 10){    // 10'dan buyuk oldugu muddetce                                     
05E8:  MOVF   71,W
05EA:  SUBLW  09
05EC:  BC    05F8
....................       binary_value   -= 10;    // 10 cikar 
05EE:  MOVLW  0A
05F0:  SUBWF  71,F
....................       retval += 0x10;  //asil degiskenimizin MsB'sine 1 ekle      
05F2:  MOVLW  10
05F4:  ADDWF  72,F
....................     }  
05F6:  BRA    05FE
....................     else{  
....................       retval += binary_value;  //artik 10'dan buyuk degil kalan 0-9 arasi sayiyi asil degiskenimize ekle                             
05F8:  MOVF   71,W
05FA:  ADDWF  72,F
....................       break;                 
05FC:  BRA    0600
....................     } 
05FE:  BRA    05E8
....................   } 
....................   return(retval);   
0600:  MOVFF  72,01
0604:  RETURN 0
.................... } 
....................                            
....................                                
.................... // 8-Bit ile oldugu icin 0-99 arasi bir bcd sayi yazilmalidir.  
.................... uchar_t bcd2bin(uchar_t bcd_value){  
....................          // (bcd_value>>4)*10) BCD'nin 10 luk kisim ilk 4 bite kaydirildi ve 10 ile carpildi. 
....................          // (bcd_value & 0x0F) BCD'nin yuksek degerli 4 biti sifirlandi ve 0-9 kismi birakildi. 
....................          // 2 sayi toplanarak binary karsiligi elde edildi. 
....................   return ((bcd_value>>4)*10) + (bcd_value & 0x0F);   
*
06D6:  SWAPF  6B,W
06D8:  MOVWF  00
06DA:  MOVLW  0F
06DC:  ANDWF  00,F
06DE:  MOVF   00,W
06E0:  MULLW  0A
06E2:  MOVFF  FF3,6C
06E6:  MOVF   6B,W
06E8:  ANDLW  0F
06EA:  ADDWF  6C,W
06EC:  MOVWF  01
06EE:  RETURN 0
.................... }                      
....................  
.................... #include "DS1307.h"                                               
.................... #ifndef DS1307_H                             
.................... #define DS1307_H    
....................  
.................... //DS1307 TIME-DATE INFO VARIABLES   
.................... extern uchar_t sec, min, hrs; 
.................... extern uchar_t day, month, yr, dow;       
.................... extern uchar_t dayText[4];   
.................... extern uchar_t DATE_TIME[32];   
....................  
....................  
.................... void DS1307_Init();                                                      
.................... void ds1307_set_date_time(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t); 
.................... void ds1307_get_date(); 
.................... void ds1307_get_time();  
.................... void getDayText();                     
....................                
.................... uchar_t getSec(); 
.................... uchar_t getMin();  
.................... uchar_t getHour(); 
....................                            
.................... uchar_t getDay();  
.................... uchar_t getMonth();  
.................... uchar_t getYear(); 
.................... uchar_t getDow();                                                                  
....................                 
.................... uint16_t day_of_the_week(uint16_t, uint16_t, uint16_t );                   
....................                     
.................... #endif //DS1307_H                      
....................                                        
....................  
.................... #include "i2c.h"              
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef I2C_H                                                            
.................... #define I2C_H                                                                  
....................  
.................... void _I2C_Start();          
.................... void _I2C_Stop();   
.................... void I2C_Clock();                                                             
....................  
.................... uchar_t _I2C_Read(uchar_t);                
.................... void _I2CACK(uchar_t);      
.................... void _I2C_Write(uchar_t);      
....................  
....................  
.................... void i2cHighSda(void);                     
.................... void i2cLowSda(void);                                                           
.................... void i2cHighScl(void); 
.................... void i2cLowScl(void);  
....................  
....................  
....................                     
.................... #endif //I2C_H      
....................  
....................  
....................            
....................  
.................... #include "i2c.c"     
.................... #include "i2c.h" 
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef I2C_H                                                            
.................... #define I2C_H                                                                  
....................  
.................... void _I2C_Start();          
.................... void _I2C_Stop();   
.................... void I2C_Clock();                                                             
....................  
.................... uchar_t _I2C_Read(uchar_t);                
.................... void _I2CACK(uchar_t);      
.................... void _I2C_Write(uchar_t);      
....................  
....................  
.................... void i2cHighSda(void);                     
.................... void i2cLowSda(void);                                                           
.................... void i2cHighScl(void); 
.................... void i2cLowScl(void);  
....................  
....................  
....................                     
.................... #endif //I2C_H      
....................  
....................  
....................            
....................  
.................... #include "definitions.h"                                                                              
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;  
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "ucregisters.h"      
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //  
.................... #bit  SCL_DIR=TRISC.3  
.................... #bit  SDA_DIR=TRISC.4  
.................... #bit  SCL=PORTC.3  
.................... #bit  SDA=PORTC.4     
....................  
.................... #byte PIR2    = 0x0FA1  
.................... #bit BCLIF    = PIR2.3 
....................                           
.................... #byte SSPSTAT = 0x0FC7         
.................... #bit  BF      = SSPSTAT.0 
.................... #bit  RW      = SSPSTAT.2  
.................... #bit  S       = SSPSTAT.3   
.................... #bit  P       = SSPSTAT.4 
.................... #bit  CKE     = SSPSTAT.6 
.................... #bit  SMP     = SSPSTAT.7 
....................  
.................... #byte SSPCON1 = 0x0FC6  
.................... #bit  SSPM0   = SSPCON1.0 
.................... #bit  SSPM1   = SSPCON1.1 
.................... #bit  SSPM2   = SSPCON1.2 
.................... #bit  SSPM3   = SSPCON1.3 
.................... #bit  SSPEN   = SSPCON1.5  
....................  
.................... #byte SSPCON2 = 0x0FC5  
.................... #bit  SEN     = SSPCON2.0 
.................... #bit  RSEN    = SSPCON2.1  
.................... #bit  PEN     = SSPCON2.2  
.................... #bit  RCEN    = SSPCON2.3  
.................... #bit  ACKEN   = SSPCON2.4 
.................... #bit  ACKDT   = SSPCON2.5           
.................... #bit  ACKSTAT = SSPCON2.6  
....................  
.................... #byte SSPBUF  = 0x0FC9  
.................... #byte SSPADD  = 0x0FC8 
.................... #bit  SSPIE   = PIE1.3 
.................... #bit  SSPIF   = PIR1.3  
....................  
....................                        
.................... #endif UCREGISTER_H                                                                          
....................  
....................  
.................... //This function is used to generate a clock pulse on SCL line. 
.................... void I2C_Clock(void){      
....................     delay_us(1);  
*
059A:  BRA    059C
....................     i2cHighScl(); // Wait for Some time and Pull the SCL line High 
059C:  RCALL  056C
....................                   // Wdelay_us(1);        ait for Some time 
....................     i2cLowScl();  // Pull back the SCL line low to Generate a clock pulse    
059E:  RCALL  054A
05A0:  RETURN 0
.................... }                                                  
....................  
.................... //This fun is used to receive a byte on SDA line using I2C protocol. 
.................... //8bit data is received bit-by-bit each clock and finally packed into Byte. 
.................... //MSB(bit) is received first and LSB(bit) is received at last.    
.................... //        ___     ___     ___     ___     ___     ___     ___     ___     ___             
.................... // SCD:  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    
.................... //     __|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|  
.................... // SDA:   D8      D7      D6      D5      D4      D3      D2      D1      D0       
.................... uchar_t _I2C_Read(uchar_t mode){                            
*
06AA:  CLRF   6C
....................     uchar_t i, dat=0x00; 
....................     i2cHighSda();            //Make SDA as I/P 
06AC:  RCALL  055C
....................     for(i=0;i<8;i++){        // loop 8times to read 1-byte of data 
06AE:  CLRF   6B
06B0:  MOVF   6B,W
06B2:  SUBLW  07
06B4:  BNC   06CA
....................         i2cHighScl();        // Pull SCL High                  
06B6:  RCALL  056C
....................                                              
....................         dat = dat<<1;        //dat is Shifted each time and 
06B8:  BCF    FD8.0
06BA:  RLCF   6C,F
....................         dat = dat | SDA;     //ORed with the received bit to pack into byte 
06BC:  MOVLW  00
06BE:  BTFSC  F82.4
06C0:  MOVLW  01
06C2:  IORWF  6C,F
....................                         
....................         i2cLowScl();         // Clear SCL to complete the Clock 
06C4:  RCALL  054A
06C6:  INCF   6B,F
06C8:  BRA    06B0
....................        } 
....................        _I2CACK(mode); 
06CA:  MOVFF  6A,6D
06CE:  BRA    0694
....................    return dat;               // Finally return the received Byte* 
06D0:  MOVFF  6C,01
06D4:  RETURN 0
.................... }  
.................... //This function is used to send a byte on SDA line using I2C protocol 
.................... //8bit data is sent bit-by-bit on each clock cycle. 
.................... //MSB(bit) is sent first and LSB(bit) is sent at last. 
.................... //Data is sent when SCL is low.             
.................... //        ___     ___     ___     ___     ___     ___     ___     ___     ___             
.................... // SCD:  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |    
.................... //     __|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|  
.................... // SDA:   D8      D7      D6      D5      D4      D3      D2      D1      D0       
.................... void _I2C_Write(uchar_t  dat){ 
....................     uchar_t i; 
....................     for(i=0;i<8;i++){         // loop 8 times to send 1-byte of data   
*
05A2:  CLRF   73
05A4:  MOVF   73,W
05A6:  SUBLW  07
05A8:  BNC   05BE
....................         if(dat & 0x80){ 
05AA:  BTFSS  72.7
05AC:  BRA    05B2
....................             i2cHighSda();     // Send Bit by Bit on SDA line 
05AE:  RCALL  055C
....................         }else{   
05B0:  BRA    05B4
....................             i2cLowSda();  
05B2:  RCALL  057C
....................         } 
....................         I2C_Clock();          // Generate Clock at SCL 
05B4:  RCALL  059A
....................         dat = dat<<1;          
05B6:  BCF    FD8.0
05B8:  RLCF   72,F
05BA:  INCF   73,F
05BC:  BRA    05A4
....................       }                                                  
....................         i2cHighSda();         // Set SDA at last     
05BE:  RCALL  055C
....................         I2C_Clock();  
05C0:  RCALL  059A
05C2:  RETURN 0
.................... }       
....................  
.................... //ACK  : This function is used to generate a the Positive ACK pulse on SDA after receiving a byte. 
.................... //NOACK: This function is used to generate a the Negative/NO ACK pulse on SDA after receiving all bytes. 
.................... void _I2CACK(uchar_t mode){ 
....................    if(mode==1){     //ACK      
*
0694:  DECFSZ 6D,W
0696:  BRA    06A0
....................     i2cLowSda();    //Pull SDA low to indicate Positive ACK  
0698:  RCALL  057C
....................     I2C_Clock();    //Generate the Clock 
069A:  RCALL  059A
....................     i2cHighSda();   // Pull SDA back to High(IDLE state) 
069C:  RCALL  055C
....................    }else{           //NACK  
069E:  BRA    06A6
....................     i2cHighSda();   //Pull SDA high to indicate Negative/NO ACK 
06A0:  RCALL  055C
....................     I2C_Clock();    // Generate the Clock   
06A2:  RCALL  059A
....................     i2cHighScl();   // Set SCL  
06A4:  RCALL  056C
....................    }                                                                                  
06A6:  GOTO   06D0 (RETURN)
.................... }                          
....................  
.................... //This function is used to generate I2C Start Condition. 
.................... //Start Condition: SDA goes low when SCL is High. 
.................... //              ________ 
.................... // SCL:        |        |                 
.................... //        _____|        |___________                 
.................... //            _____     
.................... // SDA:      |     | 
.................... //       ____|     |______  
.................... void _I2C_Start(){ 
....................     i2cLowScl();     // Pull SCL low   
*
058E:  RCALL  054A
....................     i2cHighSda();    // Pull SDA High  
0590:  RCALL  055C
....................              
....................     i2cHighScl();    //Pull SCL high      
0592:  RCALL  056C
....................     i2cLowSda();     //Now Pull SDA LOW, to generate the Start Condition   
0594:  RCALL  057C
....................                             
....................     i2cLowScl();     //Finally Clear the SCL to complete the cycle      
0596:  RCALL  054A
0598:  RETURN 0
.................... }                
....................   
.................... //This function is used to generate I2C Stop Condition. 
.................... //Stop Condition: SDA goes High when SCL is High. 
.................... //              __________ 
.................... // SCL:        |         |                 
.................... //        _____|         |___________                 
.................... //                ___________________   
.................... // SDA:          |            
.................... //      _________|       
.................... void _I2C_Stop(void){ 
....................     i2cLowScl();   // Pull SCL low             
*
05C4:  RCALL  054A
....................     i2cLowSda();   // Pull SDA  low 
05C6:  RCALL  057C
....................                       
....................     i2cHighScl();  // Pull SCL High  
05C8:  RCALL  056C
....................     i2cHighSda();  // Now Pull SDA High, to generate the Stop Condition 
05CA:  RCALL  055C
05CC:  RETURN 0
.................... }          
....................  
.................... void i2cHighSda(void){     
....................    SDA_DIR = 1;      // bring SDA to high impedance 
*
055C:  BSF    F94.4
....................    delay_us(5);       
055E:  MOVLW  02
0560:  MOVWF  00
0562:  DECFSZ 00,F
0564:  BRA    0562
0566:  BRA    0568
0568:  NOP   
056A:  RETURN 0
.................... }                                        
.................... void i2cLowSda(void){ 
....................    SDA = 0;   
*
057C:  BCF    F82.4
....................    SDA_DIR = 0;      // output a logic zero 
057E:  BCF    F94.4
....................    delay_us(5); 
0580:  MOVLW  02
0582:  MOVWF  00
0584:  DECFSZ 00,F
0586:  BRA    0584
0588:  BRA    058A
058A:  NOP   
058C:  RETURN 0
.................... }                                                                          
.................... void i2cHighScl(void){ 
....................    SCL_DIR = 1;      // bring SCL to high impedance 
*
056C:  BSF    F94.3
....................    delay_us(5);         
056E:  MOVLW  02
0570:  MOVWF  00
0572:  DECFSZ 00,F
0574:  BRA    0572
0576:  BRA    0578
0578:  NOP   
057A:  RETURN 0
.................... }             
.................... void i2cLowScl(void){ 
....................    SCL= 0;       
*
054A:  BCF    F82.3
....................    SCL_DIR = 0; 
054C:  BCF    F94.3
....................    delay_us(5); 
054E:  MOVLW  02
0550:  MOVWF  00
0552:  DECFSZ 00,F
0554:  BRA    0552
0556:  BRA    0558
0558:  NOP   
055A:  RETURN 0
.................... }        
....................                
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define DS1307_ID 0xD0     // DS1307 ID 
.................... #define SEC_ADDRESS   0x00 // Address to access Ds1307 SEC register 
.................... #define DATE_ADDRESS  0x04 // Address to access Ds1307 DATE register 
.................... #define CONTROL 0x07       // Address to access Ds1307 CONTROL register 
....................                                         
.................... // START(0) <--------------0xD - 13 is adres of DS1307----------------->  <-R/W->                  <-DATA->    ACK    STOP(1)  
.................... //|------| |------| |------| |------| |------| |------| |------| |------| |------|       |------|  |------| |------| |------|   
.................... //|  S   | |   1  |-|   1  |-|   0  |-|   1  |-|   0  |-|   0  |-|   0  |-|   0  |       |   0  |  |nx8BIT| |   0  | |  P   |    
.................... //|------| |------| |------| |------| |------| |------| |------| |------| |------|       |------|  |------| |------| |------|    
.................... //          7.Bit    6.Bit    5.Bit    4.Bit    3.Bit    2.Bit    1.Bit    0.Bit           ACK                       
....................                          
.................... uchar_t sec, min, hrs; 
.................... uchar_t day, month, yr, dow;          
.................... uchar_t dayText[4];       
.................... uchar_t DATE_TIME[32];   
....................        
....................                             
.................... void DS1307_Init(){                                      
....................     _I2C_Start();              // Start I2C communication 
*
05CE:  RCALL  058E
....................     _I2C_Write(DS1307_ID);   // Connect to DS1307 by sending its ID on I2c Bus 
05D0:  MOVLW  D0
05D2:  MOVWF  72
05D4:  RCALL  05A2
....................     _I2C_Write(CONTROL);     // Select the Ds1307 ControlRegister to configure Ds1307                    
05D6:  MOVLW  07
05D8:  MOVWF  72
05DA:  RCALL  05A2
....................     _I2C_Write(0x00);        // Write 0x00 to Control register to disable SQW-Out 
05DC:  CLRF   72
05DE:  RCALL  05A2
....................     _I2C_Stop();               // Stop I2C communication after initilizing DS1307            
05E0:  RCALL  05C4
05E2:  GOTO   0138 (RETURN)
....................  }                             
....................  
.................... void ds1307_set_date_time(uchar_t day_t, uchar_t mth_t, uchar_t year_t, uchar_t dow_t, uchar_t hr_t, uchar_t min_t, uchar_t sec_t){      
....................                                        
....................    sec_t &= 0x7F;                     
*
0606:  BCF    70.7
....................    min_t &= 0x7F; 
0608:  BCF    6F.7
....................    hr_t &= (0x7F|0x40);  //format 24H                   
060A:  BCF    6E.7
....................                      
....................   _I2C_Start();                // I2C write address   
060C:  RCALL  058E
....................   _I2C_Write(0xD0);            // Start at REG 0 - Seconds 
060E:  MOVLW  D0
0610:  MOVWF  72
0612:  RCALL  05A2
....................   _I2C_Write(0x00);            // Start at REG 0 - Seconds 
0614:  CLRF   72
0616:  RCALL  05A2
....................   _I2C_Write(bin2bcd(sec_t));      // REG 0 
0618:  MOVFF  70,71
061C:  RCALL  05E6
061E:  MOVFF  01,71
0622:  MOVFF  01,72
0626:  RCALL  05A2
....................   _I2C_Write(bin2bcd(min_t));      // REG 1 
0628:  MOVFF  6F,71
062C:  RCALL  05E6
062E:  MOVFF  01,71
0632:  MOVFF  01,72
0636:  RCALL  05A2
....................   _I2C_Write(bin2bcd(hr_t));      // REG 2            
0638:  MOVFF  6E,71
063C:  RCALL  05E6
063E:  MOVFF  01,71
0642:  MOVFF  01,72
0646:  RCALL  05A2
....................   _I2C_Write(bin2bcd(dow_t));      // REG 3              
0648:  MOVFF  6D,71
064C:  RCALL  05E6
064E:  MOVFF  01,71
0652:  MOVFF  01,72
0656:  RCALL  05A2
....................   _I2C_Write(bin2bcd(day_t));      // REG 4  
0658:  MOVFF  6A,71
065C:  RCALL  05E6
065E:  MOVFF  01,71
0662:  MOVFF  01,72
0666:  RCALL  05A2
....................   _I2C_Write(bin2bcd(mth_t));      // REG 5   
0668:  MOVFF  6B,71
066C:  RCALL  05E6
066E:  MOVFF  01,71
0672:  MOVFF  01,72
0676:  RCALL  05A2
....................   _I2C_Write(bin2bcd(year_t));     // REG 6   
0678:  MOVFF  6C,71
067C:  RCALL  05E6
067E:  MOVFF  01,71
0682:  MOVFF  01,72
0686:  RCALL  05A2
....................   _I2C_Stop();  
0688:  RCALL  05C4
068A:  GOTO   0160 (RETURN)
.................... }                                                 
....................                                                      
.................... void ds1307_get_date(){  
....................    _I2C_Start();  
*
0ABE:  RCALL  058E
....................    _I2C_Write(0xD0);   
0AC0:  MOVLW  D0
0AC2:  MOVWF  72
0AC4:  RCALL  05A2
....................    _I2C_Write(0x03);                         // Start at REG 3 - Day of week 
0AC6:  MOVLW  03
0AC8:  MOVWF  72
0ACA:  RCALL  05A2
....................    _I2C_Start();  
0ACC:  RCALL  058E
....................    _I2C_Write(0xD1);          
0ACE:  MOVLW  D1
0AD0:  MOVWF  72
0AD2:  RCALL  05A2
....................    // lecture DS1307 retourne (une valeur binaire codee BCD 
....................    // ex retourne 19 ou 0x13   l'an 13        
....................    dow  = bcd2bin(_I2C_Read(1)  & 0x07);   // REG 3 
0AD4:  MOVLW  01
0AD6:  MOVWF  6A
0AD8:  RCALL  06AA
0ADA:  MOVF   01,W
0ADC:  ANDLW  07
0ADE:  MOVWF  6A
0AE0:  MOVWF  6B
0AE2:  RCALL  06D6
0AE4:  MOVFF  01,41
....................    day  = bcd2bin(_I2C_Read(1)  & 0x3f);   // REG 4  
0AE8:  MOVLW  01
0AEA:  MOVWF  6A
0AEC:  RCALL  06AA
0AEE:  MOVF   01,W
0AF0:  ANDLW  3F
0AF2:  MOVWF  6A
0AF4:  MOVWF  6B
0AF6:  RCALL  06D6
0AF8:  MOVFF  01,3E
....................    month  = bcd2bin(_I2C_Read(1)& 0x1f);   // REG 5  
0AFC:  MOVLW  01
0AFE:  MOVWF  6A
0B00:  RCALL  06AA
0B02:  MOVF   01,W
0B04:  ANDLW  1F
0B06:  MOVWF  6A
0B08:  MOVWF  6B
0B0A:  RCALL  06D6
0B0C:  MOVFF  01,3F
....................    yr = bcd2bin(_I2C_Read(0));    // REG 6         
0B10:  CLRF   6A
0B12:  RCALL  06AA
0B14:  MOVFF  01,6A
0B18:  MOVFF  01,6B
0B1C:  RCALL  06D6
0B1E:  MOVFF  01,40
....................    _I2C_Stop();                
0B22:  RCALL  05C4
....................    getDayText();  
0B24:  BRA    089A
....................    //.  14 : 00 : 25  . 
....................     // Fri - 24/07/23   
....................    sprintf(DATE_TIME,"  \%02d : \%02d : \%02d   %s - \%02d/\%02d/\%02d",hrs,min,sec,dayText,day,month,yr);  
0B26:  CLRF   69
0B28:  MOVLW  46
0B2A:  MOVWF  68
0B2C:  MOVLW  20
0B2E:  MOVWF  70
0B30:  RCALL  0970
0B32:  MOVLW  20
0B34:  MOVWF  70
0B36:  RCALL  0970
0B38:  MOVFF  3D,6A
0B3C:  MOVLW  01
0B3E:  MOVWF  6B
0B40:  RCALL  09B4
0B42:  MOVLW  D8
0B44:  MOVWF  FF6
0B46:  MOVLW  00
0B48:  MOVWF  FF7
0B4A:  MOVLW  03
0B4C:  MOVWF  6A
0B4E:  RCALL  0A5E
0B50:  MOVFF  3C,6A
0B54:  MOVLW  01
0B56:  MOVWF  6B
0B58:  RCALL  09B4
0B5A:  MOVLW  DF
0B5C:  MOVWF  FF6
0B5E:  MOVLW  00
0B60:  MOVWF  FF7
0B62:  MOVLW  03
0B64:  MOVWF  6A
0B66:  RCALL  0A5E
0B68:  MOVFF  3B,6A
0B6C:  MOVLW  01
0B6E:  MOVWF  6B
0B70:  RCALL  09B4
0B72:  MOVLW  E6
0B74:  MOVWF  FF6
0B76:  MOVLW  00
0B78:  MOVWF  FF7
0B7A:  MOVLW  03
0B7C:  MOVWF  6A
0B7E:  RCALL  0A5E
0B80:  CLRF   FEA
0B82:  MOVLW  42
0B84:  MOVWF  FE9
0B86:  BRA    0A7C
0B88:  MOVLW  EB
0B8A:  MOVWF  FF6
0B8C:  MOVLW  00
0B8E:  MOVWF  FF7
0B90:  MOVLW  03
0B92:  MOVWF  6A
0B94:  RCALL  0A5E
0B96:  MOVFF  3E,6A
0B9A:  MOVLW  01
0B9C:  MOVWF  6B
0B9E:  RCALL  09B4
0BA0:  MOVLW  2F
0BA2:  MOVWF  70
0BA4:  RCALL  0970
0BA6:  MOVFF  3F,6A
0BAA:  MOVLW  01
0BAC:  MOVWF  6B
0BAE:  RCALL  09B4
0BB0:  MOVLW  2F
0BB2:  MOVWF  70
0BB4:  RCALL  0970
0BB6:  MOVFF  40,6A
0BBA:  MOVLW  01
0BBC:  MOVWF  6B
0BBE:  RCALL  09B4
....................    memset(strLCD,0,32);        
0BC0:  CLRF   FEA
0BC2:  MOVLW  19
0BC4:  MOVWF  FE9
0BC6:  CLRF   00
0BC8:  CLRF   02
0BCA:  MOVLW  20
0BCC:  MOVWF  01
0BCE:  BRA    0AA2
....................    memcpy(strLCD,DATE_TIME,32); 
0BD0:  CLRF   FEA
0BD2:  MOVLW  19
0BD4:  MOVWF  FE9
0BD6:  CLRF   FE2
0BD8:  MOVLW  46
0BDA:  MOVWF  FE1
0BDC:  MOVLW  20
0BDE:  MOVWF  01
0BE0:  MOVFF  FE6,FEE
0BE4:  DECFSZ 01,F
0BE6:  BRA    0BE0
0BE8:  GOTO   0174 (RETURN)
.................... }                                        
....................                                                        
.................... void ds1307_get_time(){    
....................    _I2C_Start();   
*
06F0:  RCALL  058E
....................    _I2C_Write(0XD0);     
06F2:  MOVLW  D0
06F4:  MOVWF  72
06F6:  RCALL  05A2
....................    _I2C_Write(0x00);                        // Start at REG 0 - Secondes  
06F8:  CLRF   72
06FA:  RCALL  05A2
....................    _I2C_Start();   
06FC:  RCALL  058E
....................    _I2C_Write(0XD1);            
06FE:  MOVLW  D1
0700:  MOVWF  72
0702:  RCALL  05A2
....................    sec = bcd2bin(_I2C_Read(1) & 0x7f);          
0704:  MOVLW  01
0706:  MOVWF  6A
0708:  RCALL  06AA
070A:  MOVF   01,W
070C:  ANDLW  7F
070E:  MOVWF  6A
0710:  MOVWF  6B
0712:  RCALL  06D6
0714:  MOVFF  01,3B
....................    min = bcd2bin(_I2C_Read(1) & 0x7f); 
0718:  MOVLW  01
071A:  MOVWF  6A
071C:  RCALL  06AA
071E:  MOVF   01,W
0720:  ANDLW  7F
0722:  MOVWF  6A
0724:  MOVWF  6B
0726:  RCALL  06D6
0728:  MOVFF  01,3C
....................    hrs = bcd2bin(_I2C_Read(0) & 0x7f);    
072C:  CLRF   6A
072E:  RCALL  06AA
0730:  MOVF   01,W
0732:  ANDLW  7F
0734:  MOVWF  6A
0736:  MOVWF  6B
0738:  RCALL  06D6
073A:  MOVFF  01,3D
....................    _I2C_Stop();   
073E:  RCALL  05C4
0740:  GOTO   0170 (RETURN)
....................    //.  14 : 00 : 25  . 
....................    //sprintf(TIME,"  \%02d : \%02d : \%02d  ",hrs,min,sec); 
.................... }                                                                                     
....................             
....................        
.................... void getDayText(){                           
....................    switch(day_of_the_week(getYear(),getMonth(),getDay())){ 
*
089A:  RCALL  0744
089C:  MOVFF  01,6A
08A0:  RCALL  074A
08A2:  MOVFF  01,6B
08A6:  BRA    0750
08A8:  MOVFF  01,6C
08AC:  CLRF   6E
08AE:  MOVFF  6A,6D
08B2:  CLRF   70
08B4:  MOVFF  6B,6F
08B8:  CLRF   72
08BA:  MOVFF  01,71
08BE:  BRA    079A
08C0:  MOVFF  01,00
08C4:  MOVF   02,W
08C6:  MOVWF  03
08C8:  BNZ   08CE
08CA:  MOVF   00,F
08CC:  BZ    090C
08CE:  MOVF   03,W
08D0:  BNZ   08D8
08D2:  MOVLW  01
08D4:  SUBWF  00,W
08D6:  BZ    091A
08D8:  MOVF   03,W
08DA:  BNZ   08E2
08DC:  MOVLW  02
08DE:  SUBWF  00,W
08E0:  BZ    0928
08E2:  MOVF   03,W
08E4:  BNZ   08EC
08E6:  MOVLW  03
08E8:  SUBWF  00,W
08EA:  BZ    0936
08EC:  MOVF   03,W
08EE:  BNZ   08F6
08F0:  MOVLW  04
08F2:  SUBWF  00,W
08F4:  BZ    0944
08F6:  MOVF   03,W
08F8:  BNZ   0900
08FA:  MOVLW  05
08FC:  SUBWF  00,W
08FE:  BZ    0952
0900:  MOVF   03,W
0902:  BNZ   090A
0904:  MOVLW  06
0906:  SUBWF  00,W
0908:  BZ    0960
090A:  BRA    096C
....................      case 0: memcpy(dayText,"Sun",3); break; 
090C:  MOVLW  53
090E:  MOVWF  42
0910:  MOVLW  75
0912:  MOVWF  43
0914:  MOVLW  6E
0916:  MOVWF  44
0918:  BRA    096C
....................      case 1: memcpy(dayText,"Mon",3); break; 
091A:  MOVLW  4D
091C:  MOVWF  42
091E:  MOVLW  6F
0920:  MOVWF  43
0922:  MOVLW  6E
0924:  MOVWF  44
0926:  BRA    096C
....................      case 2: memcpy(dayText,"Tue",3); break; 
0928:  MOVLW  54
092A:  MOVWF  42
092C:  MOVLW  75
092E:  MOVWF  43
0930:  MOVLW  65
0932:  MOVWF  44
0934:  BRA    096C
....................      case 3: memcpy(dayText,"Wed",3); break; 
0936:  MOVLW  57
0938:  MOVWF  42
093A:  MOVLW  65
093C:  MOVWF  43
093E:  MOVLW  64
0940:  MOVWF  44
0942:  BRA    096C
....................      case 4: memcpy(dayText,"Thu",3); break; 
0944:  MOVLW  54
0946:  MOVWF  42
0948:  MOVLW  68
094A:  MOVWF  43
094C:  MOVLW  75
094E:  MOVWF  44
0950:  BRA    096C
....................      case 5: memcpy(dayText,"Fri",3); break; 
0952:  MOVLW  46
0954:  MOVWF  42
0956:  MOVLW  72
0958:  MOVWF  43
095A:  MOVLW  69
095C:  MOVWF  44
095E:  BRA    096C
....................      case 6: memcpy(dayText,"Sat",3); break; 
0960:  MOVLW  53
0962:  MOVWF  42
0964:  MOVLW  61
0966:  MOVWF  43
0968:  MOVLW  74
096A:  MOVWF  44
....................    }    
096C:  GOTO   0B26 (RETURN)
.................... }    
....................  
.................... uchar_t getSec(){ 
....................    return sec;   
*
0BFC:  MOVF   3B,W
0BFE:  MOVWF  01
0C00:  GOTO   0188 (RETURN)
.................... }  
.................... uchar_t getMin(){ 
....................    return min;   
*
0BF4:  MOVF   3C,W
0BF6:  MOVWF  01
0BF8:  GOTO   0180 (RETURN)
.................... }   
.................... uchar_t getHour(){                     
....................    return hrs; 
*
0BEC:  MOVF   3D,W
0BEE:  MOVWF  01
0BF0:  GOTO   0178 (RETURN)
.................... }   
.................... uchar_t getDow(){ 
....................    return dow;   
.................... }   
.................... uchar_t getDay(){ 
....................    return day;   
*
0750:  MOVF   3E,W
0752:  MOVWF  01
0754:  GOTO   08A8 (RETURN)
.................... }  
.................... uchar_t getMonth(){ 
....................    return month;   
*
074A:  MOVF   3F,W
074C:  MOVWF  01
074E:  RETURN 0
.................... }   
.................... uchar_t getYear(){ 
....................    return yr;   
*
0744:  MOVF   40,W
0746:  MOVWF  01
0748:  RETURN 0
.................... }   
....................  
.................... // <-------------      (0-7, Start Sunday)       ----------->  
.................... uint16_t day_of_the_week(uint16_t Y, uint16_t M, uint16_t D) {  
....................    uint16_t days[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };  
*
079A:  CLRF   73
079C:  CLRF   74
079E:  MOVLW  03
07A0:  MOVWF  75
07A2:  CLRF   76
07A4:  MOVLW  02
07A6:  MOVWF  77
07A8:  CLRF   78
07AA:  MOVLW  05
07AC:  MOVWF  79
07AE:  CLRF   7A
07B0:  CLRF   7B
07B2:  CLRF   7C
07B4:  MOVLW  03
07B6:  MOVWF  7D
07B8:  CLRF   7E
07BA:  MOVLW  05
07BC:  MOVWF  7F
07BE:  CLRF   x80
07C0:  MOVLW  01
07C2:  MOVWF  x81
07C4:  CLRF   x82
07C6:  MOVLW  04
07C8:  MOVWF  x83
07CA:  CLRF   x84
07CC:  MOVLW  06
07CE:  MOVWF  x85
07D0:  CLRF   x86
07D2:  MOVLW  02
07D4:  MOVWF  x87
07D6:  CLRF   x88
07D8:  MOVLW  04
07DA:  MOVWF  x89
07DC:  CLRF   x8A
....................    if (M < 3)  
07DE:  MOVF   70,F
07E0:  BNZ   07F0
07E2:  MOVF   6F,W
07E4:  SUBLW  02
07E6:  BNC   07F0
....................       Y--;         
07E8:  MOVF   6D,W
07EA:  BTFSC  FD8.2
07EC:  DECF   6E,F
07EE:  DECF   6D,F
....................    return (Y + Y / 4 - Y / 100 + Y / 400 + days[M - 1] + D) % 7;  
07F0:  RRCF   6E,W
07F2:  MOVWF  03
07F4:  RRCF   6D,W
07F6:  MOVWF  02
07F8:  RRCF   03,F
07FA:  RRCF   02,F
07FC:  MOVLW  3F
07FE:  ANDWF  03,F
0800:  MOVF   02,W
0802:  ADDWF  6D,W
0804:  MOVWF  x8B
0806:  MOVF   03,W
0808:  ADDWFC 6E,W
080A:  MOVWF  x8C
080C:  MOVFF  6E,8E
0810:  MOVFF  6D,8D
0814:  CLRF   x90
0816:  MOVLW  64
0818:  MOVWF  x8F
081A:  RCALL  0758
081C:  MOVFF  02,03
0820:  MOVF   01,W
0822:  SUBWF  x8B,F
0824:  MOVF   02,W
0826:  SUBWFB x8C,F
0828:  MOVFF  6E,8E
082C:  MOVFF  6D,8D
0830:  MOVLW  01
0832:  MOVWF  x90
0834:  MOVLW  90
0836:  MOVWF  x8F
0838:  RCALL  0758
083A:  MOVFF  02,03
083E:  MOVF   01,W
0840:  ADDWF  x8B,F
0842:  MOVF   02,W
0844:  ADDWFC x8C,F
0846:  MOVLW  01
0848:  SUBWF  6F,W
084A:  MOVWF  x8D
084C:  MOVLW  00
084E:  SUBWFB 70,W
0850:  MOVWF  x8E
0852:  BCF    FD8.0
0854:  RLCF   x8D,W
0856:  MOVWF  02
0858:  RLCF   x8E,W
085A:  MOVWF  03
085C:  MOVF   02,W
085E:  ADDLW  73
0860:  MOVWF  FE9
0862:  MOVLW  00
0864:  ADDWFC 03,W
0866:  MOVWF  FEA
0868:  MOVFF  FEC,03
086C:  MOVF   FED,F
086E:  MOVF   FEF,W
0870:  ADDWF  x8B,F
0872:  MOVF   03,W
0874:  ADDWFC x8C,F
0876:  MOVF   71,W
0878:  ADDWF  x8B,F
087A:  MOVF   72,W
087C:  ADDWFC x8C,F
087E:  MOVFF  8C,8E
0882:  MOVFF  8B,8D
0886:  CLRF   x90
0888:  MOVLW  07
088A:  MOVWF  x8F
088C:  RCALL  0758
088E:  MOVFF  00,01
0892:  MOVFF  03,02
0896:  GOTO   08C0 (RETURN)
.................... }                    
....................  
....................                                                                                                                 
....................  
....................  
....................                               
....................                                     
.................... //TIMER1 UNION STRUCTURE AND COUNT MS 
.................... tmr1_time_t tmr1_time;  
.................... uint16_t iSayac;     
....................                                            
....................  
....................                       
.................... void setupTimerIOSC(void){          
....................             
....................    //Setup Osilator 
....................    IRCF2 = 1; 
*
0456:  BSF    FD3.6
....................    IRCF1 = 1; 
0458:  BSF    FD3.5
....................    IRCF0 = 1; 
045A:  BSF    FD3.4
....................    ADCON1 = 0x0F; 
045C:  MOVLW  0F
045E:  MOVWF  FC1
....................                          
....................    //D ve P portlari cikis olarak ayarlanip sifirlandi. 
....................    TRISB = 0x00;                  
0460:  CLRF   F93
....................    TRISD = 0x00; 
0462:  CLRF   F95
....................    TRISE = 0x00;                   
0464:  CLRF   F96
....................    PORTB = 0x00;                                                       
0466:  CLRF   F81
....................    PORTD = 0x00; 
0468:  CLRF   F8C
....................    PORTE = 0x00;          
046A:  CLRF   F84
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
046C:  CLRF   18
....................  
....................    // Kesmelere izin verildi 
....................    RCON_IPEN = 1;                                               
046E:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 1; 
0470:  BSF    FF2.7
....................    INTCON_PEIE = 1;           
0472:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
0474:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
0476:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
0478:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit 
047A:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
047C:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
047E:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
0480:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
0482:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
0484:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
0486:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
0488:  MOVLW  F8
048A:  MOVWF  FCF
....................    TMR1L = 0x30; // |||65436 decimal sayisina esit. 
048C:  MOVLW  30
048E:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit                                            
0490:  BSF    FCD.0
0492:  GOTO   0134 (RETURN)
.................... } 
....................                       
.................... void printOn2x16(){                   
....................    delayUsFun(40);                                                                                                                                       
*
050A:  MOVLW  28
050C:  MOVWF  6E
050E:  RCALL  0496
....................    twoLinesBCDMode(); 
0510:  BRA    04D8
....................    LinesActive();   
0512:  BRA    04E2
....................    lcdCursorOff(); 
0514:  BRA    04EC
....................    lcdShiftRight();                      
0516:  BRA    04F6
....................    lcdClear();                                                    
0518:  BRA    0500
....................    memcpy(strLCD, "INFORMELEKTRONIKAR-GE    STAJYER", 32); 
051A:  CLRF   FEA
051C:  MOVLW  19
051E:  MOVWF  FE9
0520:  MOVFF  FF2,6A
0524:  BCF    FF2.7
0526:  MOVLW  20
0528:  MOVWF  01
052A:  CLRF   FF7
052C:  MOVLW  00
052E:  RCALL  0096
0530:  TBLRD*-
0532:  TBLRD*+
0534:  MOVFF  FF5,FEE
0538:  DECFSZ 01,F
053A:  BRA    0532
053C:  BTFSC  6A.7
053E:  BSF    FF2.7
....................    countLCDChar=0;  
0540:  CLRF   39
....................    LCDW1SecFlag=1; 
0542:  MOVLW  01
0544:  MOVWF  3A
0546:  GOTO   0136 (RETURN)
....................    // LCD_Custom_CHAR(7, legrandLCDCharacter); 
....................    //LCD_Custom_CHAR(6, stickManLCDCharacter);                                
.................... }                           
....................   
.................... void I2C_Init() {            
....................     SCL_DIR=1;          //Set up I2C lines by setting as input  
....................     SDA_DIR=1;     
....................                     
....................     //SSPSTAT 
....................     SMP = 1; // 100Kbps 
....................     CKE = 0;    
....................      
....................     //SSPCON1                               
....................     SSPEN = 1; // SDA Y SCL                                  
....................     SSPM3 = 1; // Modo Maestro  
....................     SSPM2 = 0;                                                  
....................     SSPM1 = 0; 
....................     SSPM0 = 0;  
....................      
....................     SSPCON2 = 0x00; 
....................      
....................     SSPADD = 19; // 100Kbps   
....................     _I2C_Start();                    
....................     //SSPIF = 0;  
....................     //SSPIE = 1;   // Master Synchronous Serial Port Interrupt Enable bit  
....................      
.................... }                                   
.................... #INT_TIMER1                                                            
.................... void timer1_interrupt(){  
....................    TMR1H = 0xF8; //Tasma saayci| 
*
0402:  MOVLW  F8
0404:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.  
0406:  MOVLW  30
0408:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor. 
040A:  BCF    F9E.0
....................    iSayac++;  
040C:  INCF   16,F
040E:  BTFSC  FD8.2
0410:  INCF   17,F
....................    if (iSayac % 2 == 0) //2ms  
0412:  MOVF   16,W
0414:  ANDLW  01
0416:  MOVWF  x92
0418:  CLRF   x93
041A:  MOVF   x92,F
041C:  BNZ   0424
041E:  MOVF   x93,F
0420:  BNZ   0424
....................       tmr1_time.tmr1_flags._2ms = true;    
0422:  BSF    18.0
....................    if(iSayac > 1000){   // 1 Saniye   
0424:  MOVF   17,W
0426:  SUBLW  02
0428:  BC    043A
042A:  XORLW  FF
042C:  BNZ   0434
042E:  MOVF   16,W
0430:  SUBLW  E8
0432:  BC    043A
....................       tmr1_time.tmr1_flags._1000ms = true;  
0434:  BSF    18.6
....................       iSayac = 0;       
0436:  CLRF   17
0438:  CLRF   16
....................    }      
.................... }                              
....................                                    
043A:  BCF    F9E.0
043C:  GOTO   0054
.................... #ORG 0x0100,0x0400                                                                     
.................... void main(){                                  
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  MOVLW  70
0108:  MOVWF  FD3
010A:  MOVF   FD3,W
010C:  BCF    FB8.3
010E:  MOVLW  0C
0110:  MOVWF  FAF
0112:  MOVLW  A2
0114:  MOVWF  FAC
0116:  MOVLW  90
0118:  MOVWF  FAB
011A:  NOP   
011C:  NOP   
011E:  CLRF   69
0120:  CLRF   68
0122:  MOVF   FC1,W
0124:  ANDLW  C0
0126:  IORLW  0F
0128:  MOVWF  FC1
012A:  MOVLW  07
012C:  MOVWF  FB4
012E:  CLRF   66
0130:  CLRF   67
....................    setupTimerIOSC();                                                      
0132:  BRA    0456
....................    printOn2x16();  
0134:  BRA    050A
....................    DS1307_Init(); 
0136:  BRA    05CE
....................    delay_us(250);                     
0138:  MOVLW  A6
013A:  MOVWF  00
013C:  DECFSZ 00,F
013E:  BRA    013C
0140:  NOP   
....................    ds1307_set_date_time(26,7,23,2,13,30,25); 
0142:  MOVLW  1A
0144:  MOVWF  6A
0146:  MOVLW  07
0148:  MOVWF  6B
014A:  MOVLW  17
014C:  MOVWF  6C
014E:  MOVLW  02
0150:  MOVWF  6D
0152:  MOVLW  0D
0154:  MOVWF  6E
0156:  MOVLW  1E
0158:  MOVWF  6F
015A:  MOVLW  19
015C:  MOVWF  70
015E:  BRA    0606
....................    while (TRUE){            
....................      WDTreset();      
0160:  BRA    068E
....................      if(tmr1_time.tmr1_flags._1000ms){                       
0162:  BTFSS  18.6
0164:  BRA    0232
....................         tmr1_time.tmr1_flags._1000ms = false;  
0166:  BCF    18.6
....................         PORTB_7=~PORTB_7;                  
0168:  BTG    F81.7
....................         LCDW1SecFlag=1;  
016A:  MOVLW  01
016C:  MOVWF  3A
....................         ds1307_get_time(); 
016E:  BRA    06F0
....................         ds1307_get_date(); 
0170:  GOTO   0ABE
....................         printf("\f\%02d:\%02d:\%02d\r\n", getHour(), getMin(),getSec());  
0174:  GOTO   0BEC
0178:  MOVFF  01,6A
017C:  GOTO   0BF4
0180:  MOVFF  01,6B
0184:  GOTO   0BFC
0188:  MOVFF  01,6C
018C:  MOVLW  0C
018E:  BTFSS  F9E.4
0190:  BRA    018E
0192:  MOVWF  FAD
0194:  MOVFF  6A,6D
0198:  MOVLW  01
019A:  MOVWF  6E
019C:  CALL   0C04
01A0:  MOVLW  3A
01A2:  BTFSS  F9E.4
01A4:  BRA    01A2
01A6:  MOVWF  FAD
01A8:  MOVFF  6B,6D
01AC:  MOVLW  01
01AE:  MOVWF  6E
01B0:  CALL   0C04
01B4:  MOVLW  3A
01B6:  BTFSS  F9E.4
01B8:  BRA    01B6
01BA:  MOVWF  FAD
01BC:  MOVFF  6C,6D
01C0:  MOVLW  01
01C2:  MOVWF  6E
01C4:  CALL   0C04
01C8:  MOVLW  0D
01CA:  BTFSS  F9E.4
01CC:  BRA    01CA
01CE:  MOVWF  FAD
01D0:  MOVLW  0A
01D2:  BTFSS  F9E.4
01D4:  BRA    01D2
01D6:  MOVWF  FAD
....................         printf("\%02d/\%02d/\%02d -->%s",day, getMonth(), getYear(), dayText); 
01D8:  RCALL  074A
01DA:  MOVFF  01,6A
01DE:  RCALL  0744
01E0:  MOVFF  01,6B
01E4:  MOVFF  3E,6D
01E8:  MOVLW  01
01EA:  MOVWF  6E
01EC:  CALL   0C04
01F0:  MOVLW  2F
01F2:  BTFSS  F9E.4
01F4:  BRA    01F2
01F6:  MOVWF  FAD
01F8:  MOVFF  6A,6D
01FC:  MOVLW  01
01FE:  MOVWF  6E
0200:  CALL   0C04
0204:  MOVLW  2F
0206:  BTFSS  F9E.4
0208:  BRA    0206
020A:  MOVWF  FAD
020C:  MOVFF  6B,6D
0210:  MOVLW  01
0212:  MOVWF  6E
0214:  CALL   0C04
0218:  MOVLW  4E
021A:  MOVWF  FF6
021C:  MOVLW  04
021E:  MOVWF  FF7
0220:  MOVLW  04
0222:  MOVWF  6C
0224:  GOTO   0CB6
0228:  CLRF   FEA
022A:  MOVLW  42
022C:  MOVWF  FE9
022E:  GOTO   0CD8
....................   
....................      }                                                   
....................      if(tmr1_time.tmr1_flags._2ms){ 
0232:  BTFSS  18.0
0234:  BRA    0240
....................         tmr1_time.tmr1_flags._2ms = false;                                                                                               
0236:  BCF    18.0
....................         if(LCDW1SecFlag){      
0238:  MOVF   3A,F
023A:  BZ    0240
....................            LCD_String();        
023C:  GOTO   0D50
....................                                       
....................         }            
....................      }                    
0240:  BRA    0160
....................   }   
.................... }  
....................  
0242:  SLEEP 
.................... void WDTreset(void){          
....................    #asm                   
*
068E:  CLRWDT
....................    CLRWDT                           
....................    #endasm                                  
0690:  GOTO   0162 (RETURN)
.................... }                   
....................                                         

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 061E   PUT BROWNOUT BORV21 NOWDT WDT8
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
