CCS PCH C Compiler, Version 5.015, 5967               24-Aug-23 14:00

               Filename:   C:\18F4520\CCS\RS232(REG)-MODBUS(RTU)-DS1307(IIC)\main.lst

               ROM used:   5624 bytes (17%)
                           Largest free fragment is 26526
               RAM used:   377 (25%) at main() level
                           428 (28%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   069E
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
....................  
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir. 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0096:  CLRF   01
0098:  CLRF   02
009A:  CLRF   00
009C:  CLRF   03
009E:  MOVLB  1
00A0:  MOVF   xAA,W
00A2:  BNZ   00A8
00A4:  MOVF   xA9,W
00A6:  BZ    00D8
00A8:  MOVLW  10
00AA:  MOVWF  xAB
00AC:  BCF    FD8.0
00AE:  RLCF   xA7,F
00B0:  RLCF   xA8,F
00B2:  RLCF   00,F
00B4:  RLCF   03,F
00B6:  MOVF   xAA,W
00B8:  SUBWF  03,W
00BA:  BNZ   00C0
00BC:  MOVF   xA9,W
00BE:  SUBWF  00,W
00C0:  BNC   00D0
00C2:  MOVF   xA9,W
00C4:  SUBWF  00,F
00C6:  BTFSS  FD8.0
00C8:  DECF   03,F
00CA:  MOVF   xAA,W
00CC:  SUBWF  03,F
00CE:  BSF    FD8.0
00D0:  RLCF   01,F
00D2:  RLCF   02,F
00D4:  DECFSZ xAB,F
00D6:  BRA    00AC
00D8:  MOVLB  0
00DA:  RETURN 0
*
0402:  MOVFF  FF2,0D
0406:  BCF    FF2.7
0408:  CLRF   FF7
040A:  ADDLW  1C
040C:  MOVWF  FF6
040E:  MOVLW  04
0410:  ADDWFC FF7,F
0412:  TBLRD*+
0414:  MOVF   FF5,W
0416:  BTFSC  0D.7
0418:  BSF    FF2.7
041A:  RETURN 0
041C:  DATA 00,C1
041E:  DATA 81,40
0420:  DATA 01,C0
0422:  DATA 80,41
0424:  DATA 01,C0
0426:  DATA 80,41
0428:  DATA 00,C1
042A:  DATA 81,40
042C:  DATA 01,C0
042E:  DATA 80,41
0430:  DATA 00,C1
0432:  DATA 81,40
0434:  DATA 00,C1
0436:  DATA 81,40
0438:  DATA 01,C0
043A:  DATA 80,41
043C:  DATA 01,C0
043E:  DATA 80,41
0440:  DATA 00,C1
0442:  DATA 81,40
0444:  DATA 00,C1
0446:  DATA 81,40
0448:  DATA 01,C0
044A:  DATA 80,41
044C:  DATA 00,C1
044E:  DATA 81,40
0450:  DATA 01,C0
0452:  DATA 80,41
0454:  DATA 01,C0
0456:  DATA 80,41
0458:  DATA 00,C1
045A:  DATA 81,40
045C:  DATA 01,C0
045E:  DATA 80,41
0460:  DATA 00,C1
0462:  DATA 81,40
0464:  DATA 00,C1
0466:  DATA 81,40
0468:  DATA 01,C0
046A:  DATA 80,41
046C:  DATA 00,C1
046E:  DATA 81,40
0470:  DATA 01,C0
0472:  DATA 80,41
0474:  DATA 01,C0
0476:  DATA 80,41
0478:  DATA 00,C1
047A:  DATA 81,40
047C:  DATA 00,C1
047E:  DATA 81,40
0480:  DATA 01,C0
0482:  DATA 80,41
0484:  DATA 01,C0
0486:  DATA 80,41
0488:  DATA 00,C1
048A:  DATA 81,40
048C:  DATA 01,C0
048E:  DATA 80,41
0490:  DATA 00,C1
0492:  DATA 81,40
0494:  DATA 00,C1
0496:  DATA 81,40
0498:  DATA 01,C0
049A:  DATA 80,41
049C:  DATA 01,C0
049E:  DATA 80,41
04A0:  DATA 00,C1
04A2:  DATA 81,40
04A4:  DATA 00,C1
04A6:  DATA 81,40
04A8:  DATA 01,C0
04AA:  DATA 80,41
04AC:  DATA 00,C1
04AE:  DATA 81,40
04B0:  DATA 01,C0
04B2:  DATA 80,41
04B4:  DATA 01,C0
04B6:  DATA 80,41
04B8:  DATA 00,C1
04BA:  DATA 81,40
04BC:  DATA 00,C1
04BE:  DATA 81,40
04C0:  DATA 01,C0
04C2:  DATA 80,41
04C4:  DATA 01,C0
04C6:  DATA 80,41
04C8:  DATA 00,C1
04CA:  DATA 81,40
04CC:  DATA 01,C0
04CE:  DATA 80,41
04D0:  DATA 00,C1
04D2:  DATA 81,40
04D4:  DATA 00,C1
04D6:  DATA 81,40
04D8:  DATA 01,C0
04DA:  DATA 80,41
04DC:  DATA 00,C1
04DE:  DATA 81,40
04E0:  DATA 01,C0
04E2:  DATA 80,41
04E4:  DATA 01,C0
04E6:  DATA 80,41
04E8:  DATA 00,C1
04EA:  DATA 81,40
04EC:  DATA 01,C0
04EE:  DATA 80,41
04F0:  DATA 00,C1
04F2:  DATA 81,40
04F4:  DATA 00,C1
04F6:  DATA 81,40
04F8:  DATA 01,C0
04FA:  DATA 80,41
04FC:  DATA 01,C0
04FE:  DATA 80,41
0500:  DATA 00,C1
0502:  DATA 81,40
0504:  DATA 00,C1
0506:  DATA 81,40
0508:  DATA 01,C0
050A:  DATA 80,41
050C:  DATA 00,C1
050E:  DATA 81,40
0510:  DATA 01,C0
0512:  DATA 80,41
0514:  DATA 01,C0
0516:  DATA 80,41
0518:  DATA 00,C1
051A:  DATA 81,40
051C:  MOVFF  FF2,0D
0520:  BCF    FF2.7
0522:  CLRF   FF7
0524:  ADDLW  36
0526:  MOVWF  FF6
0528:  MOVLW  05
052A:  ADDWFC FF7,F
052C:  TBLRD*+
052E:  MOVF   FF5,W
0530:  BTFSC  0D.7
0532:  BSF    FF2.7
0534:  RETURN 0
0536:  DATA 00,C0
0538:  DATA C1,01
053A:  DATA C3,03
053C:  DATA 02,C2
053E:  DATA C6,06
0540:  DATA 07,C7
0542:  DATA 05,C5
0544:  DATA C4,04
0546:  DATA CC,0C
0548:  DATA 0D,CD
054A:  DATA 0F,CF
054C:  DATA CE,0E
054E:  DATA 0A,CA
0550:  DATA CB,0B
0552:  DATA C9,09
0554:  DATA 08,C8
0556:  DATA D8,18
0558:  DATA 19,D9
055A:  DATA 1B,DB
055C:  DATA DA,1A
055E:  DATA 1E,DE
0560:  DATA DF,1F
0562:  DATA DD,1D
0564:  DATA 1C,DC
0566:  DATA 14,D4
0568:  DATA D5,15
056A:  DATA D7,17
056C:  DATA 16,D6
056E:  DATA D2,12
0570:  DATA 13,D3
0572:  DATA 11,D1
0574:  DATA D0,10
0576:  DATA F0,30
0578:  DATA 31,F1
057A:  DATA 33,F3
057C:  DATA F2,32
057E:  DATA 36,F6
0580:  DATA F7,37
0582:  DATA F5,35
0584:  DATA 34,F4
0586:  DATA 3C,FC
0588:  DATA FD,3D
058A:  DATA FF,3F
058C:  DATA 3E,FE
058E:  DATA FA,3A
0590:  DATA 3B,FB
0592:  DATA 39,F9
0594:  DATA F8,38
0596:  DATA 28,E8
0598:  DATA E9,29
059A:  DATA EB,2B
059C:  DATA 2A,EA
059E:  DATA EE,2E
05A0:  DATA 2F,EF
05A2:  DATA 2D,ED
05A4:  DATA EC,2C
05A6:  DATA E4,24
05A8:  DATA 25,E5
05AA:  DATA 27,E7
05AC:  DATA E6,26
05AE:  DATA 22,E2
05B0:  DATA E3,23
05B2:  DATA E1,21
05B4:  DATA 20,E0
05B6:  DATA A0,60
05B8:  DATA 61,A1
05BA:  DATA 63,A3
05BC:  DATA A2,62
05BE:  DATA 66,A6
05C0:  DATA A7,67
05C2:  DATA A5,65
05C4:  DATA 64,A4
05C6:  DATA 6C,AC
05C8:  DATA AD,6D
05CA:  DATA AF,6F
05CC:  DATA 6E,AE
05CE:  DATA AA,6A
05D0:  DATA 6B,AB
05D2:  DATA 69,A9
05D4:  DATA A8,68
05D6:  DATA 78,B8
05D8:  DATA B9,79
05DA:  DATA BB,7B
05DC:  DATA 7A,BA
05DE:  DATA BE,7E
05E0:  DATA 7F,BF
05E2:  DATA 7D,BD
05E4:  DATA BC,7C
05E6:  DATA B4,74
05E8:  DATA 75,B5
05EA:  DATA 77,B7
05EC:  DATA B6,76
05EE:  DATA 72,B2
05F0:  DATA B3,73
05F2:  DATA B1,71
05F4:  DATA 70,B0
05F6:  DATA 50,90
05F8:  DATA 91,51
05FA:  DATA 93,53
05FC:  DATA 52,92
05FE:  DATA 96,56
0600:  DATA 57,97
0602:  DATA 55,95
0604:  DATA 94,54
0606:  DATA 9C,5C
0608:  DATA 5D,9D
060A:  DATA 5F,9F
060C:  DATA 9E,5E
060E:  DATA 5A,9A
0610:  DATA 9B,5B
0612:  DATA 99,59
0614:  DATA 58,98
0616:  DATA 88,48
0618:  DATA 49,89
061A:  DATA 4B,8B
061C:  DATA 8A,4A
061E:  DATA 4E,8E
0620:  DATA 8F,4F
0622:  DATA 8D,4D
0624:  DATA 4C,8C
0626:  DATA 44,84
0628:  DATA 85,45
062A:  DATA 87,47
062C:  DATA 46,86
062E:  DATA 82,42
0630:  DATA 43,83
0632:  DATA 41,81
0634:  DATA 80,40
0636:  MOVFF  FF2,0D
063A:  BCF    FF2.7
063C:  CLRF   FF7
063E:  ADDLW  50
0640:  MOVWF  FF6
0642:  MOVLW  06
0644:  ADDWFC FF7,F
0646:  TBLRD*+
0648:  MOVF   FF5,W
064A:  BTFSC  0D.7
064C:  BSF    FF2.7
064E:  RETURN 0
0650:  DATA 49,4E
0652:  DATA 46,4F
0654:  DATA 52,4D
0656:  DATA 45,4C
0658:  DATA 45,4B
065A:  DATA 54,52
065C:  DATA 4F,4E
065E:  DATA 49,4B
0660:  DATA 41,52
0662:  DATA 2D,47
0664:  DATA 45,20
0666:  DATA 20,20
0668:  DATA 20,53
066A:  DATA 54,41
066C:  DATA 4A,59
066E:  DATA 45,52
0670:  DATA 00,00
0672:  DATA 20,20
0674:  DATA 25,30
0676:  DATA 32,64
0678:  DATA 20,3A
067A:  DATA 20,25
067C:  DATA 30,32
067E:  DATA 64,20
0680:  DATA 3A,20
0682:  DATA 25,30
0684:  DATA 32,64
0686:  DATA 20,20
0688:  DATA 20,25
068A:  DATA 73,20
068C:  DATA 2D,20
068E:  DATA 25,30
0690:  DATA 32,64
0692:  DATA 2F,25
0694:  DATA 30,32
0696:  DATA 64,2F
0698:  DATA 25,30
069A:  DATA 32,64
069C:  DATA 00,00
*
0968:  TSTFSZ 01
096A:  BRA    0972
096C:  TSTFSZ 02
096E:  BRA    0974
0970:  BRA    0980
0972:  INCF   02,F
0974:  MOVFF  00,FEE
0978:  DECFSZ 01,F
097A:  BRA    0974
097C:  DECFSZ 02,F
097E:  BRA    0974
0980:  RETURN 0
*
1030:  MOVFF  FF2,0D
1034:  BCF    FF2.7
1036:  ADDWF  FE8,W
1038:  CLRF   FF7
103A:  RLCF   FF7,F
103C:  ADDLW  55
103E:  MOVWF  FF6
1040:  MOVLW  10
1042:  ADDWFC FF7,F
1044:  TBLRD*-
1046:  MOVF   FF5,W
1048:  MOVWF  FFA
104A:  TBLRD*
104C:  MOVF   FF5,W
104E:  BTFSC  0D.7
1050:  BSF    FF2.7
1052:  MOVWF  FF9
1054:  DATA 62,0F
1056:  DATA 68,0F
1058:  DATA 7E,0F
105A:  DATA 8A,0F
105C:  DATA A4,0F
105E:  DATA BE,0F
1060:  DATA D8,0F
1062:  DATA EC,0F
1064:  DATA 00,10
1066:  DATA 14,10
1068:  DATA 28,10
*
1196:  MOVFF  FF2,0D
119A:  BCF    FF2.7
119C:  ADDWF  FE8,W
119E:  CLRF   FF7
11A0:  RLCF   FF7,F
11A2:  ADDLW  BB
11A4:  MOVWF  FF6
11A6:  MOVLW  11
11A8:  ADDWFC FF7,F
11AA:  TBLRD*-
11AC:  MOVF   FF5,W
11AE:  MOVWF  FFA
11B0:  TBLRD*
11B2:  MOVF   FF5,W
11B4:  BTFSC  0D.7
11B6:  BSF    FF2.7
11B8:  MOVWF  FF9
11BA:  DATA DC,10
11BC:  DATA E4,10
11BE:  DATA FE,10
11C0:  DATA 0C,11
11C2:  DATA 14,11
11C4:  DATA 24,11
11C6:  DATA 46,11
11C8:  DATA 68,11
11CA:  DATA 8C,11
*
13EC:  MOVFF  7A,FEA
13F0:  MOVFF  79,FE9
13F4:  MOVLB  1
13F6:  MOVFF  185,FEF
13FA:  INCF   FE9,F
13FC:  BTFSC  FD8.2
13FE:  INCF   FEA,F
1400:  CLRF   FEF
1402:  INCF   79,F
1404:  BTFSC  FD8.2
1406:  INCF   7A,F
1408:  MOVLB  0
140A:  RETURN 0
140C:  MOVLB  1
140E:  MOVF   x86,W
1410:  CLRF   01
1412:  SUBWF  x85,W
1414:  BC    141C
1416:  MOVFF  185,00
141A:  BRA    1434
141C:  CLRF   00
141E:  MOVLW  08
1420:  MOVWF  x87
1422:  RLCF   x85,F
1424:  RLCF   00,F
1426:  MOVF   x86,W
1428:  SUBWF  00,W
142A:  BTFSC  FD8.0
142C:  MOVWF  00
142E:  RLCF   01,F
1430:  DECFSZ x87,F
1432:  BRA    1422
1434:  MOVLB  0
1436:  RETURN 0
1438:  MOVLW  20
143A:  MOVLB  1
143C:  BTFSS  x80.4
143E:  MOVLW  30
1440:  MOVWF  x81
1442:  MOVFF  17F,00
1446:  BTFSS  x7F.7
1448:  BRA    145A
144A:  COMF   00,F
144C:  INCF   00,F
144E:  MOVFF  00,17F
1452:  MOVLW  2D
1454:  MOVWF  x81
1456:  BSF    x80.7
1458:  BSF    x80.0
145A:  MOVF   01,W
145C:  MOVFF  17F,185
1460:  MOVLW  64
1462:  MOVWF  x86
1464:  MOVLB  0
1466:  RCALL  140C
1468:  MOVFF  00,17F
146C:  MOVLW  30
146E:  ADDWF  01,W
1470:  MOVLB  1
1472:  MOVWF  x82
1474:  MOVFF  17F,185
1478:  MOVLW  0A
147A:  MOVWF  x86
147C:  MOVLB  0
147E:  RCALL  140C
1480:  MOVLW  30
1482:  ADDWF  00,W
1484:  MOVLB  1
1486:  MOVWF  x84
1488:  MOVLW  30
148A:  ADDWF  01,W
148C:  MOVWF  x83
148E:  MOVFF  181,00
1492:  MOVLW  30
1494:  SUBWF  x82,W
1496:  BZ    14A0
1498:  BSF    x80.1
149A:  BTFSC  x80.7
149C:  BSF    x80.2
149E:  BRA    14C4
14A0:  BTFSC  x80.2
14A2:  BRA    14C4
14A4:  MOVFF  181,182
14A8:  BTFSC  x80.1
14AA:  BRA    14B4
14AC:  MOVLW  30
14AE:  SUBWF  x83,W
14B0:  BZ    14BA
14B2:  BSF    x80.0
14B4:  BTFSC  x80.7
14B6:  BSF    x80.1
14B8:  BRA    14C4
14BA:  BTFSS  FD8.2
14BC:  BSF    x80.0
14BE:  BTFSC  FD8.2
14C0:  MOVFF  182,183
14C4:  BTFSC  x80.2
14C6:  BRA    14D2
14C8:  BTFSC  x80.1
14CA:  BRA    14DA
14CC:  BTFSC  x80.0
14CE:  BRA    14E2
14D0:  BRA    14EA
14D2:  MOVFF  181,185
14D6:  MOVLB  0
14D8:  RCALL  13EC
14DA:  MOVFF  182,185
14DE:  MOVLB  0
14E0:  RCALL  13EC
14E2:  MOVFF  183,185
14E6:  MOVLB  0
14E8:  RCALL  13EC
14EA:  MOVFF  184,185
14EE:  MOVLB  0
14F0:  RCALL  13EC
14F2:  RETURN 0
14F4:  TBLRD*+
14F6:  MOVFF  FF6,180
14FA:  MOVFF  FF7,181
14FE:  MOVFF  FF5,185
1502:  RCALL  13EC
1504:  MOVFF  180,FF6
1508:  MOVFF  181,FF7
150C:  MOVLB  1
150E:  DECFSZ x7F,F
1510:  BRA    1514
1512:  BRA    1518
1514:  MOVLB  0
1516:  BRA    14F4
1518:  MOVLB  0
151A:  RETURN 0
151C:  MOVF   FEF,F
151E:  BZ    153E
1520:  MOVFF  FEA,180
1524:  MOVFF  FE9,17F
1528:  MOVFF  FEF,185
152C:  RCALL  13EC
152E:  MOVFF  180,FEA
1532:  MOVFF  17F,FE9
1536:  INCF   FE9,F
1538:  BTFSC  FD8.2
153A:  INCF   FEA,F
153C:  BRA    151C
153E:  GOTO   16D4 (RETURN)
*
1744:  MOVFF  FF2,0D
1748:  BCF    FF2.7
174A:  ADDWF  FE8,W
174C:  CLRF   FF7
174E:  RLCF   FF7,F
1750:  ADDLW  69
1752:  MOVWF  FF6
1754:  MOVLW  17
1756:  ADDWFC FF7,F
1758:  TBLRD*-
175A:  MOVF   FF5,W
175C:  MOVWF  FFA
175E:  TBLRD*
1760:  MOVF   FF5,W
1762:  BTFSC  0D.7
1764:  BSF    FF2.7
1766:  MOVWF  FF9
1768:  DATA 52,15
176A:  DATA 5A,15
176C:  DATA 74,15
176E:  DATA 84,15
1770:  DATA 8C,15
1772:  DATA 9C,15
1774:  DATA BA,15
1776:  DATA DC,15
1778:  DATA FE,15
177A:  DATA 1E,16
....................  
.................... #list 
....................  
....................    
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanýr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       Â· LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       Â· WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini saðlar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       Â· PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin içine yükleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       Â· PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       Â· BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       Â· INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       Â· NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */                                           
....................                                           
.................... #FUSES NOWDT, WDT1, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC  
.................... #use delay (internal=8MHz)                          
.................... //#use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7) 
....................                                                   
....................                                             
....................                                                
.................... #include "definitions.h"                                                                                                       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "main.h"                                   
.................... #ifndef MAIN_H      
.................... #define MAIN_H                   
.................... #define DELAY 1000  
....................      
.................... extern uint16_t iSayac;   
....................  
.................... void WDTreset(void);   
....................  
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"                
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                  
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
.................... #byte ADCON1 = 0x0FC1     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit     
....................  
....................   
....................   
.................... //   #############WATCHDOG#######   
.................... #byte WDTCON   = 0x0FD1  
.................... #bit WDTCON_SWDTEN =WDTCON.0    
....................                         
....................                                                                 
....................                                                                 
.................... //   ################   RS232/EUSART   #################  // 
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit       
....................                     
....................                     
....................                     
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................                   
....................                            
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h"                                       
.................... #ifndef INITS_H 
.................... #define INITS_H       
....................  
.................... extern uint16_t iSayac;                          
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _1ms    : 1;  //bit:0, 1ms  
....................       uint8_t _2ms    : 1;  //bit:1, 2ms    
....................       uint8_t _20ms   : 1;  //bit:2, 20ms    
....................       uint8_t _50ms   : 1;  //bit:3, 50ms  
....................       uint8_t _100ms  : 1;  //bit:4, 100ms     
....................       uint8_t _200ms  : 1;  //bit:5, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:6, 500ms  
....................       uint8_t _1000ms : 1;  //bit:7, 1000ms  
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t   tmr1_time;    
.................... uchar_t x = 0x08 | x;                 
....................                                                 
.................... #endif //INIT_H                               
....................  
.................... #include "button.h"   
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS;  
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t); 
....................    
.................... #endif            
....................  
.................... #include "DS1307.h" 
.................... #ifndef DS1307_H      
.................... #define DS1307_H    
....................  
.................... //DS1307 TIME-DATE INFO VARIABLES   
.................... extern uchar_t sec, min, hrs; 
.................... extern uchar_t day, month, yr, dow;       
.................... extern uchar_t dayText[4];  
.................... //READ WRITE SET QUEUE 
.................... extern uchar_t timeSwitchPosition; 
.................... //LCD BUFFER 
.................... extern uchar_t DATE_TIME[32]; 
....................             
....................  
.................... void DS1307_Init();     
.................... void ds1307_run(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t);   
.................... void ds1307_set_date_time(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t);   
.................... void ds1307_get_date(); 
.................... void ds1307_get_time();     
.................... void ds1307_write_date(); 
.................... void getDayText();                     
....................                
.................... uchar_t getSec(); 
.................... uchar_t getMin();                     
.................... uchar_t getHour(); 
....................                            
.................... uchar_t getDay();  
.................... uchar_t getMonth();  
.................... uchar_t getYear(); 
.................... uchar_t getDow();                                                                  
....................                 
.................... uint16_t day_of_the_week(uint16_t, uint16_t, uint16_t );                   
....................                     
.................... #endif //DS1307_H                      
....................                                        
....................  
.................... #include "usart_rs232.h" 
.................... #ifndef USART_RS232_H                                                                                                
.................... #define USART_RS232_H    
....................   
....................  
.................... uchar_t USART_RxCharBuffer(); 
.................... void USART_TxCharBuffer(uchar_t data); 
.................... void USART_Init();      
....................                                                    
.................... #endif  //USART_RS232_H 
....................                   
....................  
....................  
....................                             
.................... #include "lcd.h"   
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "lcd.c"                         
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                  
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
.................... #byte ADCON1 = 0x0FC1     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit     
....................  
....................   
....................   
.................... //   #############WATCHDOG#######   
.................... #byte WDTCON   = 0x0FD1  
.................... #bit WDTCON_SWDTEN =WDTCON.0    
....................                         
....................                                                                 
....................                                                                 
.................... //   ################   RS232/EUSART   #################  // 
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit       
....................                     
....................                     
....................                     
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................                   
....................                            
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "delayms.h"  
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................                  
....................                
.................... /*Hex Code   LCD Ekran Karsiligi  
....................  Initialize Lcd in 4-bit mode               0x02 
.................... 1   Function Set: 8-bit, 1 Line, 5×7 Dots   0x30   48                                              
.................... 2   Function Set: 8-bit, 2 Line, 5×7 Dots   0x38   56                            
.................... 3   Function Set: 4-bit, 1 Line, 5×7 Dots   0x20   32 
.................... 4   Function Set: 4-bit, 2 Line, 5×7 Dots   0x28   40  
.................... 0F   LCD acik, Imlec acik 
.................... 01   Ekrani Temizle                                 
.................... 02   Satir Basina Dön            
.................... 04   Imleci Sola Kaydir 
.................... 06   Imleci Saga Kaydir 
.................... 05   Ekrani Saga Kaydir 
.................... 07   Ekrani Sola Kaydir 
.................... 0E   Ekran Acik, Imleç Yanip Sonuyor 
.................... 80   Imleci Ilk Satirin Basinda Konumlandir 
.................... C0   Imleci Ikinci Satirin Basinda Konumlandir         
.................... 3C   Ikinci Satiri Etkinlestir                                                     
.................... 08   Ekran Kapali, Imleç Kapali              
.................... OC   Ekran Acik, Imlec Kapali*/   
....................                                             
.................... uchar_t strLCD[32]; 
.................... uint8_t countLCDChar; 
.................... uchar_t LCDW1SecFlag; 
....................                                          
.................... /*LCD (CHIP: HD44780), COMMAND MODE*/  
.................... void dis_cmd(uchar_t cmdout){  
....................    PORTD=cmdout;      //Send command to lcdport=PORTB 
*
0776:  MOVFF  17A,F8C
....................    PORTE_RS=0;                   
077A:  BCF    F84.0
....................    PORTE_E=1;    
077C:  BSF    F84.1
....................    delayUsFun(1); 
077E:  MOVLW  01
0780:  MOVLB  1
0782:  MOVWF  x7C
0784:  MOVLB  0
0786:  RCALL  00DC
....................    PORTE_E=0;                               
0788:  BCF    F84.1
078A:  RETURN 0
.................... }                                   
....................  
....................  
....................  
.................... void lcdcmd(uchar_t cmd_value){          
....................    uchar_t cmd_value1;                              
....................    cmd_value1 = (cmd_value & 0xF0);      // Mask lower nibble because RB4-RB7 pins are being used    
078C:  MOVLB  1
078E:  MOVF   x78,W
0790:  ANDLW  F0
0792:  MOVWF  x79
....................    dis_cmd(cmd_value1);                   // Send to LCD 
0794:  MOVFF  179,17A
0798:  MOVLB  0
079A:  RCALL  0776
....................    cmd_value1 = ((cmd_value<<4) & 0xF0);  // Shift 4-bit and mask 
079C:  MOVLB  1
079E:  SWAPF  x78,W
07A0:  MOVWF  00
07A2:  MOVLW  F0
07A4:  ANDWF  00,F
07A6:  MOVF   00,W
07A8:  ANDLW  F0
07AA:  MOVWF  x79
....................    dis_cmd(cmd_value1);                   // Send to LCD 
07AC:  MOVFF  179,17A
07B0:  MOVLB  0
07B2:  RCALL  0776
07B4:  RETURN 0
.................... } 
....................  // 2 lines are active.              
.................... void twoLinesBCDMode(){  
....................    lcdcmd(0x02); 
*
00EE:  MOVLW  02
00F0:  MOVLB  1
00F2:  MOVWF  x78
00F4:  MOVLB  0
00F6:  RCALL  078C
00F8:  GOTO   07FA (RETURN)
.................... } 
....................                         
.................... // 2 lines are active. BCD MODE 
.................... void LinesActive(){  
....................    lcdcmd(0x28);                
*
07B6:  MOVLW  28
07B8:  MOVLB  1
07BA:  MOVWF  x78
07BC:  MOVLB  0
07BE:  RCALL  078C
07C0:  GOTO   07FC (RETURN)
.................... }                          
.................... // LCD screen clear.                   
.................... void lcdClear(){ 
....................    lcdcmd(0x01);                   
*
07E0:  MOVLW  01
07E2:  MOVLB  1
07E4:  MOVWF  x78
07E6:  MOVLB  0
07E8:  RCALL  078C
07EA:  GOTO   0802 (RETURN)
.................... }                   
.................... // Go to first line. 
.................... void lcdGoToFirstLine(){  
....................    lcdcmd(0x80); 
*
17C6:  MOVLW  80
17C8:  MOVLB  1
17CA:  MOVWF  x78
17CC:  MOVLB  0
17CE:  CALL   078C
17D2:  GOTO   1830 (RETURN)
.................... }                                  
.................... // Go to second line.                        
.................... void lcdGoToSecondLine(){ 
....................    lcdcmd(0xC0); 
17D6:  MOVLW  C0
17D8:  MOVLB  1
17DA:  MOVWF  x78
17DC:  MOVLB  0
17DE:  CALL   078C
17E2:  GOTO   1838 (RETURN)
.................... }                        
.................... // Shift cursor to right. 
.................... void lcdShiftRight(){   
....................    lcdcmd(0x06);                                                     
*
07D2:  MOVLW  06
07D4:  MOVLB  1
07D6:  MOVWF  x78
07D8:  MOVLB  0
07DA:  RCALL  078C
07DC:  GOTO   0800 (RETURN)
.................... }                                           
.................... // Display on, Cursor on              
.................... void lcdCursorOn(){                  
....................    lcdcmd(0x0E); 
.................... }                                      
.................... //Display off, Cursor off 
.................... void lcdCursorOff(){                                             
....................    lcdcmd(0x0C);                             
*
07C4:  MOVLW  0C
07C6:  MOVLB  1
07C8:  MOVWF  x78
07CA:  MOVLB  0
07CC:  RCALL  078C
07CE:  GOTO   07FE (RETURN)
.................... }                              
....................   
.................... void dis_data(uchar_t dataout) {  
....................    PORTD=dataout;   //Send data to lcdport=PORTB 
*
17E6:  MOVFF  17B,F8C
....................    PORTE_RS=1;                   
17EA:  BSF    F84.0
....................    PORTE_E=1;                          
17EC:  BSF    F84.1
....................    delayUsFun(1); 
17EE:  MOVLW  01
17F0:  MOVLB  1
17F2:  MOVWF  x7C
17F4:  MOVLB  0
17F6:  CALL   00DC
....................    PORTE_E=0;   
17FA:  BCF    F84.1
17FC:  RETURN 0
....................    //PORTD=0x00; 
....................    //while(test_bit(PORTD,7));           
.................... }   
.................... /*DATA MODE*/   
.................... void lcddata(uchar_t text){  
....................    uchar_t data;                                                                 
....................    data=(text & 0xF0);         
17FE:  MOVLB  1
1800:  MOVF   x79,W
1802:  ANDLW  F0
1804:  MOVWF  x7A
....................    dis_data(data);     
1806:  MOVFF  17A,17B
180A:  MOVLB  0
180C:  RCALL  17E6
....................    data=((text<<4)&0xF0);      
180E:  MOVLB  1
1810:  SWAPF  x79,W
1812:  MOVWF  00
1814:  MOVLW  F0
1816:  ANDWF  00,F
1818:  MOVF   00,W
181A:  ANDLW  F0
181C:  MOVWF  x7A
....................    dis_data(data);                  
181E:  MOVFF  17A,17B
1822:  MOVLB  0
1824:  RCALL  17E6
1826:  GOTO   1856 (RETURN)
.................... }                                
.................... void LCD_String(){  
....................    if(countLCDChar==0)  
182A:  MOVF   69,F
182C:  BNZ   1830
....................       lcdGoToFirstLine(); 
182E:  BRA    17C6
....................    if(countLCDChar==16)   
1830:  MOVF   69,W
1832:  SUBLW  10
1834:  BNZ   1838
....................       lcdGoToSecondLine();    
1836:  BRA    17D6
....................    if(countLCDChar<=31){  
1838:  MOVF   69,W
183A:  SUBLW  1F
183C:  BNC   185A
....................       lcddata(strLCD[countLCDChar]); 
183E:  CLRF   03
1840:  MOVF   69,W
1842:  ADDLW  49
1844:  MOVWF  FE9
1846:  MOVLW  00
1848:  ADDWFC 03,W
184A:  MOVWF  FEA
184C:  MOVFF  FEF,178
1850:  MOVFF  178,179
1854:  BRA    17FE
....................       countLCDChar++;   
1856:  INCF   69,F
....................    }else{    
1858:  BRA    185E
....................       LCDW1SecFlag=0; 
185A:  CLRF   6A
....................       countLCDChar=0; 
185C:  CLRF   69
....................    }                  
185E:  GOTO   019C (RETURN)
.................... }  
....................  
....................  
.................... void LCD_Custom_Char(uchar_t loc, uchar_t *msg){ 
....................     uchar_t i; 
....................     if(loc<8) 
....................     { 
....................      lcdcmd(0x40 + (loc*8));    /* Command 0x40 and onwards forces the device to point CGRAM address */ 
....................      for(i=0;i<8;i++)          /* Write 8 byte for generation of 1 character */ 
....................         lcddata(msg[i]);       
....................     }                        
.................... } 
....................  
....................                                           
....................  
....................       
....................  
.................... #include "button.c"           
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "button.h" 
.................... #ifndef BUTTON_H                                                             
.................... #define BUTTON_H  
....................  
.................... extern uint8_t BUTTON_PRESSED_RELEASED;  /* bit:1, Aktif     */  
.................... extern uint8_t STATUS;  
.................... uint8_t button_debounce(uint8_t,uint8_t);    
.................... uint8_t test_bit(uint8_t,uint8_t); 
....................    
.................... #endif            
....................  
.................... uint8_t BUTTON_PRESSED_RELEASED; 
.................... uint8_t STATUS=0;             
....................  
.................... uint8_t test_bit(uint8_t valueOfInput, uint8_t bits){  
....................    return ((valueOfInput & (1<<bits)) != 0); 
.................... }                             
....................   
.................... uint8_t button_debounce(uint8_t valueOfInput, uint8_t bit){ 
....................    if(!test_bit(valueOfInput,bit)){ 
....................       BUTTON_PRESSED_RELEASED<<=1; 
....................    }else{                        
....................       BUTTON_PRESSED_RELEASED<<=1;                        
....................       BUTTON_PRESSED_RELEASED|=1;           
....................    }   
....................    if((BUTTON_PRESSED_RELEASED & 0x07)==0x07){  
....................       STATUS = 1; 
....................       return true;   
....................    }else if((BUTTON_PRESSED_RELEASED  & 0x07)==0x00){  
....................       STATUS = 0; 
....................       return false; 
....................    }else{  
....................       return STATUS; 
....................    } 
.................... }         
....................  
....................  
.................... #include "delayms.c"   
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs)  // Delay function - generates a delay of specified msecs 
.................... {   uint16_t i,j;  
....................     for(i=0;i<=msecs;i++){               
....................       for(j=0;j<197;j++); 
....................     }                                
.................... }  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
*
00DC:  MOVLB  1
00DE:  CLRF   x7D
00E0:  MOVF   x7D,W
00E2:  SUBWF  x7C,W
00E4:  BNC   00EA
00E6:  INCF   x7D,F
00E8:  BRA    00E0
....................     }                                
00EA:  MOVLB  0
00EC:  RETURN 0
.................... }   
....................  
....................  
.................... #include "DS1307.c"   
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///                               DS1307.C                                   /// 
.................... ///                     Driver for Real Time Clock                           /// 
.................... ///                                                                          /// 
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -/// 
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     /// 
.................... ///               - Disable squarewave output                                /// 
.................... ///                                                                          /// 
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             /// 
.................... ///                                                                          /// 
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             /// 
.................... ///                                                                          /// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
....................                                                                                               
.................... #include "binbcdconv.c"   
.................... #include "binbcdconv.h" 
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef BINBCDCONV_H         
.................... #define BINBCDCONV_H   
....................  
.................... uchar_t bin2bcd(uchar_t binary_value); 
.................... uchar_t bcd2bin(uchar_t bcd_value); 
....................                          
.................... #endif //BINBCDCONV_H      
....................  
....................                                                      
.................... uchar_t bin2bcd(uchar_t binary_value){ 
....................   uchar_t retval;                     
....................   retval = 0;                                                
*
0BB4:  MOVLB  1
0BB6:  CLRF   x87
....................   while(1){ 
....................     if(binary_value >= 10){    // 10'dan buyuk oldugu muddetce                                     
0BB8:  MOVF   x86,W
0BBA:  SUBLW  09
0BBC:  BC    0BC8
....................       binary_value   -= 10;    // 10 cikar 
0BBE:  MOVLW  0A
0BC0:  SUBWF  x86,F
....................       retval += 0x10;  //asil degiskenimizin MsB'sine 1 ekle      
0BC2:  MOVLW  10
0BC4:  ADDWF  x87,F
....................     }  
0BC6:  BRA    0BCE
....................     else{  
....................       retval += binary_value;  //artik 10'dan buyuk degil kalan 0-9 arasi sayiyi asil degiskenimize ekle                             
0BC8:  MOVF   x86,W
0BCA:  ADDWF  x87,F
....................       break;                 
0BCC:  BRA    0BD0
....................     } 
0BCE:  BRA    0BB8
....................   } 
....................   return(retval);   
0BD0:  MOVFF  187,01
0BD4:  MOVLB  0
0BD6:  RETURN 0
.................... } 
....................                            
....................                                
.................... // 8-Bit ile oldugu icin 0-99 arasi bir bcd sayi yazilmalidir.  
.................... uchar_t bcd2bin(uchar_t bcd_value){  
....................          // (bcd_value>>4)*10) BCD'nin 10 luk kisim ilk 4 bite kaydirildi ve 10 ile carpildi. 
....................          // (bcd_value & 0x0F) BCD'nin yuksek degerli 4 biti sifirlandi ve 0-9 kismi birakildi. 
....................          // 2 sayi toplanarak binary karsiligi elde edildi. 
....................   return ((bcd_value>>4)*10) + (bcd_value & 0x0F);   
*
10B0:  MOVLB  1
10B2:  SWAPF  x80,W
10B4:  MOVWF  00
10B6:  MOVLW  0F
10B8:  ANDWF  00,F
10BA:  MOVF   00,W
10BC:  MULLW  0A
10BE:  MOVFF  FF3,181
10C2:  MOVF   x80,W
10C4:  ANDLW  0F
10C6:  ADDWF  x81,W
10C8:  MOVWF  01
10CA:  MOVLB  0
10CC:  RETURN 0
.................... }                      
....................  
.................... #include "DS1307.h"   
.................... #ifndef DS1307_H      
.................... #define DS1307_H    
....................  
.................... //DS1307 TIME-DATE INFO VARIABLES   
.................... extern uchar_t sec, min, hrs; 
.................... extern uchar_t day, month, yr, dow;       
.................... extern uchar_t dayText[4];  
.................... //READ WRITE SET QUEUE 
.................... extern uchar_t timeSwitchPosition; 
.................... //LCD BUFFER 
.................... extern uchar_t DATE_TIME[32]; 
....................             
....................  
.................... void DS1307_Init();     
.................... void ds1307_run(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t);   
.................... void ds1307_set_date_time(uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t, uchar_t);   
.................... void ds1307_get_date(); 
.................... void ds1307_get_time();     
.................... void ds1307_write_date(); 
.................... void getDayText();                     
....................                
.................... uchar_t getSec(); 
.................... uchar_t getMin();                     
.................... uchar_t getHour(); 
....................                            
.................... uchar_t getDay();  
.................... uchar_t getMonth();  
.................... uchar_t getYear(); 
.................... uchar_t getDow();                                                                  
....................                 
.................... uint16_t day_of_the_week(uint16_t, uint16_t, uint16_t );                   
....................                     
.................... #endif //DS1307_H                      
....................                                        
....................  
.................... #include "i2c.h"  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef I2C_H 
.................... #define I2C_H      
....................  
.................... void I2C_Init();            
.................... void _I2C_Start(void);        
.................... void _I2C_ReStart(void);     
.................... void _I2C_Stop(void);               
.................... void _I2CACK(void);   
.................... void _I2CNACK(void); 
.................... void _I2C_WAIT(void); 
.................... uchar_t _I2C_Write_Byte(uchar_t);   
.................... uchar_t _I2C_Read_Byte(uchar_t);            
....................                
.................... #endif //I2C_H      
....................  
.................... #include "i2c.c"   
.................... #include "i2c.h"                                                                                         
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef I2C_H 
.................... #define I2C_H      
....................  
.................... void I2C_Init();            
.................... void _I2C_Start(void);        
.................... void _I2C_ReStart(void);     
.................... void _I2C_Stop(void);               
.................... void _I2CACK(void);   
.................... void _I2CNACK(void); 
.................... void _I2C_WAIT(void); 
.................... uchar_t _I2C_Write_Byte(uchar_t);   
.................... uchar_t _I2C_Read_Byte(uchar_t);            
....................                
.................... #endif //I2C_H      
....................  
.................... #include "definitions.h"     
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "ucregisters.h"         
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                  
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
.................... #byte ADCON1 = 0x0FC1     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit     
....................  
....................   
....................   
.................... //   #############WATCHDOG#######   
.................... #byte WDTCON   = 0x0FD1  
.................... #bit WDTCON_SWDTEN =WDTCON.0    
....................                         
....................                                                                 
....................                                                                 
.................... //   ################   RS232/EUSART   #################  // 
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit       
....................                     
....................                     
....................                     
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................                   
....................                            
.................... #endif UCREGISTER_H                                                                          
....................  
....................  
.................... void I2C_Init(){     
....................    SCL_DIR = 1;     //Set as a digital input 
*
0836:  BSF    F94.3
....................    SDA_DIR = 1;     //Set as a digital input 
0838:  BSF    F94.4
....................    SSPADD  = 19;  
083A:  MOVLW  13
083C:  MOVWF  FC8
....................    SSPCON1 = 0x28;  // enable I2C pins SCL and SDA for serial communication 
083E:  MOVLW  28
0840:  MOVWF  FC6
....................    //SSPCON2 = 0x00;   
....................    SSPSTAT = 0x80;  //slew rate disabled for high speed control       
0842:  MOVLW  80
0844:  MOVWF  FC7
0846:  GOTO   0142 (RETURN)
.................... }            
....................            
.................... void _I2C_WAIT(){ 
....................    while ( ( SSPCON2 & 0x1F ) || ( SSPSTAT & 0x04 ) ); 
*
0852:  MOVF   FC5,W
0854:  ANDLW  1F
0856:  BNZ   0852
0858:  BTFSC  FC7.2
085A:  BRA    0852
085C:  RETURN 0
....................    // wait for any pending transfer  
.................... }                                     
.................... // Function Purpose: I2C_Write_Byte transfers one byte  
.................... uchar_t _I2C_Write_Byte(uchar_t data){               
....................    SSPBUF = data;      // Send Byte value 
085E:  MOVFF  187,FC9
....................    while(BF);      // Wait for it to complete  
0862:  BTFSC  FC7.0
0864:  BRA    0862
....................    _I2C_WAIT(); 
0866:  RCALL  0852
....................    return ACKSTAT;     // Return ACK/NACK from slave 
0868:  MOVLW  00
086A:  BTFSC  FC5.6
086C:  MOVLW  01
086E:  MOVWF  01
0870:  RETURN 0
.................... }                            
....................                                          
.................... // Function Purpose: I2C_Read_Byte reads one byte 
.................... uchar_t _I2C_Read_Byte(uchar_t flag){     
*
1082:  MOVLB  1
1084:  CLRF   x80
....................    uchar_t receive = 0; 
....................    RCEN = 1;                     
1086:  BSF    FC5.3
....................    while(!BF);      // Wait for it to complete          
1088:  BTFSS  FC7.0
108A:  BRA    1088
....................    receive = SSPBUF;     
108C:  MOVFF  FC9,180
....................    if(flag==0)  
1090:  MOVF   x7F,F
1092:  BNZ   109E
....................       _I2CACK();                                      
1094:  MOVLB  0
1096:  BRA    106A
1098:  MOVLB  0
109A:  BRA    10A2
109C:  MOVLB  1
....................    else 
....................       _I2CNACK();  
109E:  MOVLB  0
10A0:  BRA    1076
....................    _I2C_WAIT();  
10A2:  CALL   0852
....................    return receive; // Return The Received Byte   
10A6:  MOVLB  1
10A8:  MOVFF  180,01
10AC:  MOVLB  0
10AE:  RETURN 0
.................... }     
....................    
.................... void _I2C_Start(void){  
....................    SEN = 1;         // Start condition enabled  
*
084A:  BSF    FC5.0
....................    while(SEN);      // automatically cleared by hardware  
084C:  BTFSC  FC5.0
084E:  BRA    084C
0850:  RETURN 0
....................                     // wait for start condition to finish   
.................... }   
....................  
.................... void _I2C_ReStart(void){ 
....................    RSEN = 1;         // Send Restart bit 
*
0872:  BSF    FC5.1
....................    while(RSEN);      // Wait for it to complete 
0874:  BTFSC  FC5.1
0876:  BRA    0874
0878:  RETURN 0
.................... }                     
....................                                             
.................... //Function : I2C_Stop sends stop bit sequence  
.................... void _I2C_Stop(void){      
....................    PEN = 1;      // Initiate Stop condition on SDA and SCL pins  
087A:  BSF    FC5.2
....................    while(PEN);   // Wait for stop condition to finish  
087C:  BTFSC  FC5.2
087E:  BRA    087C
0880:  RETURN 0
....................                      // PEN automatically cleared by hardware  
.................... }     
....................  
.................... void _I2CACK(void){ 
....................    ACKDT = 0; //Acknowledge Data bit   
*
106A:  BCF    FC5.5
....................    ACKEN = 1;  // Acknowledge Sequence Enable bit    
106C:  BSF    FC5.4
....................    while(ACKEN);      // Wait for it to complete 
106E:  BTFSC  FC5.4
1070:  BRA    106E
1072:  GOTO   10A2 (RETURN)
.................... }        
....................  
.................... void _I2CNACK(void){ 
....................    ACKDT = 1;    
1076:  BSF    FC5.5
....................    ACKEN = 1;  
1078:  BSF    FC5.4
....................    while(ACKEN);      // Wait for it to complete     
107A:  BTFSC  FC5.4
107C:  BRA    107A
107E:  GOTO   10A2 (RETURN)
.................... }       
....................  
.................... #include "DATA.h"   
.................... #include "definitions.h"                                                          
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef DATA_H 
.................... #define DATA_H     
.................... // Second    [0]   
.................... // Minute    [1] 
.................... // Hour      [2] 
.................... // WeekOfDay [3] 
.................... // Day       [4] 
.................... // Month     [5] 
.................... // Year      [6] 
.................... uchar_t timeDateReadData[7]={0,0,0,0,0,0,0};   
.................... uchar_t timeDateWriteData[7]={0,0,0,0,0,0,0};  
....................  
.................... #endif  //DATA_H   
....................  
....................                                         
.................... // START(0) <--------------0xD - 13 is adres of DS1307----------------->  <-R/W->                  <-DATA->    ACK    STOP(1)  
.................... //|------| |------| |------| |------| |------| |------| |------| |------| |------|       |------|  |------| |------| |------|   
.................... //|  S   | |   1  |-|   1  |-|   0  |-|   1  |-|   0  |-|   0  |-|   0  |-|   0  |       |   0  |  |nx8BIT| |   0  | |  P   |    
.................... //|------| |------| |------| |------| |------| |------| |------| |------| |------|       |------|  |------| |------| |------|    
.................... //          7.Bit    6.Bit    5.Bit    4.Bit    3.Bit    2.Bit    1.Bit    0.Bit           ACK                       
....................                          
.................... uchar_t sec, min, hrs;                 
.................... uchar_t day, month, yr, dow;          
.................... uchar_t dayText[4];  
.................... uchar_t timeSwitchPosition; 
.................... uchar_t DATE_TIME[32]; 
....................    
.................... void DS1307_Init(){   
....................     _I2C_Start();          
*
0882:  RCALL  084A
....................     while(_I2C_Write_Byte(0xD0 + 0) == 1)// Wait until device is free 
0884:  MOVLW  D0
0886:  MOVLB  1
0888:  MOVWF  x87
088A:  MOVLB  0
088C:  RCALL  085E
088E:  DECFSZ 01,W
0890:  BRA    0896
....................     {   _I2C_ReStart();   }  
0892:  RCALL  0872
0894:  BRA    0884
....................     _I2C_Write_Byte(0x07);          // Select the Ds1307 ControlRegister to configure Ds1307 
0896:  MOVLW  07
0898:  MOVLB  1
089A:  MOVWF  x87
089C:  MOVLB  0
089E:  RCALL  085E
....................     _I2C_Write_Byte(0x00);          // Write 0x00 to Control register to disable SQW-Out       
08A0:  MOVLB  1
08A2:  CLRF   x87
08A4:  MOVLB  0
08A6:  RCALL  085E
....................     _I2C_Stop();                // Stop I2C communication after initilizing DS1307 
08A8:  RCALL  087A
....................     timeSwitchPosition=11; 
08AA:  MOVLW  0B
08AC:  MOVWF  28
08AE:  GOTO   0144 (RETURN)
....................  }                                                               
....................         
.................... void ds1307_run(uchar_t day_t, uchar_t mth_t, uchar_t year_t, uchar_t dow_t, uchar_t hr_t, uchar_t min_t, uchar_t sec_t){                                                                                             
....................    if(timeSwitchPosition>=0 && timeSwitchPosition<=10){  
*
177C:  MOVF   28,W
177E:  SUBLW  0A
1780:  BNC   17A4
....................       ds1307_set_date_time(day_t, mth_t, year_t, dow_t, hr_t, min_t, sec_t); 
1782:  MOVFF  178,17F
1786:  MOVFF  179,180
178A:  MOVFF  17A,181
178E:  MOVFF  17B,182
1792:  MOVFF  17C,183
1796:  MOVFF  17D,184
179A:  MOVFF  17E,185
179E:  GOTO   0F54
....................    }  
17A2:  BRA    17C2
....................    else if(timeSwitchPosition>=11 && timeSwitchPosition<=19){  
17A4:  MOVF   28,W
17A6:  SUBLW  0A
17A8:  BC    17B4
17AA:  MOVF   28,W
17AC:  SUBLW  13
17AE:  BNC   17B4
....................       ds1307_get_time();     
17B0:  BRA    10CE
....................    } 
17B2:  BRA    17C2
....................    else if(timeSwitchPosition>=20 && timeSwitchPosition<=29){ 
17B4:  MOVF   28,W
17B6:  SUBLW  13
17B8:  BC    17C2
17BA:  MOVF   28,W
17BC:  SUBLW  1D
17BE:  BNC   17C2
....................       ds1307_get_date();         
17C0:  BRA    1542
....................    } 
17C2:  GOTO   018E (RETURN)
.................... }                                                                                                                          
....................  
.................... void ds1307_set_date_time(uchar_t day_t, uchar_t mth_t, uchar_t year_t, uchar_t dow_t, uchar_t hr_t, uchar_t min_t, uchar_t sec_t){      
....................    switch(timeSwitchPosition){ 
*
0F54:  MOVF   28,W
0F56:  ADDLW  F5
0F58:  BTFSC  FD8.0
0F5A:  BRA    102C
0F5C:  ADDLW  0B
0F5E:  GOTO   1030
....................    case 0: 
....................         _I2C_Start();                         // I2C write address  
0F62:  RCALL  084A
....................         timeSwitchPosition++;  
0F64:  INCF   28,F
....................    break;  
0F66:  BRA    102C
....................       
....................    case 1:  
....................         while(_I2C_Write_Byte(0xD0 + 0) == 1) // Wait until device is free  
0F68:  MOVLW  D0
0F6A:  MOVLB  1
0F6C:  MOVWF  x87
0F6E:  MOVLB  0
0F70:  RCALL  085E
0F72:  DECFSZ 01,W
0F74:  BRA    0F7A
....................         {   _I2C_ReStart();   }    
0F76:  RCALL  0872
0F78:  BRA    0F68
....................         timeSwitchPosition++;  
0F7A:  INCF   28,F
....................    break;    
0F7C:  BRA    102C
....................     
....................    case 2:  
....................         _I2C_Write_Byte(0x00);                // Start at REG 0 - Seconds   
0F7E:  MOVLB  1
0F80:  CLRF   x87
0F82:  MOVLB  0
0F84:  RCALL  085E
....................         timeSwitchPosition++;  
0F86:  INCF   28,F
....................    break;  
0F88:  BRA    102C
....................     
....................    case 3:   
....................         sec_t &= 0x7F; 
0F8A:  MOVLB  1
0F8C:  BCF    x85.7
....................         _I2C_Write_Byte(bin2bcd(sec_t));      // REG 0   
0F8E:  MOVFF  185,186
0F92:  MOVLB  0
0F94:  RCALL  0BB4
0F96:  MOVFF  01,186
0F9A:  MOVFF  01,187
0F9E:  RCALL  085E
....................         timeSwitchPosition++;  
0FA0:  INCF   28,F
....................    break;    
0FA2:  BRA    102C
....................     
....................    case 4:  
....................         min_t &= 0x7F; 
0FA4:  MOVLB  1
0FA6:  BCF    x84.7
....................         _I2C_Write_Byte(bin2bcd(min_t));      // REG 1   
0FA8:  MOVFF  184,186
0FAC:  MOVLB  0
0FAE:  RCALL  0BB4
0FB0:  MOVFF  01,186
0FB4:  MOVFF  01,187
0FB8:  RCALL  085E
....................         timeSwitchPosition++;  
0FBA:  INCF   28,F
....................    break;     
0FBC:  BRA    102C
....................     
....................    case 5:  
....................         hr_t &= (0x7F|0x40);  //format 24H  
0FBE:  MOVLB  1
0FC0:  BCF    x83.7
....................         _I2C_Write_Byte(bin2bcd(hr_t));       // REG 2  
0FC2:  MOVFF  183,186
0FC6:  MOVLB  0
0FC8:  RCALL  0BB4
0FCA:  MOVFF  01,186
0FCE:  MOVFF  01,187
0FD2:  RCALL  085E
....................         timeSwitchPosition++;  
0FD4:  INCF   28,F
....................    break;  
0FD6:  BRA    102C
....................     
....................    case 6: 
....................         _I2C_Write_Byte(bin2bcd(dow_t));      // REG 3  
0FD8:  MOVFF  182,186
0FDC:  RCALL  0BB4
0FDE:  MOVFF  01,186
0FE2:  MOVFF  01,187
0FE6:  RCALL  085E
....................         timeSwitchPosition++;  
0FE8:  INCF   28,F
....................    break;    
0FEA:  BRA    102C
....................     
....................    case 7:  
....................        _I2C_Write_Byte(bin2bcd(day_t));      // REG 4   
0FEC:  MOVFF  17F,186
0FF0:  RCALL  0BB4
0FF2:  MOVFF  01,186
0FF6:  MOVFF  01,187
0FFA:  RCALL  085E
....................        timeSwitchPosition++;  
0FFC:  INCF   28,F
....................    break;   
0FFE:  BRA    102C
....................     
....................    case 8:  
....................        _I2C_Write_Byte(bin2bcd(mth_t));      // REG 5   
1000:  MOVFF  180,186
1004:  RCALL  0BB4
1006:  MOVFF  01,186
100A:  MOVFF  01,187
100E:  RCALL  085E
....................        timeSwitchPosition++;  
1010:  INCF   28,F
....................    break;    
1012:  BRA    102C
....................     
....................    case 9: 
....................        _I2C_Write_Byte(bin2bcd(year_t));     // REG 6  
1014:  MOVFF  181,186
1018:  RCALL  0BB4
101A:  MOVFF  01,186
101E:  MOVFF  01,187
1022:  RCALL  085E
....................        timeSwitchPosition++;                      
1024:  INCF   28,F
....................    break; 
1026:  BRA    102C
....................     
....................    case 10: 
....................        _I2C_Stop();         
1028:  RCALL  087A
....................        timeSwitchPosition++;  
102A:  INCF   28,F
....................    break;            
....................   }            
102C:  GOTO   17A2 (RETURN)
.................... }                              
....................  
....................                  
.................... void ds1307_get_time(){  
....................  switch(timeSwitchPosition){ 
*
10CE:  MOVLW  0B
10D0:  SUBWF  28,W
10D2:  ADDLW  F7
10D4:  BC    1192
10D6:  ADDLW  09
10D8:  GOTO   1196
....................    case 11: 
....................         _I2C_Start();                         // I2C write address  
10DC:  CALL   084A
....................         timeSwitchPosition++;  
10E0:  INCF   28,F
....................    break;  
10E2:  BRA    1192
....................       
....................    case 12:  
....................         while(_I2C_Write_Byte(0xD0 + 0) == 1)   // Wait until device is free 
10E4:  MOVLW  D0
10E6:  MOVLB  1
10E8:  MOVWF  x87
10EA:  MOVLB  0
10EC:  CALL   085E
10F0:  DECFSZ 01,W
10F2:  BRA    10FA
....................         {   _I2C_ReStart();   }     
10F4:  CALL   0872
10F8:  BRA    10E4
....................         timeSwitchPosition++;  
10FA:  INCF   28,F
....................    break;    
10FC:  BRA    1192
....................     
....................    case 13:  
....................         _I2C_Write_Byte(0x00);                  // Start at REG 3 - Day of week   
10FE:  MOVLB  1
1100:  CLRF   x87
1102:  MOVLB  0
1104:  CALL   085E
....................         timeSwitchPosition++;  
1108:  INCF   28,F
....................    break;  
110A:  BRA    1192
....................     
....................    case 14:   
....................         _I2C_ReStart();  
110C:  CALL   0872
....................         timeSwitchPosition++;  
1110:  INCF   28,F
....................    break;    
1112:  BRA    1192
....................     
....................    case 15:  
....................         _I2C_Write_Byte(0xD0 + 1);   
1114:  MOVLW  D1
1116:  MOVLB  1
1118:  MOVWF  x87
111A:  MOVLB  0
111C:  CALL   085E
....................         timeSwitchPosition++;  
1120:  INCF   28,F
....................    break;     
1122:  BRA    1192
....................     
....................    case 16:                 
....................         sec = bcd2bin(_I2C_Read_Byte(0) & 0x7F);  
1124:  MOVLB  1
1126:  CLRF   x7F
1128:  MOVLB  0
112A:  RCALL  1082
112C:  MOVF   01,W
112E:  ANDLW  7F
1130:  MOVLB  1
1132:  MOVWF  x7F
1134:  MOVWF  x80
1136:  MOVLB  0
1138:  RCALL  10B0
113A:  MOVFF  01,1D
....................         timeDateReadData[0] = sec;  
113E:  MOVFF  1D,6B
....................         timeSwitchPosition++;     
1142:  INCF   28,F
....................    break;  
1144:  BRA    1192
....................     
....................    case 17: 
....................         min = bcd2bin(_I2C_Read_Byte(0) & 0x7F);  
1146:  MOVLB  1
1148:  CLRF   x7F
114A:  MOVLB  0
114C:  RCALL  1082
114E:  MOVF   01,W
1150:  ANDLW  7F
1152:  MOVLB  1
1154:  MOVWF  x7F
1156:  MOVWF  x80
1158:  MOVLB  0
115A:  RCALL  10B0
115C:  MOVFF  01,1E
....................         timeDateReadData[1] = min; 
1160:  MOVFF  1E,6C
....................         timeSwitchPosition++;  
1164:  INCF   28,F
....................    break;                  
1166:  BRA    1192
....................                                 
....................    case 18:    
....................         hrs = bcd2bin(_I2C_Read_Byte(1) & 0x7F);  
1168:  MOVLW  01
116A:  MOVLB  1
116C:  MOVWF  x7F
116E:  MOVLB  0
1170:  RCALL  1082
1172:  MOVF   01,W
1174:  ANDLW  7F
1176:  MOVLB  1
1178:  MOVWF  x7F
117A:  MOVWF  x80
117C:  MOVLB  0
117E:  RCALL  10B0
1180:  MOVFF  01,1F
....................          timeDateReadData[2] = hrs; 
1184:  MOVFF  1F,6D
....................         timeSwitchPosition++;  
1188:  INCF   28,F
....................    break;   
118A:  BRA    1192
....................     
....................    case 19:  
....................         _I2C_Stop();    
118C:  CALL   087A
....................         timeSwitchPosition++;  
1190:  INCF   28,F
....................    break;   
....................  
....................   }                    
1192:  GOTO   17B2 (RETURN)
.................... }                                                     
....................  
.................... void ds1307_get_date(){ 
....................    switch(timeSwitchPosition){ 
*
1542:  MOVLW  14
1544:  SUBWF  28,W
1546:  ADDLW  F6
1548:  BTFSC  FD8.0
154A:  BRA    1740
154C:  ADDLW  0A
154E:  GOTO   1744
....................    case 20: 
....................         _I2C_Start();                         // I2C write address  
1552:  CALL   084A
....................         timeSwitchPosition++;  
1556:  INCF   28,F
....................    break;      
1558:  BRA    1740
....................       
....................    case 21:  
....................         while(_I2C_Write_Byte(0xD0 + 0) == 1)   // Wait until device is free 
155A:  MOVLW  D0
155C:  MOVLB  1
155E:  MOVWF  x87
1560:  MOVLB  0
1562:  CALL   085E
1566:  DECFSZ 01,W
1568:  BRA    1570
....................         {   _I2C_ReStart();   }  
156A:  CALL   0872
156E:  BRA    155A
....................         timeSwitchPosition++;  
1570:  INCF   28,F
....................    break;    
1572:  BRA    1740
....................                 
....................    case 22:  
....................         _I2C_Write_Byte(0x03);                  // Start at REG 3 - Day of week   
1574:  MOVLW  03
1576:  MOVLB  1
1578:  MOVWF  x87
157A:  MOVLB  0
157C:  CALL   085E
....................         timeSwitchPosition++;  
1580:  INCF   28,F
....................    break;  
1582:  BRA    1740
....................     
....................    case 23:   
....................         _I2C_ReStart();  
1584:  CALL   0872
....................         timeSwitchPosition++;  
1588:  INCF   28,F
....................    break;    
158A:  BRA    1740
....................     
....................    case 24:  
....................         _I2C_Write_Byte(0xD0 + 1);   
158C:  MOVLW  D1
158E:  MOVLB  1
1590:  MOVWF  x87
1592:  MOVLB  0
1594:  CALL   085E
....................         timeSwitchPosition++;  
1598:  INCF   28,F
....................    break;     
159A:  BRA    1740
....................     
....................    case 25:  
....................         // lecture DS1307 retourne (une valeur binaire codee BCD 
....................          // ex retourne 19 ou 0x13   l'an 13                  
....................         dow    = bcd2bin(_I2C_Read_Byte(0) & 0x07);   // REG 3  
159C:  MOVLB  1
159E:  CLRF   x7F
15A0:  MOVLB  0
15A2:  RCALL  1082
15A4:  MOVF   01,W
15A6:  ANDLW  07
15A8:  MOVLB  1
15AA:  MOVWF  x7F
15AC:  MOVWF  x80
15AE:  MOVLB  0
15B0:  RCALL  10B0
15B2:  MOVFF  01,23
....................         timeSwitchPosition++;  
15B6:  INCF   28,F
....................    break;  
15B8:  BRA    1740
....................     
....................    case 26: 
....................         day    = bcd2bin(_I2C_Read_Byte(0) & 0x3F);   // REG 4  
15BA:  MOVLB  1
15BC:  CLRF   x7F
15BE:  MOVLB  0
15C0:  RCALL  1082
15C2:  MOVF   01,W
15C4:  ANDLW  3F
15C6:  MOVLB  1
15C8:  MOVWF  x7F
15CA:  MOVWF  x80
15CC:  MOVLB  0
15CE:  RCALL  10B0
15D0:  MOVFF  01,20
....................          timeDateReadData[4] = day;  
15D4:  MOVFF  20,6F
....................         timeSwitchPosition++;  
15D8:  INCF   28,F
....................    break;    
15DA:  BRA    1740
....................     
....................    case 27: 
....................         month  = bcd2bin(_I2C_Read_Byte(0) & 0x1F);   // REG 5  
15DC:  MOVLB  1
15DE:  CLRF   x7F
15E0:  MOVLB  0
15E2:  RCALL  1082
15E4:  MOVF   01,W
15E6:  ANDLW  1F
15E8:  MOVLB  1
15EA:  MOVWF  x7F
15EC:  MOVWF  x80
15EE:  MOVLB  0
15F0:  RCALL  10B0
15F2:  MOVFF  01,21
....................         timeDateReadData[5] = month;  
15F6:  MOVFF  21,70
....................     
....................         timeSwitchPosition++;    
15FA:  INCF   28,F
....................    break;   
15FC:  BRA    1740
....................     
....................    case 28:  
....................         yr     = bcd2bin(_I2C_Read_Byte(1));    // REG 6 
15FE:  MOVLW  01
1600:  MOVLB  1
1602:  MOVWF  x7F
1604:  MOVLB  0
1606:  RCALL  1082
1608:  MOVFF  01,17F
160C:  MOVFF  01,180
1610:  RCALL  10B0
1612:  MOVFF  01,22
....................         timeDateReadData[6] = yr;  
1616:  MOVFF  22,71
....................         timeSwitchPosition++;  
161A:  INCF   28,F
....................    break;   
161C:  BRA    1740
....................     
....................    case 29:  
....................        _I2C_Stop();  
161E:  CALL   087A
....................        getDayText();  
1622:  BRA    1312
....................        timeDateReadData[3] = day_of_the_week(getYear(),getMonth(),getDay());   
1624:  RCALL  11CC
1626:  MOVFF  01,17F
162A:  RCALL  11D2
162C:  MOVFF  01,180
1630:  RCALL  11D8
1632:  MOVFF  01,181
1636:  MOVLB  1
1638:  CLRF   x83
163A:  MOVFF  17F,182
163E:  CLRF   x85
1640:  MOVFF  180,184
1644:  CLRF   x87
1646:  MOVFF  01,186
164A:  MOVLB  0
164C:  RCALL  11DE
164E:  MOVFF  01,6E
....................        sprintf(DATE_TIME,"  \%02d : \%02d : \%02d   %s - \%02d/\%02d/\%02d",hrs,min,sec,dayText,day,month,yr);        
1652:  CLRF   7A
1654:  MOVLW  29
1656:  MOVWF  79
1658:  MOVLW  20
165A:  MOVLB  1
165C:  MOVWF  x85
165E:  MOVLB  0
1660:  RCALL  13EC
1662:  MOVLW  20
1664:  MOVLB  1
1666:  MOVWF  x85
1668:  MOVLB  0
166A:  RCALL  13EC
166C:  MOVFF  1F,17F
1670:  MOVLW  01
1672:  MOVLB  1
1674:  MOVWF  x80
1676:  MOVLB  0
1678:  RCALL  1438
167A:  MOVLW  78
167C:  MOVWF  FF6
167E:  MOVLW  06
1680:  MOVWF  FF7
1682:  MOVLW  03
1684:  MOVLB  1
1686:  MOVWF  x7F
1688:  MOVLB  0
168A:  RCALL  14F4
168C:  MOVFF  1E,17F
1690:  MOVLW  01
1692:  MOVLB  1
1694:  MOVWF  x80
1696:  MOVLB  0
1698:  RCALL  1438
169A:  MOVLW  7F
169C:  MOVWF  FF6
169E:  MOVLW  06
16A0:  MOVWF  FF7
16A2:  MOVLW  03
16A4:  MOVLB  1
16A6:  MOVWF  x7F
16A8:  MOVLB  0
16AA:  RCALL  14F4
16AC:  MOVFF  1D,17F
16B0:  MOVLW  01
16B2:  MOVLB  1
16B4:  MOVWF  x80
16B6:  MOVLB  0
16B8:  RCALL  1438
16BA:  MOVLW  86
16BC:  MOVWF  FF6
16BE:  MOVLW  06
16C0:  MOVWF  FF7
16C2:  MOVLW  03
16C4:  MOVLB  1
16C6:  MOVWF  x7F
16C8:  MOVLB  0
16CA:  RCALL  14F4
16CC:  CLRF   FEA
16CE:  MOVLW  24
16D0:  MOVWF  FE9
16D2:  BRA    151C
16D4:  MOVLW  8B
16D6:  MOVWF  FF6
16D8:  MOVLW  06
16DA:  MOVWF  FF7
16DC:  MOVLW  03
16DE:  MOVLB  1
16E0:  MOVWF  x7F
16E2:  MOVLB  0
16E4:  RCALL  14F4
16E6:  MOVFF  20,17F
16EA:  MOVLW  01
16EC:  MOVLB  1
16EE:  MOVWF  x80
16F0:  MOVLB  0
16F2:  RCALL  1438
16F4:  MOVLW  2F
16F6:  MOVLB  1
16F8:  MOVWF  x85
16FA:  MOVLB  0
16FC:  RCALL  13EC
16FE:  MOVFF  21,17F
1702:  MOVLW  01
1704:  MOVLB  1
1706:  MOVWF  x80
1708:  MOVLB  0
170A:  RCALL  1438
170C:  MOVLW  2F
170E:  MOVLB  1
1710:  MOVWF  x85
1712:  MOVLB  0
1714:  RCALL  13EC
1716:  MOVFF  22,17F
171A:  MOVLW  01
171C:  MOVLB  1
171E:  MOVWF  x80
1720:  MOVLB  0
1722:  RCALL  1438
....................        memcpy(strLCD,DATE_TIME,32); 
1724:  CLRF   FEA
1726:  MOVLW  49
1728:  MOVWF  FE9
172A:  CLRF   FE2
172C:  MOVLW  29
172E:  MOVWF  FE1
1730:  MOVLW  20
1732:  MOVWF  01
1734:  MOVFF  FE6,FEE
1738:  DECFSZ 01,F
173A:  BRA    1734
....................        timeSwitchPosition=11;  
173C:  MOVLW  0B
173E:  MOVWF  28
....................    break;    
....................   }            
1740:  GOTO   17C2 (RETURN)
.................... }              
....................  
.................... // ########################### MODBUS - RTU 0x18 Multiple Write ############ 
.................... void ds1307_write_date(uchar_t startAddress, uchar_t length){ 
....................    uchar_t ii;     
....................    for(ii=0;ii<2;ii++) 
*
0BD8:  MOVLB  1
0BDA:  CLRF   x7F
0BDC:  MOVF   x7F,W
0BDE:  SUBLW  01
0BE0:  BNC   0BEC
....................       _I2C_Stop(); 
0BE2:  MOVLB  0
0BE4:  RCALL  087A
0BE6:  MOVLB  1
0BE8:  INCF   x7F,F
0BEA:  BRA    0BDC
....................        
....................    _I2C_Start();                         // I2C write address 
0BEC:  MOVLB  0
0BEE:  RCALL  084A
....................    while(_I2C_Write_Byte(0xD0 + 0) == 1){ // Wait until device is free  
0BF0:  MOVLW  D0
0BF2:  MOVLB  1
0BF4:  MOVWF  x87
0BF6:  MOVLB  0
0BF8:  RCALL  085E
0BFA:  DECFSZ 01,W
0BFC:  BRA    0C02
....................       _I2C_ReStart();               
0BFE:  RCALL  0872
0C00:  BRA    0BF0
....................    }        
....................    _I2C_Write_Byte(startAddress);                 
0C02:  MOVFF  17D,187
0C06:  RCALL  085E
....................    timeDateWriteData[0] &= 0x7F;         // Second    
0C08:  BCF    72.7
....................    timeDateWriteData[1] &= (0x7F|0x40);  // Minute                                    
0C0A:  BCF    73.7
....................    timeDateWriteData[2] &= 0x7F;         // Hour     
0C0C:  BCF    74.7
....................     
....................    for(ii=0;ii<length;ii++)                                 
0C0E:  MOVLB  1
0C10:  CLRF   x7F
0C12:  MOVF   x7E,W
0C14:  SUBWF  x7F,W
0C16:  BC    0C44
....................       _I2C_Write_Byte(bin2bcd(timeDateWriteData[ii+startAddress])); 
0C18:  MOVF   x7D,W
0C1A:  ADDWF  x7F,W
0C1C:  CLRF   03
0C1E:  ADDLW  72
0C20:  MOVWF  FE9
0C22:  MOVLW  00
0C24:  ADDWFC 03,W
0C26:  MOVWF  FEA
0C28:  MOVFF  FEF,180
0C2C:  MOVFF  180,186
0C30:  MOVLB  0
0C32:  RCALL  0BB4
0C34:  MOVFF  01,180
0C38:  MOVFF  01,187
0C3C:  RCALL  085E
0C3E:  MOVLB  1
0C40:  INCF   x7F,F
0C42:  BRA    0C12
....................                                        
....................    _I2C_Stop();                                  
0C44:  MOVLB  0
0C46:  RCALL  087A
0C48:  RETURN 0
.................... }   
....................  
.................... void getDayText(){                           
....................    switch(day_of_the_week(getYear(),getMonth(),getDay())){ 
*
1312:  RCALL  11CC
1314:  MOVFF  01,17F
1318:  RCALL  11D2
131A:  MOVFF  01,180
131E:  RCALL  11D8
1320:  MOVFF  01,181
1324:  MOVLB  1
1326:  CLRF   x83
1328:  MOVFF  17F,182
132C:  CLRF   x85
132E:  MOVFF  180,184
1332:  CLRF   x87
1334:  MOVFF  01,186
1338:  MOVLB  0
133A:  RCALL  11DE
133C:  MOVFF  01,00
1340:  MOVF   02,W
1342:  MOVWF  03
1344:  BNZ   134A
1346:  MOVF   00,F
1348:  BZ    1388
134A:  MOVF   03,W
134C:  BNZ   1354
134E:  MOVLW  01
1350:  SUBWF  00,W
1352:  BZ    1396
1354:  MOVF   03,W
1356:  BNZ   135E
1358:  MOVLW  02
135A:  SUBWF  00,W
135C:  BZ    13A4
135E:  MOVF   03,W
1360:  BNZ   1368
1362:  MOVLW  03
1364:  SUBWF  00,W
1366:  BZ    13B2
1368:  MOVF   03,W
136A:  BNZ   1372
136C:  MOVLW  04
136E:  SUBWF  00,W
1370:  BZ    13C0
1372:  MOVF   03,W
1374:  BNZ   137C
1376:  MOVLW  05
1378:  SUBWF  00,W
137A:  BZ    13CE
137C:  MOVF   03,W
137E:  BNZ   1386
1380:  MOVLW  06
1382:  SUBWF  00,W
1384:  BZ    13DC
1386:  BRA    13E8
....................      case 0: memcpy(dayText,"Sun",3); break; 
1388:  MOVLW  53
138A:  MOVWF  24
138C:  MOVLW  75
138E:  MOVWF  25
1390:  MOVLW  6E
1392:  MOVWF  26
1394:  BRA    13E8
....................      case 1: memcpy(dayText,"Mon",3); break; 
1396:  MOVLW  4D
1398:  MOVWF  24
139A:  MOVLW  6F
139C:  MOVWF  25
139E:  MOVLW  6E
13A0:  MOVWF  26
13A2:  BRA    13E8
....................      case 2: memcpy(dayText,"Tue",3); break; 
13A4:  MOVLW  54
13A6:  MOVWF  24
13A8:  MOVLW  75
13AA:  MOVWF  25
13AC:  MOVLW  65
13AE:  MOVWF  26
13B0:  BRA    13E8
....................      case 3: memcpy(dayText,"Wed",3); break; 
13B2:  MOVLW  57
13B4:  MOVWF  24
13B6:  MOVLW  65
13B8:  MOVWF  25
13BA:  MOVLW  64
13BC:  MOVWF  26
13BE:  BRA    13E8
....................      case 4: memcpy(dayText,"Thu",3); break; 
13C0:  MOVLW  54
13C2:  MOVWF  24
13C4:  MOVLW  68
13C6:  MOVWF  25
13C8:  MOVLW  75
13CA:  MOVWF  26
13CC:  BRA    13E8
....................      case 5: memcpy(dayText,"Fri",3); break; 
13CE:  MOVLW  46
13D0:  MOVWF  24
13D2:  MOVLW  72
13D4:  MOVWF  25
13D6:  MOVLW  69
13D8:  MOVWF  26
13DA:  BRA    13E8
....................      case 6: memcpy(dayText,"Sat",3); break; 
13DC:  MOVLW  53
13DE:  MOVWF  24
13E0:  MOVLW  61
13E2:  MOVWF  25
13E4:  MOVLW  74
13E6:  MOVWF  26
....................    }  
13E8:  GOTO   1624 (RETURN)
.................... }    
....................    
.................... uchar_t getSec(){ 
....................    return sec;   
.................... }  
.................... uchar_t getMin(){ 
....................    return min;   
.................... }   
.................... uchar_t getHour(){                     
....................    return hrs; 
.................... }   
.................... uchar_t getDow(){ 
....................    return dow;   
.................... }   
.................... uchar_t getDay(){ 
....................    return day;   
*
11D8:  MOVF   20,W
11DA:  MOVWF  01
11DC:  RETURN 0
.................... }  
.................... uchar_t getMonth(){ 
....................    return month;   
*
11D2:  MOVF   21,W
11D4:  MOVWF  01
11D6:  RETURN 0
.................... }   
.................... uchar_t getYear(){ 
....................    return yr;   
*
11CC:  MOVF   22,W
11CE:  MOVWF  01
11D0:  RETURN 0
.................... }                                            
.................... // <-------------      (0-7, Start Sunday)       ----------->  
.................... uint16_t day_of_the_week(uint16_t Y, uint16_t M, uint16_t D) {  
....................    uint16_t days[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };  
*
11DE:  MOVLB  1
11E0:  CLRF   x88
11E2:  CLRF   x89
11E4:  MOVLW  03
11E6:  MOVWF  x8A
11E8:  CLRF   x8B
11EA:  MOVLW  02
11EC:  MOVWF  x8C
11EE:  CLRF   x8D
11F0:  MOVLW  05
11F2:  MOVWF  x8E
11F4:  CLRF   x8F
11F6:  CLRF   x90
11F8:  CLRF   x91
11FA:  MOVLW  03
11FC:  MOVWF  x92
11FE:  CLRF   x93
1200:  MOVLW  05
1202:  MOVWF  x94
1204:  CLRF   x95
1206:  MOVLW  01
1208:  MOVWF  x96
120A:  CLRF   x97
120C:  MOVLW  04
120E:  MOVWF  x98
1210:  CLRF   x99
1212:  MOVLW  06
1214:  MOVWF  x9A
1216:  CLRF   x9B
1218:  MOVLW  02
121A:  MOVWF  x9C
121C:  CLRF   x9D
121E:  MOVLW  04
1220:  MOVWF  x9E
1222:  CLRF   x9F
....................    if (M < 3)  
1224:  MOVF   x85,F
1226:  BNZ   1236
1228:  MOVF   x84,W
122A:  SUBLW  02
122C:  BNC   1236
....................       Y--;         
122E:  MOVF   x82,W
1230:  BTFSC  FD8.2
1232:  DECF   x83,F
1234:  DECF   x82,F
....................    return (Y + Y / 4 - Y / 100 + Y / 400 + days[M - 1] + D) % 7;  
1236:  RRCF   x83,W
1238:  MOVWF  03
123A:  RRCF   x82,W
123C:  MOVWF  02
123E:  RRCF   03,F
1240:  RRCF   02,F
1242:  MOVLW  3F
1244:  ANDWF  03,F
1246:  MOVF   02,W
1248:  ADDWF  x82,W
124A:  MOVWF  xA0
124C:  MOVF   03,W
124E:  ADDWFC x83,W
1250:  MOVWF  xA1
1252:  CLRF   16
1254:  BTFSC  FF2.7
1256:  BSF    16.7
1258:  BCF    FF2.7
125A:  MOVFF  183,1A8
125E:  MOVFF  182,1A7
1262:  CLRF   xAA
1264:  MOVLW  64
1266:  MOVWF  xA9
1268:  MOVLB  0
126A:  CALL   0096
126E:  BTFSC  16.7
1270:  BSF    FF2.7
1272:  MOVFF  02,03
1276:  MOVF   01,W
1278:  MOVLB  1
127A:  SUBWF  xA0,F
127C:  MOVF   02,W
127E:  SUBWFB xA1,F
1280:  CLRF   16
1282:  BTFSC  FF2.7
1284:  BSF    16.7
1286:  BCF    FF2.7
1288:  MOVFF  183,1A8
128C:  MOVFF  182,1A7
1290:  MOVLW  01
1292:  MOVWF  xAA
1294:  MOVLW  90
1296:  MOVWF  xA9
1298:  MOVLB  0
129A:  CALL   0096
129E:  BTFSC  16.7
12A0:  BSF    FF2.7
12A2:  MOVFF  02,03
12A6:  MOVF   01,W
12A8:  MOVLB  1
12AA:  ADDWF  xA0,F
12AC:  MOVF   02,W
12AE:  ADDWFC xA1,F
12B0:  MOVLW  01
12B2:  SUBWF  x84,W
12B4:  MOVWF  xA2
12B6:  MOVLW  00
12B8:  SUBWFB x85,W
12BA:  MOVWF  xA3
12BC:  BCF    FD8.0
12BE:  RLCF   xA2,W
12C0:  MOVWF  02
12C2:  RLCF   xA3,W
12C4:  MOVWF  03
12C6:  MOVF   02,W
12C8:  ADDLW  88
12CA:  MOVWF  FE9
12CC:  MOVLW  01
12CE:  ADDWFC 03,W
12D0:  MOVWF  FEA
12D2:  MOVFF  FEC,03
12D6:  MOVF   FED,F
12D8:  MOVF   FEF,W
12DA:  ADDWF  xA0,F
12DC:  MOVF   03,W
12DE:  ADDWFC xA1,F
12E0:  MOVF   x86,W
12E2:  ADDWF  xA0,F
12E4:  MOVF   x87,W
12E6:  ADDWFC xA1,F
12E8:  CLRF   16
12EA:  BTFSC  FF2.7
12EC:  BSF    16.7
12EE:  BCF    FF2.7
12F0:  MOVFF  1A1,1A8
12F4:  MOVFF  1A0,1A7
12F8:  CLRF   xAA
12FA:  MOVLW  07
12FC:  MOVWF  xA9
12FE:  MOVLB  0
1300:  CALL   0096
1304:  BTFSC  16.7
1306:  BSF    FF2.7
1308:  MOVFF  00,01
130C:  MOVFF  03,02
1310:  RETURN 0
.................... }  
....................  
....................                                                                                                                 
....................  
.................... #include "usart_rs232.c"     
.................... #include "ucregisters.h"                                                                                              
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                  
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
.................... #byte ADCON1 = 0x0FC1     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit     
....................  
....................   
....................   
.................... //   #############WATCHDOG#######   
.................... #byte WDTCON   = 0x0FD1  
.................... #bit WDTCON_SWDTEN =WDTCON.0    
....................                         
....................                                                                 
....................                                                                 
.................... //   ################   RS232/EUSART   #################  // 
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit       
....................                     
....................                     
....................                     
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................                   
....................                            
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "usart_rs232.h" 
.................... #ifndef USART_RS232_H                                                                                                
.................... #define USART_RS232_H    
....................   
....................  
.................... uchar_t USART_RxCharBuffer(); 
.................... void USART_TxCharBuffer(uchar_t data); 
.................... void USART_Init();      
....................                                                    
.................... #endif  //USART_RS232_H 
....................                   
....................  
....................  
....................   
....................                
.................... void USART_Init(){                                                                   
....................    TRISC_6=0;        // Make Tx pin as output    
*
08B2:  BCF    F94.6
....................    TRISC_7=1;        // Make Rx pin as input                                                                   
08B4:  BSF    F94.7
....................    // Baud rate=9600, SPBRG = (F_CPU /(64*9600))-1         
....................    SPBRG = 0x0C;                       
08B6:  MOVLW  0C
08B8:  MOVWF  FAF
....................    TXSTA = 0x20;     // Enable Transmit(TX)  
08BA:  MOVLW  20
08BC:  MOVWF  FAC
....................    RCSTA = 0x90;     // Enable Recieve (RX) 
08BE:  MOVLW  90
08C0:  MOVWF  FAB
08C2:  GOTO   0146 (RETURN)
.................... }                                        
....................                              
....................                                  
.................... uchar_t USART_RxCharBuffer(){                
....................    if(RCIF_PIR1==1)                   
08C6:  BTFSS  F9E.5
08C8:  BRA    08CE
....................       return(RCREG);           //received in RCREG register and return to main program     
08CA:  MOVFF  FAE,01
08CE:  RETURN 0
.................... }                             
....................                                                
.................... void USART_TxCharBuffer(uchar_t data){        
....................     TXREG=data;                                     // Store data in Transmit register 
*
0996:  MOVFF  186,FAD
....................     while(TXIF_PIR1==0);                             // Wait until TXIF gets low 
099A:  BTFSS  F9E.4
099C:  BRA    099A
099E:  GOTO   09F4 (RETURN)
....................    /* if(OERR_RCSTA){               
....................       CREN_RCSTA = 0;                                        
....................       #ASM NOP #ENDASM      
....................       CREN_RCSTA=1; 
....................    }                                    
....................    TXREG = data;            //Write char data to transmit register 
....................    TXIF_PIR1=0;    */          
.................... }                    
....................                                                             
....................  
.................... #include "modbusrtu.c"      
.................... #include "modbusrtu.h"                                      
.................... #include "definitions.h"                                                          
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "ucregisters.h"    
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                  
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80 
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
.................... #byte ADCON1 = 0x0FC1     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit     
....................  
....................   
....................   
.................... //   #############WATCHDOG#######   
.................... #byte WDTCON   = 0x0FD1  
.................... #bit WDTCON_SWDTEN =WDTCON.0    
....................                         
....................                                                                 
....................                                                                 
.................... //   ################   RS232/EUSART   #################  // 
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit       
....................                     
....................                     
....................                     
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................                   
....................                            
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "DATA.h" 
.................... #include "definitions.h"                                                          
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef unsigned int8   uint8_t; 
.................... typedef unsigned char   uchar_t; 
....................                
.................... #endif //DEFINITIONS_H       
....................  
....................  
.................... #ifndef DATA_H 
.................... #define DATA_H     
.................... // Second    [0]   
.................... // Minute    [1] 
.................... // Hour      [2] 
.................... // WeekOfDay [3] 
.................... // Day       [4] 
.................... // Month     [5] 
.................... // Year      [6] 
.................... uchar_t timeDateReadData[7]={0,0,0,0,0,0,0};   
.................... uchar_t timeDateWriteData[7]={0,0,0,0,0,0,0};  
....................  
.................... #endif  //DATA_H   
....................  
....................                             
.................... #ifndef MODBUSRTU_H                                
.................... #define MODBUSRTU_H   
.................... #define SLAVEADDRESS 1                      
.................... extern uchar_t query[125], response[125]; 
.................... extern uint16_t crcCheckCode; 
....................                                                
.................... void modbusRTUrx();                              
.................... void modbusReadReg();           //0x03  //########## Function 03 (03hex) Read Holding Registers ######## 
.................... void modbusWriteSingleReg();    //0x06  //########## Function 06 (06hex) Write Single Register ########  
.................... void modbusWriteMultipleReg();  //0x10  //########## Function 16 (10hex) Write Multiple Registers ########  
.................... void modbusResponse(uchar_t);      
....................  
.................... void clearResponse(); 
.................... void clearQuery();  
....................  
.................... //uint16_t CRC16 (uchar_t, uint8_t);    
.................... uint16_t CRC16(uchar_t, uint8_t); 
....................  
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const char Table_CRC_Hi[256] = { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const char Table_CRC_Lo[256] = { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... }; 
....................  
....................  
.................... #endif  //MODBUSRTU_H 
....................  
....................  
.................... #ifndef MODBUSRTU_ 
.................... #define MODBUSRTU_C                                          
.................... uchar_t query[125], response[125]; 
.................... uint16_t crcCheckCode; 
.................... uchar_t comStat;                                   
....................                                                     
.................... void modbusRTUrx(){                    
....................    comStat=0;  
*
0F04:  MOVLB  1
0F06:  CLRF   x77
....................    uchar_t rxData = USART_RxCharBuffer();  
0F08:  MOVLB  0
0F0A:  RCALL  08C6
0F0C:  MOVFF  01,178
....................    if(SLAVEADDRESS==rxData){                         
0F10:  MOVLB  1
0F12:  DECFSZ x78,W
0F14:  BRA    0F48
....................       while(RCIF_PIR1==0); 
0F16:  BTFSS  F9E.5
0F18:  BRA    0F16
....................       rxData = USART_RxCharBuffer();  
0F1A:  MOVLB  0
0F1C:  RCALL  08C6
0F1E:  MOVFF  01,178
....................       if(rxData==0x03)     
0F22:  MOVLB  1
0F24:  MOVF   x78,W
0F26:  SUBLW  03
0F28:  BNZ   0F30
....................          modbusReadReg();   
0F2A:  MOVLB  0
0F2C:  BRA    0A00
0F2E:  MOVLB  1
....................       if(rxData==0x06)                                    
0F30:  MOVF   x78,W
0F32:  SUBLW  06
0F34:  BNZ   0F3C
....................          modbusWriteSingleReg(); 
0F36:  MOVLB  0
0F38:  BRA    0C4A
0F3A:  MOVLB  1
....................       if(rxData==0x10)                                    
0F3C:  MOVF   x78,W
0F3E:  SUBLW  10
0F40:  BNZ   0F48
....................          modbusWriteMultipleReg();  
0F42:  MOVLB  0
0F44:  BRA    0D46
0F46:  MOVLB  1
....................    } 
....................    if(comStat){        
0F48:  MOVF   x77,F
0F4A:  BZ    0F4E
....................       comStat=0;                                 
0F4C:  CLRF   x77
....................       return;                      
....................    }                                                   
0F4E:  MOVLB  0
0F50:  GOTO   0156 (RETURN)
.................... }   
....................                                                                      
.................... //########## Function 03 (03hex) Read Holding Registers ########    
.................... void modbusReadReg(){                                                         
....................    query[0] = 0x01;    
*
0A00:  MOVLW  01
0A02:  MOVWF  7B
....................    query[1] = 0x03;  
0A04:  MOVLW  03
0A06:  MOVWF  7C
....................     
....................    uchar_t ii,charTime; 
....................    for(ii=2;ii<8;ii++){  
0A08:  MOVLW  02
0A0A:  MOVLB  1
0A0C:  MOVWF  x79
0A0E:  MOVF   x79,W
0A10:  SUBLW  07
0A12:  BTFSS  FD8.0
0A14:  BRA    0BAE
....................       charTime=0;                                                                                                     
0A16:  CLRF   x7A
....................       while(RCIF_PIR1==0){   
0A18:  BTFSC  F9E.5
0A1A:  BRA    0A38
....................         delay_us(20);  
0A1C:  MOVLW  0C
0A1E:  MOVWF  00
0A20:  DECFSZ 00,F
0A22:  BRA    0A20
0A24:  BRA    0A26
0A26:  NOP   
....................         charTime++; 
0A28:  INCF   x7A,F
....................         if(charTime>=200){ 
0A2A:  MOVF   x7A,W
0A2C:  SUBLW  C7
0A2E:  BC    0A36
....................            comStat = 1;                                                
0A30:  MOVLW  01
0A32:  MOVWF  x77
....................            break; 
0A34:  BRA    0A38
....................         }         
0A36:  BRA    0A18
....................       }                                        
....................       query[ii]=USART_RxCharBuffer(); 
0A38:  CLRF   03
0A3A:  MOVF   x79,W
0A3C:  ADDLW  7B
0A3E:  MOVWF  01
0A40:  MOVLW  00
0A42:  ADDWFC 03,F
0A44:  MOVFF  01,181
0A48:  MOVFF  03,182
0A4C:  MOVLB  0
0A4E:  RCALL  08C6
0A50:  MOVFF  182,FEA
0A54:  MOVFF  181,FE9
0A58:  MOVFF  01,FEF
....................       if(comStat==1||ii>=7){  
0A5C:  MOVLB  1
0A5E:  DECFSZ x77,W
0A60:  BRA    0A64
0A62:  BRA    0A6C
0A64:  MOVF   x79,W
0A66:  SUBLW  06
0A68:  BTFSC  FD8.0
0A6A:  BRA    0BAA
....................          crcCheckCode = CRC16(0,8);    
0A6C:  CLRF   x82
0A6E:  MOVLW  08
0A70:  MOVWF  x83
0A72:  MOVLB  0
0A74:  RCALL  08D0
0A76:  MOVFF  02,176
0A7A:  MOVFF  01,175
....................          if(((crcCheckCode >> 8)&0x00FF)==query[6] &&((crcCheckCode)&0x00FF)==query[7]){    
0A7E:  MOVFF  176,181
0A82:  MOVLB  1
0A84:  CLRF   x82
0A86:  CLRF   x82
0A88:  MOVLB  0
0A8A:  MOVF   x81,W
0A8C:  MOVLB  1
0A8E:  SUBWF  x76,W
0A90:  BTFSS  FD8.2
0A92:  BRA    0BAA
0A94:  MOVF   x82,F
0A96:  BTFSS  FD8.2
0A98:  BRA    0BAA
0A9A:  MOVFF  175,181
0A9E:  CLRF   x82
0AA0:  MOVLB  0
0AA2:  MOVF   x82,W
0AA4:  MOVLB  1
0AA6:  SUBWF  x75,W
0AA8:  BTFSS  FD8.2
0AAA:  BRA    0BAA
0AAC:  MOVF   x82,F
0AAE:  BTFSS  FD8.2
0AB0:  BRA    0BAA
....................             uint16_t startingAddr = (query[2] << 8 | query[3]);                  
....................             uint16_t numOfReg = (query[4] << 8 | query[5]);  
....................             uint8_t byteCount = numOfReg*2;   
0AB2:  MOVLW  00
0AB4:  IORWF  7E,W
0AB6:  MOVWF  x7B
0AB8:  CLRF   x7C
0ABA:  MOVLW  00
0ABC:  MOVLB  0
0ABE:  IORWF  x80,W
0AC0:  MOVLB  1
0AC2:  MOVWF  x7D
0AC4:  CLRF   x7E
0AC6:  BCF    FD8.0
0AC8:  RLCF   x7D,W
0ACA:  MOVWF  02
0ACC:  RLCF   x7E,W
0ACE:  MOVFF  02,17F
....................             response[0]=0x01;                                            // SlaveAddress 
0AD2:  MOVLW  01
0AD4:  MOVLB  0
0AD6:  MOVWF  xF8
....................             response[1]=0x03;                                            // Function                                         
0AD8:  MOVLW  03
0ADA:  MOVWF  xF9
....................             response[2]=numOfReg*2;                                      // ByteCount            
0ADC:  BCF    FD8.0
0ADE:  MOVLB  1
0AE0:  RLCF   x7D,W
0AE2:  MOVWF  02
0AE4:  RLCF   x7E,W
0AE6:  MOVFF  02,FA
0AEA:  MOVLB  0
....................             for(uchar_t ii=3;ii<byteCount+3;ii++){                       // DATA 
0AEC:  MOVLW  03
0AEE:  MOVLB  1
0AF0:  MOVWF  x80
0AF2:  MOVLW  03
0AF4:  ADDWF  x7F,W
0AF6:  SUBWF  x80,W
0AF8:  BC    0B56
....................                if(ii%2==1)                                               // DATA High      
0AFA:  MOVF   x80,W
0AFC:  ANDLW  01
0AFE:  SUBLW  01
0B00:  BNZ   0B14
....................                  response[ii]=0x00;                                     
0B02:  CLRF   03
0B04:  MOVF   x80,W
0B06:  ADDLW  F8
0B08:  MOVWF  FE9
0B0A:  MOVLW  00
0B0C:  ADDWFC 03,W
0B0E:  MOVWF  FEA
0B10:  CLRF   FEF
0B12:  BRA    0B52
....................                else                                                      // DATA Low 
....................                  response[ii]=timeDateReadData[startingAddr+((ii-3)/2)]; //   ...          
0B14:  CLRF   03
0B16:  MOVF   x80,W
0B18:  ADDLW  F8
0B1A:  MOVWF  01
0B1C:  MOVLW  00
0B1E:  ADDWFC 03,F
0B20:  MOVLW  03
0B22:  SUBWF  x80,W
0B24:  MOVWF  00
0B26:  BCF    FD8.0
0B28:  RRCF   00,F
0B2A:  MOVF   00,W
0B2C:  ADDWF  x7B,W
0B2E:  MOVWF  x83
0B30:  MOVLW  00
0B32:  ADDWFC x7C,W
0B34:  MOVWF  x84
0B36:  MOVLW  6B
0B38:  ADDWF  x83,W
0B3A:  MOVWF  FE9
0B3C:  MOVLW  00
0B3E:  ADDWFC x84,W
0B40:  MOVWF  FEA
0B42:  MOVFF  FEF,185
0B46:  MOVFF  03,FEA
0B4A:  MOVFF  01,FE9
0B4E:  MOVFF  185,FEF
0B52:  INCF   x80,F
0B54:  BRA    0AF2
....................             }                                                            //   ...                                                                        
....................             crcCheckCode = CRC16(1,(5+byteCount));        
0B56:  MOVLW  05
0B58:  ADDWF  x7F,W
0B5A:  MOVWF  x81
0B5C:  MOVLW  01
0B5E:  MOVWF  x82
0B60:  MOVFF  181,183
0B64:  MOVLB  0
0B66:  RCALL  08D0
0B68:  MOVFF  02,176
0B6C:  MOVFF  01,175
....................             response[3+byteCount] = (crcCheckCode >> 8) & 0x00FF;        // Error Check High  
0B70:  MOVLW  03
0B72:  MOVLB  1
0B74:  ADDWF  x7F,W
0B76:  CLRF   03
0B78:  ADDLW  F8
0B7A:  MOVWF  FE9
0B7C:  MOVLW  00
0B7E:  ADDWFC 03,W
0B80:  MOVWF  FEA
0B82:  MOVFF  176,FEF
....................             response[4+byteCount] = (crcCheckCode) & 0x00FF;             // Error Check Low  
0B86:  MOVLW  04
0B88:  ADDWF  x7F,W
0B8A:  CLRF   03
0B8C:  ADDLW  F8
0B8E:  MOVWF  FE9
0B90:  MOVLW  00
0B92:  ADDWFC 03,W
0B94:  MOVWF  FEA
0B96:  MOVFF  175,FEF
....................             modbusResponse(5+byteCount);                         
0B9A:  MOVLW  05
0B9C:  ADDWF  x7F,W
0B9E:  MOVWF  x81
0BA0:  MOVWF  x82
0BA2:  MOVLB  0
0BA4:  RCALL  09B6
....................             return; 
0BA6:  BRA    0BAE
0BA8:  MOVLB  1
....................         } 
....................       } 
0BAA:  INCF   x79,F
0BAC:  BRA    0A0E
0BAE:  MOVLB  0
....................    }                                    
0BB0:  GOTO   0F2E (RETURN)
.................... }                             
.................... //########## Function 06 (06hex) Write Single Register ########                                   
.................... void modbusWriteSingleReg(){                                        
....................    query[0] = 0x01; 
*
0C4A:  MOVLW  01
0C4C:  MOVWF  7B
....................    query[1] = 0x06;   
0C4E:  MOVLW  06
0C50:  MOVWF  7C
....................    uchar_t ii,charTime; 
....................    for(ii=2;ii<8;ii++){ 
0C52:  MOVLW  02
0C54:  MOVLB  1
0C56:  MOVWF  x79
0C58:  MOVF   x79,W
0C5A:  SUBLW  07
0C5C:  BTFSS  FD8.0
0C5E:  BRA    0D40
....................       charTime=0;  
0C60:  CLRF   x7A
....................       while(RCIF_PIR1==0){                       
0C62:  BTFSC  F9E.5
0C64:  BRA    0C82
....................         delay_us(20);                 
0C66:  MOVLW  0C
0C68:  MOVWF  00
0C6A:  DECFSZ 00,F
0C6C:  BRA    0C6A
0C6E:  BRA    0C70
0C70:  NOP   
....................         charTime++; 
0C72:  INCF   x7A,F
....................         if(charTime>=200){     
0C74:  MOVF   x7A,W
0C76:  SUBLW  C7
0C78:  BC    0C80
....................            comStat = 1;  
0C7A:  MOVLW  01
0C7C:  MOVWF  x77
....................            break; 
0C7E:  BRA    0C82
....................         }                          
0C80:  BRA    0C62
....................       }                                    
....................       query[ii]=USART_RxCharBuffer();  
0C82:  CLRF   03
0C84:  MOVF   x79,W
0C86:  ADDLW  7B
0C88:  MOVWF  01
0C8A:  MOVLW  00
0C8C:  ADDWFC 03,F
0C8E:  MOVFF  01,17B
0C92:  MOVFF  03,17C
0C96:  MOVLB  0
0C98:  RCALL  08C6
0C9A:  MOVFF  17C,FEA
0C9E:  MOVFF  17B,FE9
0CA2:  MOVFF  01,FEF
....................       if(comStat==1||ii>=7){  
0CA6:  MOVLB  1
0CA8:  DECFSZ x77,W
0CAA:  BRA    0CAE
0CAC:  BRA    0CB4
0CAE:  MOVF   x79,W
0CB0:  SUBLW  06
0CB2:  BC    0D3C
....................          crcCheckCode = CRC16(0,8);    
0CB4:  CLRF   x82
0CB6:  MOVLW  08
0CB8:  MOVWF  x83
0CBA:  MOVLB  0
0CBC:  RCALL  08D0
0CBE:  MOVFF  02,176
0CC2:  MOVFF  01,175
....................          if(((crcCheckCode >> 8)&0x00FF)==query[6] &&((crcCheckCode)&0x00FF)==query[7]){  
0CC6:  MOVFF  176,17B
0CCA:  MOVLB  1
0CCC:  CLRF   x7C
0CCE:  CLRF   x7C
0CD0:  MOVLB  0
0CD2:  MOVF   x81,W
0CD4:  MOVLB  1
0CD6:  SUBWF  x76,W
0CD8:  BNZ   0D3C
0CDA:  MOVF   x7C,F
0CDC:  BNZ   0D3C
0CDE:  MOVFF  175,17B
0CE2:  CLRF   x7C
0CE4:  MOVLB  0
0CE6:  MOVF   x82,W
0CE8:  MOVLB  1
0CEA:  SUBWF  x75,W
0CEC:  BNZ   0D3C
0CEE:  MOVF   x7C,F
0CF0:  BNZ   0D3C
....................             timeDateWriteData[query[3]-7]=query[5];      
0CF2:  MOVLW  07
0CF4:  SUBWF  7E,W
0CF6:  CLRF   03
0CF8:  ADDLW  72
0CFA:  MOVWF  FE9
0CFC:  MOVLW  00
0CFE:  ADDWFC 03,W
0D00:  MOVWF  FEA
0D02:  MOVFF  80,FEF
....................             ds1307_write_date(query[3]-7,1);   
0D06:  MOVLW  07
0D08:  SUBWF  7E,W
0D0A:  MOVWF  x7B
0D0C:  MOVWF  x7D
0D0E:  MOVLW  01
0D10:  MOVWF  x7E
0D12:  MOVLB  0
0D14:  RCALL  0BD8
....................             memcpy(response,query,8);                 
0D16:  CLRF   FEA
0D18:  MOVLW  F8
0D1A:  MOVWF  FE9
0D1C:  CLRF   FE2
0D1E:  MOVLW  7B
0D20:  MOVWF  FE1
0D22:  MOVLW  08
0D24:  MOVWF  01
0D26:  MOVFF  FE6,FEE
0D2A:  DECFSZ 01,F
0D2C:  BRA    0D26
....................             modbusResponse(8);  
0D2E:  MOVLW  08
0D30:  MOVLB  1
0D32:  MOVWF  x82
0D34:  MOVLB  0
0D36:  RCALL  09B6
....................             return;     
0D38:  BRA    0D40
0D3A:  MOVLB  1
....................          } 
....................       }     
0D3C:  INCF   x79,F
0D3E:  BRA    0C58
0D40:  MOVLB  0
....................    }                                          
0D42:  GOTO   0F3A (RETURN)
.................... }                                                    
.................... //########## Function 16 (10hex) Write Multiple Registers ########                                                    
.................... void modbusWriteMultipleReg(){    
....................    query[0] = 0x01;                    // Slave Address              0 
0D46:  MOVLW  01
0D48:  MOVWF  7B
....................    query[1] = 0x10;                    // Function                   1                                                   
0D4A:  MOVLW  10
0D4C:  MOVWF  7C
....................    uchar_t ii,charTime,byteCount;      // Starting Address HIGH      2 
....................    for(ii=2;ii<7;ii++){                // Starting Address LOW       3 
0D4E:  MOVLW  02
0D50:  MOVLB  1
0D52:  MOVWF  x79
0D54:  MOVF   x79,W
0D56:  SUBLW  06
0D58:  BNC   0DA6
....................       charTime=0;                      // Number of Registers HIGH   4 
0D5A:  CLRF   x7A
....................       while(RCIF_PIR1==0){             // Number of Registers LOW    5 
0D5C:  BTFSC  F9E.5
0D5E:  BRA    0D7C
....................         delay_us(20);                  // Byte Count                 6 
0D60:  MOVLW  0C
0D62:  MOVWF  00
0D64:  DECFSZ 00,F
0D66:  BRA    0D64
0D68:  BRA    0D6A
0D6A:  NOP   
....................         charTime++; 
0D6C:  INCF   x7A,F
....................         if(charTime>=200){     
0D6E:  MOVF   x7A,W
0D70:  SUBLW  C7
0D72:  BC    0D7A
....................            comStat = 1;  
0D74:  MOVLW  01
0D76:  MOVWF  x77
....................            break; 
0D78:  BRA    0D7C
....................         }                          
0D7A:  BRA    0D5C
....................       } 
....................       query[ii]=USART_RxCharBuffer(); 
0D7C:  CLRF   03
0D7E:  MOVF   x79,W
0D80:  ADDLW  7B
0D82:  MOVWF  01
0D84:  MOVLW  00
0D86:  ADDWFC 03,F
0D88:  MOVFF  01,17C
0D8C:  MOVFF  03,17D
0D90:  MOVLB  0
0D92:  RCALL  08C6
0D94:  MOVFF  17D,FEA
0D98:  MOVFF  17C,FE9
0D9C:  MOVFF  01,FEF
0DA0:  MOVLB  1
0DA2:  INCF   x79,F
0DA4:  BRA    0D54
....................    }       
....................    byteCount = query[6]; 
0DA6:  MOVFF  81,17B
....................    for(ii=7;ii<8+byteCount+2;ii++){    // DATA HIGH                  7                                                    
0DAA:  MOVLW  07
0DAC:  MOVWF  x79
0DAE:  MOVLW  08
0DB0:  ADDWF  x7B,W
0DB2:  ADDLW  02
0DB4:  SUBWF  x79,W
0DB6:  BC    0E04
....................       charTime=0;                      // DATA LOW                   8 
0DB8:  CLRF   x7A
....................       while(RCIF_PIR1==0){             // DATA LOW                   n  
0DBA:  BTFSC  F9E.5
0DBC:  BRA    0DDA
....................         delay_us(20);                  // DATA LOW                   n+1     
0DBE:  MOVLW  0C
0DC0:  MOVWF  00
0DC2:  DECFSZ 00,F
0DC4:  BRA    0DC2
0DC6:  BRA    0DC8
0DC8:  NOP   
....................         charTime++;                    // CRC  HIGH                  n+2  
0DCA:  INCF   x7A,F
....................         if(charTime>=200){             // CRC  LOW                   n+3  
0DCC:  MOVF   x7A,W
0DCE:  SUBLW  C7
0DD0:  BC    0DD8
....................            comStat = 1;  
0DD2:  MOVLW  01
0DD4:  MOVWF  x77
....................            break; 
0DD6:  BRA    0DDA
....................         }                          
0DD8:  BRA    0DBA
....................       } 
....................       query[ii]=USART_RxCharBuffer();   
0DDA:  CLRF   03
0DDC:  MOVF   x79,W
0DDE:  ADDLW  7B
0DE0:  MOVWF  01
0DE2:  MOVLW  00
0DE4:  ADDWFC 03,F
0DE6:  MOVFF  01,17C
0DEA:  MOVFF  03,17D
0DEE:  MOVLB  0
0DF0:  RCALL  08C6
0DF2:  MOVFF  17D,FEA
0DF6:  MOVFF  17C,FE9
0DFA:  MOVFF  01,FEF
0DFE:  MOVLB  1
0E00:  INCF   x79,F
0E02:  BRA    0DAE
....................    } 
....................    crcCheckCode = CRC16(0,9+byteCount); 
0E04:  MOVLW  09
0E06:  ADDWF  x7B,W
0E08:  MOVWF  x7C
0E0A:  CLRF   x82
0E0C:  MOVWF  x83
0E0E:  MOVLB  0
0E10:  RCALL  08D0
0E12:  MOVFF  02,176
0E16:  MOVFF  01,175
....................    if(((crcCheckCode >> 8)&0x00FF)==query[9+byteCount-2] &&((crcCheckCode)&0x00FF)==query[9+byteCount-1]){  
0E1A:  MOVFF  176,17C
0E1E:  MOVLB  1
0E20:  CLRF   x7D
0E22:  CLRF   x7D
0E24:  MOVLW  09
0E26:  ADDWF  x7B,W
0E28:  ADDLW  FE
0E2A:  CLRF   03
0E2C:  ADDLW  7B
0E2E:  MOVWF  FE9
0E30:  MOVLW  00
0E32:  ADDWFC 03,W
0E34:  MOVWF  FEA
0E36:  MOVF   FEF,W
0E38:  SUBWF  x76,W
0E3A:  BNZ   0EFE
0E3C:  MOVF   x7D,F
0E3E:  BNZ   0EFE
0E40:  MOVFF  175,17C
0E44:  CLRF   x7D
0E46:  MOVLW  09
0E48:  ADDWF  x7B,W
0E4A:  ADDLW  FF
0E4C:  CLRF   03
0E4E:  ADDLW  7B
0E50:  MOVWF  FE9
0E52:  MOVLW  00
0E54:  ADDWFC 03,W
0E56:  MOVWF  FEA
0E58:  MOVF   FEF,W
0E5A:  SUBWF  x75,W
0E5C:  BNZ   0EFE
0E5E:  MOVF   x7D,F
0E60:  BNZ   0EFE
....................       memcpy(response,query,6);           
0E62:  CLRF   FEA
0E64:  MOVLW  F8
0E66:  MOVWF  FE9
0E68:  CLRF   FE2
0E6A:  MOVLW  7B
0E6C:  MOVWF  FE1
0E6E:  MOVLW  06
0E70:  MOVWF  01
0E72:  MOVFF  FE6,FEE
0E76:  DECFSZ 01,F
0E78:  BRA    0E72
....................       crcCheckCode = CRC16(1,8);                  
0E7A:  MOVLW  01
0E7C:  MOVWF  x82
0E7E:  MOVLW  08
0E80:  MOVWF  x83
0E82:  MOVLB  0
0E84:  RCALL  08D0
0E86:  MOVFF  02,176
0E8A:  MOVFF  01,175
....................       response[6]= (crcCheckCode >> 8) & 0x00FF;                   // Error Check Low   
0E8E:  MOVFF  176,FE
0E92:  MOVLB  0
....................       response[7]= (crcCheckCode) & 0x00FF;                        // Error Check High  
0E94:  MOVFF  175,FF
0E98:  MOVLB  0
....................       for(ii=0;ii<query[5];ii++){ 
0E9A:  MOVLB  1
0E9C:  CLRF   x79
0E9E:  MOVLB  0
0EA0:  MOVF   x80,W
0EA2:  MOVLB  1
0EA4:  SUBWF  x79,W
0EA6:  BC    0EE2
....................          timeDateWriteData[ii+query[3]-7]=query[8+(ii*2)]; 
0EA8:  MOVF   7E,W
0EAA:  ADDWF  x79,W
0EAC:  ADDLW  F9
0EAE:  CLRF   03
0EB0:  ADDLW  72
0EB2:  MOVWF  01
0EB4:  MOVLW  00
0EB6:  ADDWFC 03,F
0EB8:  MOVFF  03,17D
0EBC:  BCF    FD8.0
0EBE:  RLCF   x79,W
0EC0:  ADDLW  08
0EC2:  CLRF   03
0EC4:  ADDLW  7B
0EC6:  MOVWF  FE9
0EC8:  MOVLW  00
0ECA:  ADDWFC 03,W
0ECC:  MOVWF  FEA
0ECE:  MOVFF  FEF,17E
0ED2:  MOVFF  17D,FEA
0ED6:  MOVFF  01,FE9
0EDA:  MOVFF  17E,FEF
0EDE:  INCF   x79,F
0EE0:  BRA    0E9E
....................       } 
....................       ds1307_write_date(query[3]-7,query[5]);   
0EE2:  MOVLW  07
0EE4:  SUBWF  7E,W
0EE6:  MOVWF  x7C
0EE8:  MOVWF  x7D
0EEA:  MOVFF  80,17E
0EEE:  MOVLB  0
0EF0:  RCALL  0BD8
....................       modbusResponse(8);   
0EF2:  MOVLW  08
0EF4:  MOVLB  1
0EF6:  MOVWF  x82
0EF8:  MOVLB  0
0EFA:  RCALL  09B6
0EFC:  MOVLB  1
....................    } 
0EFE:  MOVLB  0
0F00:  GOTO   0F46 (RETURN)
.................... }                                      
....................  
....................  
.................... void modbusResponse(uchar_t length){   
....................    clearQuery(); 
*
09B6:  BRA    0982
....................    uchar_t charTime=0,ii;  
09B8:  MOVLB  1
09BA:  CLRF   x83
....................    while(charTime>=200){                        
09BC:  MOVF   x83,W
09BE:  SUBLW  C7
09C0:  BC    09D2
....................       delay_us(20);                          
09C2:  MOVLW  0C
09C4:  MOVWF  00
09C6:  DECFSZ 00,F
09C8:  BRA    09C6
09CA:  BRA    09CC
09CC:  NOP   
....................       charTime++;                           
09CE:  INCF   x83,F
09D0:  BRA    09BC
....................    }                                                                                                              
....................    for(ii=0;ii<length;ii++){                          
09D2:  CLRF   x84
09D4:  MOVF   x82,W
09D6:  SUBWF  x84,W
09D8:  BC    09FA
....................       USART_TxCharBuffer(response[ii]);                        
09DA:  CLRF   03
09DC:  MOVF   x84,W
09DE:  ADDLW  F8
09E0:  MOVWF  FE9
09E2:  MOVLW  00
09E4:  ADDWFC 03,W
09E6:  MOVWF  FEA
09E8:  MOVFF  FEF,185
09EC:  MOVFF  185,186
09F0:  MOVLB  0
09F2:  BRA    0996
09F4:  MOVLB  1
09F6:  INCF   x84,F
09F8:  BRA    09D4
....................    }              
....................    clearResponse();  
09FA:  MOVLB  0
09FC:  BRA    09A2
09FE:  RETURN 0
.................... }   
.................... void clearResponse(){ 
....................    memset(response, 0, 125);   
*
09A2:  CLRF   FEA
09A4:  MOVLW  F8
09A6:  MOVWF  FE9
09A8:  CLRF   00
09AA:  CLRF   02
09AC:  MOVLW  7D
09AE:  MOVWF  01
09B0:  RCALL  0968
09B2:  GOTO   09FE (RETURN)
.................... }  
.................... void clearQuery(){ 
....................    memset(query, 0, 125); 
*
0982:  CLRF   FEA
0984:  MOVLW  7B
0986:  MOVWF  FE9
0988:  CLRF   00
098A:  CLRF   02
098C:  MOVLW  7D
098E:  MOVWF  01
0990:  RCALL  0968
0992:  GOTO   09B8 (RETURN)
.................... }                                            
.................... uint16_t CRC16(uchar_t mode, uint8_t length){ 
*
08D0:  MOVLB  1
08D2:  CLRF   x84
08D4:  SETF   x85
08D6:  SETF   x86
08D8:  CLRF   x89
....................    uchar_t ii=0;  
....................    uchar_t CRC_Hi = 0xFF;                        
....................    uchar_t CRC_Lo = 0xFF;         
....................    uint16_t CRC;             
....................    uint8_t index=0;                   
....................    while (ii<length-2){   
08DA:  MOVLW  02
08DC:  SUBWF  x83,W
08DE:  SUBWF  x84,W
08E0:  BC    0946
....................       if(mode==0) 
08E2:  MOVF   x82,F
08E4:  BNZ   08FC
....................          index = CRC_Hi ^ query[ii];           
08E6:  CLRF   03
08E8:  MOVF   x84,W
08EA:  ADDLW  7B
08EC:  MOVWF  FE9
08EE:  MOVLW  00
08F0:  ADDWFC 03,W
08F2:  MOVWF  FEA
08F4:  MOVF   FEF,W
08F6:  XORWF  x85,W
08F8:  MOVWF  x89
08FA:  BRA    0910
....................       else  
....................          index = CRC_Hi ^ response[ii];            
08FC:  CLRF   03
08FE:  MOVF   x84,W
0900:  ADDLW  F8
0902:  MOVWF  FE9
0904:  MOVLW  00
0906:  ADDWFC 03,W
0908:  MOVWF  FEA
090A:  MOVF   FEF,W
090C:  XORWF  x85,W
090E:  MOVWF  x89
....................       CRC_Hi = CRC_Lo ^ Table_CRC_Hi[index]; 
0910:  CLRF   03
0912:  MOVF   x89,W
0914:  MOVFF  FF2,18A
0918:  BCF    FF2.7
091A:  MOVLB  0
091C:  RCALL  0402
091E:  MOVLB  1
0920:  BTFSC  x8A.7
0922:  BSF    FF2.7
0924:  MOVWF  01
0926:  MOVF   x86,W
0928:  XORWF  01,W
092A:  MOVWF  x85
....................       CRC_Lo = Table_CRC_Lo[index];    
092C:  CLRF   03
092E:  MOVF   x89,W
0930:  MOVFF  FF2,18A
0934:  BCF    FF2.7
0936:  MOVLB  0
0938:  RCALL  051C
093A:  MOVLB  1
093C:  BTFSC  x8A.7
093E:  BSF    FF2.7
0940:  MOVWF  x86
....................       ii++;                         
0942:  INCF   x84,F
0944:  BRA    08DA
....................    }          
....................    CRC = CRC_Hi;                   
0946:  CLRF   x88
0948:  MOVFF  185,187
....................    CRC = (CRC<<8) | CRC_Lo; 
094C:  MOVFF  187,18B
0950:  CLRF   x8A
0952:  MOVF   x8A,W
0954:  IORWF  x86,W
0956:  MOVWF  x87
0958:  MOVFF  18B,188
....................    return CRC;                    
095C:  MOVFF  187,01
0960:  MOVFF  188,02
0964:  MOVLB  0
0966:  RETURN 0
.................... }                                               
....................                                                         
.................... #endif  //MODBUSRTU_H                               
....................  
....................                          
....................                                              
.................... uint16_t iSayac;  
.................... tmr1_time_t tmr1_time;    
....................                             
....................                    
.................... void setupTimerIOSC(void){  
....................  //Setup Osilator 
....................    IRCF2 = 1;        
*
073A:  BSF    FD3.6
....................    IRCF1 = 1; 
073C:  BSF    FD3.5
....................    IRCF0 = 1;                    
073E:  BSF    FD3.4
....................                          
....................    //D ve P portlari cikis olarak ayarlanip sifirlandi. 
....................    TRISB = 0x00;                  
0740:  CLRF   F93
....................    TRISD = 0x00; 
0742:  CLRF   F95
....................    TRISE = 0x00;       
0744:  CLRF   F96
....................    PORTB = 0x00;                                                       
0746:  CLRF   F81
....................    PORTD = 0x00; 
0748:  CLRF   F8C
....................    PORTE = 0x00;   
074A:  CLRF   F84
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
074C:  CLRF   19
....................  
....................    // Kesmelere izin verildi 
....................    RCON_IPEN = 1;                                               
074E:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 1; 
0750:  BSF    FF2.7
....................    INTCON_PEIE = 1;           
0752:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
0754:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
0756:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
0758:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit 
075A:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
075C:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
075E:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
0760:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
0762:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
0764:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
0766:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
0768:  MOVLW  F8
076A:  MOVWF  FCF
....................    TMR1L = 0x30; // |||65436 decimal sayisina esit.  
076C:  MOVLW  30
076E:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit                                   
0770:  BSF    FCD.0
0772:  GOTO   013E (RETURN)
.................... }       
....................                                                     
....................                                                                                                                   
.................... void printOn2x16(){ 
....................    delayUsFun(40);                                                                                                                                       
*
07EE:  MOVLW  28
07F0:  MOVLB  1
07F2:  MOVWF  x7C
07F4:  MOVLB  0
07F6:  RCALL  00DC
....................    twoLinesBCDMode();    
07F8:  BRA    00EE
....................    LinesActive();   
07FA:  BRA    07B6
....................    lcdCursorOff(); 
07FC:  BRA    07C4
....................    lcdShiftRight();                      
07FE:  BRA    07D2
....................    lcdClear();                                                    
0800:  BRA    07E0
....................    memcpy(strLCD, "INFORMELEKTRONIKAR-GE    STAJYER", 32);  
0802:  CLRF   FEA
0804:  MOVLW  49
0806:  MOVWF  FE9
0808:  MOVFF  FF2,178
080C:  BCF    FF2.7
080E:  MOVLW  20
0810:  MOVWF  01
0812:  CLRF   FF7
0814:  MOVLW  00
0816:  RCALL  0636
0818:  TBLRD*-
081A:  TBLRD*+
081C:  MOVFF  FF5,FEE
0820:  DECFSZ 01,F
0822:  BRA    081A
0824:  MOVLB  1
0826:  BTFSC  x78.7
0828:  BSF    FF2.7
....................    countLCDChar=0;    
082A:  CLRF   69
....................    LCDW1SecFlag=1;                        
082C:  MOVLW  01
082E:  MOVWF  6A
0830:  MOVLB  0
0832:  GOTO   0140 (RETURN)
....................    // LCD_Custom_CHAR(7, legrandLCDCharacter); 
....................    //LCD_Custom_CHAR(6, stickManLCDCharacter);                                
.................... }          
....................                                                   
.................... #INT_TIMER1                                                            
.................... void interrupt(){             
....................    TMR1H = 0xF8; //Tasma saayci| 
*
069E:  MOVLW  F8
06A0:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.                      
06A2:  MOVLW  30
06A4:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor. 
06A6:  BCF    F9E.0
....................    iSayac++;  
06A8:  INCF   17,F
06AA:  BTFSC  FD8.2
06AC:  INCF   18,F
....................    if (iSayac % 1 == 0) //1ms  
06AE:  MOVLB  1
06B0:  CLRF   xA7
06B2:  CLRF   xA8
06B4:  MOVF   xA7,F
06B6:  BNZ   06BE
06B8:  MOVF   xA8,F
06BA:  BNZ   06BE
....................       tmr1_time.tmr1_flags._1ms = true;       
06BC:  BSF    19.0
....................    if (iSayac % 2 == 0) //2ms      
06BE:  MOVF   17,W
06C0:  ANDLW  01
06C2:  MOVWF  xA7
06C4:  CLRF   xA8
06C6:  MOVF   xA7,F
06C8:  BNZ   06D0
06CA:  MOVF   xA8,F
06CC:  BNZ   06D0
....................       tmr1_time.tmr1_flags._2ms = true; 
06CE:  BSF    19.1
....................    if (iSayac % 20 == 0) //20ms   
06D0:  MOVFF  18,1A8
06D4:  MOVFF  17,1A7
06D8:  CLRF   xAA
06DA:  MOVLW  14
06DC:  MOVWF  xA9
06DE:  MOVLB  0
06E0:  RCALL  0096
06E2:  MOVFF  00,1A7
06E6:  MOVLB  1
06E8:  MOVFF  03,1A8
06EC:  MOVF   xA7,F
06EE:  BNZ   06F6
06F0:  MOVF   xA8,F
06F2:  BNZ   06F6
....................       tmr1_time.tmr1_flags._20ms = true;              
06F4:  BSF    19.2
....................    if (iSayac % 50 == 0) //50ms  
06F6:  MOVFF  18,1A8
06FA:  MOVFF  17,1A7
06FE:  CLRF   xAA
0700:  MOVLW  32
0702:  MOVWF  xA9
0704:  MOVLB  0
0706:  RCALL  0096
0708:  MOVFF  00,1A7
070C:  MOVLB  1
070E:  MOVFF  03,1A8
0712:  MOVF   xA7,F
0714:  BNZ   071C
0716:  MOVF   xA8,F
0718:  BNZ   071C
....................       tmr1_time.tmr1_flags._50ms = true; 
071A:  BSF    19.3
....................    if (iSayac > 1000){   // 1 Saniye          
071C:  MOVF   18,W
071E:  SUBLW  02
0720:  BC    0732
0722:  XORLW  FF
0724:  BNZ   072C
0726:  MOVF   17,W
0728:  SUBLW  E8
072A:  BC    0732
....................       tmr1_time.tmr1_flags._1000ms = true;   
072C:  BSF    19.7
....................       iSayac = 0;                                                  
072E:  CLRF   18
0730:  CLRF   17
....................    }                
....................                            
.................... }                                                 
....................                                                
....................               
0732:  BCF    F9E.0
0734:  MOVLB  0
0736:  GOTO   0054
.................... #ORG 0x0100,0x0400                                                                     
.................... void main(){                                  
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  MOVLW  70
0108:  MOVWF  FD3
010A:  MOVF   FD3,W
010C:  BSF    1A.3
010E:  CLRF   1C
0110:  CLRF   7A
0112:  CLRF   79
0114:  MOVF   FC1,W
0116:  ANDLW  C0
0118:  IORLW  0F
011A:  MOVWF  FC1
011C:  MOVLW  07
011E:  MOVWF  FB4
0120:  CLRF   6B
0122:  CLRF   6C
0124:  CLRF   6D
0126:  CLRF   6E
0128:  CLRF   6F
012A:  CLRF   70
012C:  CLRF   71
012E:  CLRF   72
0130:  CLRF   73
0132:  CLRF   74
0134:  CLRF   75
0136:  CLRF   76
0138:  CLRF   77
013A:  CLRF   78
....................    setupTimerIOSC(); 
013C:  BRA    073A
....................    printOn2x16();  
013E:  BRA    07EE
....................    I2C_Init();            
0140:  BRA    0836
....................    DS1307_Init(); 
0142:  BRA    0882
....................    USART_Init();  
0144:  BRA    08B2
....................    while(TRUE){           
....................      // WDTreset();  
....................      if(tmr1_time.tmr1_flags._1ms){   
0146:  BTFSS  19.0
0148:  BRA    0158
....................          tmr1_time.tmr1_flags._1ms = false;  
014A:  BCF    19.0
....................          if(RCIF_PIR1==1){   
014C:  BTFSS  F9E.5
014E:  BRA    0158
....................             T1CON_TMR1ON = 0; 
0150:  BCF    FCD.0
....................             modbusRTUrx(); 
0152:  GOTO   0F04
....................             T1CON_TMR1ON = 1;   
0156:  BSF    FCD.0
....................          }                                     
....................       }                                              
....................       if(tmr1_time.tmr1_flags._1000ms){               
0158:  BTFSS  19.7
015A:  BRA    0164
....................          tmr1_time.tmr1_flags._1000ms = false;          
015C:  BCF    19.7
....................          LCDW1SecFlag=1;              
015E:  MOVLW  01
0160:  MOVWF  6A
....................          PORTB_7=~PORTB_7;                         
0162:  BTG    F81.7
....................       }             
....................         
....................       if(tmr1_time.tmr1_flags._20ms){   
0164:  BTFSS  19.2
0166:  BRA    018E
....................          tmr1_time.tmr1_flags._20ms = false;  
0168:  BCF    19.2
....................          ds1307_run(27,7,23,2,14,59,10);                              
016A:  MOVLW  1B
016C:  MOVLB  1
016E:  MOVWF  x78
0170:  MOVLW  07
0172:  MOVWF  x79
0174:  MOVLW  17
0176:  MOVWF  x7A
0178:  MOVLW  02
017A:  MOVWF  x7B
017C:  MOVLW  0E
017E:  MOVWF  x7C
0180:  MOVLW  3B
0182:  MOVWF  x7D
0184:  MOVLW  0A
0186:  MOVWF  x7E
0188:  MOVLB  0
018A:  GOTO   177C
....................       }    
....................       if(tmr1_time.tmr1_flags._2ms){                                  
018E:  BTFSS  19.1
0190:  BRA    019C
....................          tmr1_time.tmr1_flags._2ms = false;   
0192:  BCF    19.1
....................          if(LCDW1SecFlag){      
0194:  MOVF   6A,F
0196:  BZ    019C
....................             LCD_String();     
0198:  GOTO   182A
....................          }  
....................       }    
019C:  BRA    0146
....................    }                                                         
.................... }                                        
....................  
019E:  SLEEP 
....................  
.................... void WDTreset(void){                
....................    #asm                 
....................    CLRWDT 
....................    #endasm                                  
.................... }                 
....................                                                                                              
....................                                                                                                  
....................                                         
....................  
....................         
....................                     

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 001E   PUT BROWNOUT BORV21 NOWDT WDT1
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
