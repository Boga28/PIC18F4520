CCS PCH C Compiler, Version 5.015, 5967               28-Jul-23 08:27

               Filename:   C:\18F4520\CCS\1-Wire-D18B20-LCD\main.lst

               ROM used:   1696 bytes (5%)
                           Largest free fragment is 30394
               RAM used:   72 (5%) at main() level
                           92 (6%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   0446
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir. 
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  CLRF   FF7
009E:  ADDLW  B0
00A0:  MOVWF  FF6
00A2:  MOVLW  00
00A4:  ADDWFC FF7,F
00A6:  TBLRD*+
00A8:  MOVF   FF5,W
00AA:  BTFSC  0D.7
00AC:  BSF    FF2.7
00AE:  RETURN 0
00B0:  DATA 49,4E
00B2:  DATA 46,4F
00B4:  DATA 52,4D
00B6:  DATA 45,4C
00B8:  DATA 45,4B
00BA:  DATA 54,52
00BC:  DATA 4F,4E
00BE:  DATA 49,4B
00C0:  DATA 41,52
00C2:  DATA 2D,47
00C4:  DATA 45,20
00C6:  DATA 20,20
00C8:  DATA 20,53
00CA:  DATA 54,41
00CC:  DATA 4A,59
00CE:  DATA 45,52
00D0:  DATA 00,00
00D2:  DATA 54,45
00D4:  DATA 4D,50
00D6:  DATA 20,3A
00D8:  DATA 25,4C
00DA:  DATA 64,00
*
0402:  CLRF   01
0404:  CLRF   02
0406:  CLRF   00
0408:  CLRF   03
040A:  MOVF   5A,W
040C:  BNZ   0412
040E:  MOVF   59,W
0410:  BZ    0442
0412:  MOVLW  10
0414:  MOVWF  5B
0416:  BCF    FD8.0
0418:  RLCF   57,F
041A:  RLCF   58,F
041C:  RLCF   00,F
041E:  RLCF   03,F
0420:  MOVF   5A,W
0422:  SUBWF  03,W
0424:  BNZ   042A
0426:  MOVF   59,W
0428:  SUBWF  00,W
042A:  BNC   043A
042C:  MOVF   59,W
042E:  SUBWF  00,F
0430:  BTFSS  FD8.0
0432:  DECF   03,F
0434:  MOVF   5A,W
0436:  SUBWF  03,F
0438:  BSF    FD8.0
043A:  RLCF   01,F
043C:  RLCF   02,F
043E:  DECFSZ 5B,F
0440:  BRA    0416
0442:  GOTO   0478 (RETURN)
*
063E:  MOVF   4E,W
0640:  XORWF  50,W
0642:  ANDLW  80
0644:  MOVWF  52
0646:  BTFSS  4E.7
0648:  BRA    0654
064A:  COMF   4D,F
064C:  COMF   4E,F
064E:  INCF   4D,F
0650:  BTFSC  FD8.2
0652:  INCF   4E,F
0654:  BTFSS  50.7
0656:  BRA    0662
0658:  COMF   4F,F
065A:  COMF   50,F
065C:  INCF   4F,F
065E:  BTFSC  FD8.2
0660:  INCF   50,F
0662:  CLRF   01
0664:  CLRF   02
0666:  CLRF   00
0668:  CLRF   03
066A:  MOVF   50,W
066C:  BNZ   0672
066E:  MOVF   4F,W
0670:  BZ    06A2
0672:  MOVLW  10
0674:  MOVWF  51
0676:  BCF    FD8.0
0678:  RLCF   4D,F
067A:  RLCF   4E,F
067C:  RLCF   00,F
067E:  RLCF   03,F
0680:  MOVF   50,W
0682:  SUBWF  03,W
0684:  BNZ   068A
0686:  MOVF   4F,W
0688:  SUBWF  00,W
068A:  BNC   069A
068C:  MOVF   4F,W
068E:  SUBWF  00,F
0690:  BTFSS  FD8.0
0692:  DECF   03,F
0694:  MOVF   50,W
0696:  SUBWF  03,F
0698:  BSF    FD8.0
069A:  RLCF   01,F
069C:  RLCF   02,F
069E:  DECFSZ 51,F
06A0:  BRA    0676
06A2:  BTFSS  52.7
06A4:  BRA    06B0
06A6:  COMF   01,F
06A8:  COMF   02,F
06AA:  INCF   01,F
06AC:  BTFSC  FD8.2
06AE:  INCF   02,F
06B0:  GOTO   0866 (RETURN)
06B4:  MOVFF  47,FEA
06B8:  MOVFF  46,FE9
06BC:  MOVFF  56,FEF
06C0:  INCF   FE9,F
06C2:  BTFSC  FD8.2
06C4:  INCF   FEA,F
06C6:  CLRF   FEF
06C8:  INCF   46,F
06CA:  BTFSC  FD8.2
06CC:  INCF   47,F
06CE:  RETURN 0
06D0:  TBLRD*+
06D2:  MOVFF  FF6,4E
06D6:  MOVFF  FF7,4F
06DA:  MOVFF  FF5,56
06DE:  RCALL  06B4
06E0:  MOVFF  4E,FF6
06E4:  MOVFF  4F,FF7
06E8:  DECFSZ 4D,F
06EA:  BRA    06D0
06EC:  GOTO   0882 (RETURN)
06F0:  MOVFF  FEA,55
06F4:  MOVFF  FE9,54
06F8:  BTFSS  4E.7
06FA:  BRA    070C
06FC:  BSF    54.7
06FE:  BTFSS  54.4
0700:  INCF   54,F
0702:  COMF   4D,F
0704:  COMF   4E,F
0706:  INCF   4D,F
0708:  BTFSC  FD8.2
070A:  INCF   4E,F
070C:  SWAPF  4E,W
070E:  IORLW  F0
0710:  MOVWF  50
0712:  ADDWF  50,F
0714:  ADDLW  E2
0716:  MOVWF  51
0718:  ADDLW  32
071A:  MOVWF  53
071C:  MOVF   4E,W
071E:  ANDLW  0F
0720:  ADDWF  51,F
0722:  ADDWF  51,F
0724:  ADDWF  53,F
0726:  ADDLW  E9
0728:  MOVWF  52
072A:  ADDWF  52,F
072C:  ADDWF  52,F
072E:  SWAPF  4D,W
0730:  ANDLW  0F
0732:  ADDWF  52,F
0734:  ADDWF  53,F
0736:  RLCF   52,F
0738:  RLCF   53,F
073A:  COMF   53,F
073C:  RLCF   53,F
073E:  MOVF   4D,W
0740:  ANDLW  0F
0742:  ADDWF  53,F
0744:  RLCF   50,F
0746:  MOVLW  07
0748:  MOVWF  4F
074A:  MOVLW  0A
074C:  DECF   52,F
074E:  ADDWF  53,F
0750:  BNC   074C
0752:  DECF   51,F
0754:  ADDWF  52,F
0756:  BNC   0752
0758:  DECF   50,F
075A:  ADDWF  51,F
075C:  BNC   0758
075E:  DECF   4F,F
0760:  ADDWF  50,F
0762:  BNC   075E
0764:  CLRF   FEA
0766:  MOVLW  4F
0768:  MOVWF  FE9
076A:  MOVLW  07
076C:  ANDWF  54,W
076E:  BCF    54.6
0770:  MOVF   FED,F
0772:  ANDWF  54,W
0774:  BNZ   0784
0776:  BTFSC  54.4
0778:  MOVF   FEE,F
077A:  BTFSC  54.4
077C:  BRA    0784
077E:  MOVLW  20
0780:  MOVWF  00
0782:  BRA    07C4
0784:  ADDWF  FE9,F
0786:  MOVLW  00
0788:  ADDWFC FEA,F
078A:  MOVF   FE9,W
078C:  SUBLW  53
078E:  BNZ   0796
0790:  MOVF   FEA,F
0792:  BNZ   0796
0794:  BSF    54.6
0796:  MOVF   FEF,W
0798:  MOVWF  00
079A:  BNZ   07AC
079C:  BTFSC  54.6
079E:  BRA    07AC
07A0:  BTFSC  54.4
07A2:  BRA    07DA
07A4:  BTFSC  54.3
07A6:  BRA    07AC
07A8:  MOVLW  20
07AA:  BRA    07C2
07AC:  BTFSS  54.7
07AE:  BRA    07BC
07B0:  MOVLW  2D
07B2:  MOVWF  00
07B4:  MOVF   FED,W
07B6:  BCF    54.6
07B8:  BCF    54.7
07BA:  BRA    07C4
07BC:  BSF    54.3
07BE:  BCF    54.4
07C0:  MOVLW  30
07C2:  ADDWF  00,F
07C4:  MOVFF  FEA,4E
07C8:  MOVFF  FE9,4D
07CC:  MOVFF  00,56
07D0:  RCALL  06B4
07D2:  MOVFF  4E,FEA
07D6:  MOVFF  4D,FE9
07DA:  MOVF   FEE,W
07DC:  BTFSS  54.6
07DE:  BRA    078A
07E0:  GOTO   0890 (RETURN)
07E4:  TSTFSZ 01
07E6:  BRA    07EE
07E8:  TSTFSZ 02
07EA:  BRA    07F0
07EC:  BRA    07FC
07EE:  INCF   02,F
07F0:  MOVFF  00,FEE
07F4:  DECFSZ 01,F
07F6:  BRA    07F0
07F8:  DECFSZ 02,F
07FA:  BRA    07F0
07FC:  GOTO   08A0 (RETURN)
....................  
.................... #list 
....................  
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanýr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       Â· LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       Â· WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini saðlar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       Â· PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin içine yükleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       Â· PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       Â· BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       Â· INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       Â· NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */                                
....................                                                          
.................... #FUSES NOWDT, WDT8, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC  
.................... #use delay (internal=8MHz)                     
*
057E:  MOVLW  09
0580:  SUBWF  4E,F
0582:  BNC   059A
0584:  CLRF   FEA
0586:  MOVLW  4E
0588:  MOVWF  FE9
058A:  BCF    FD8.0
058C:  RRCF   FEF,F
058E:  MOVF   FEF,W
0590:  BZ    059A
0592:  BRA    0596
0594:  NOP   
0596:  DECFSZ FEF,F
0598:  BRA    0594
059A:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7) 
.................... //#use i2c(Master, Fast=100000, sda=PIN_C4, scl=PIN_C3, SMBUS)             
....................                                             
.................... #include "definitions.h"                                                                                                       
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "main.h"                                                
.................... #ifndef MAIN_H      
.................... #define MAIN_H  
.................... #define DELAY 500  
....................                             
.................... void WDTreset(void);   
....................                      
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"                                     
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................  
.................... //   ################   D18B20  #################  //                            
.................... #byte LATC    = 0x0F8B   
.................... #bit  LATC_0  = LATC.0   
.................... #bit  TRISC_0 = TRISC.0   
.................... #bit  PORTC_0 = PORTC.0 
....................  
....................                                                                                                      
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h"                                                                                          
.................... #ifndef INITS_H 
.................... #define INITS_H       
....................  
.................... extern uint16_t iSayac;  
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _2ms    : 1;  //bit:0, 2ms  
....................       uint8_t _20ms   : 1;  //bit:1, 20ms  
....................       uint8_t _50ms   : 1;  //bit:2, 50ms  
....................       uint8_t _100ms  : 1;  //bit:3, 100ms     
....................       uint8_t _200ms  : 1;  //bit:4, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:5, 500ms  
....................       uint8_t _1000ms : 1;  //bit:6, 1000ms  
....................       uint8_t _500us  : 1;  //bit:7, 500us 
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t tmr1_time;     
....................  
....................  
....................  
....................  
....................                                                 
.................... #endif //INIT_H                               
....................  
.................... #include "lcd.h"                 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
....................                                                              
.................... #include "lcd.c"                                  
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "lcd.h" 
.................... #ifndef LCD_H                                                                                                
.................... #define LCD_H  
....................                                              
.................... extern uchar_t strLCD[32];   
.................... extern uint8_t countLCDChar; 
.................... extern uchar_t LCDW1SecFlag;         
.................... //uchar_t legrandLCDCharacter [8]= {0x08, 0x1F, 0x19, 0x11, 0x11, 0x13, 0x1F, 0x02}; 
.................... //uchar_t stickManLCDCharacter [8] = {0x0E, 0x0E, 0x04, 0x0F, 0x14, 0x0A, 0x1B, 0x00}; 
.................... void lcdcmd(uchar_t);                                                                                
.................... void lcddata(uchar_t);                                                                      
.................... void LCD_String();                                                                              
.................... //LCD (CHIP: HD44780), COMMANDS 
.................... void twoLinesBCDMode(); 
.................... void LinesActive(); 
.................... void lcdClear();                               
.................... void lcdGoToFirstLine();      
.................... void lcdGoToSecondLine(); 
.................... void lcdShiftRight(); 
.................... void lcdCursorOn();  
.................... void lcdCursorOff(); 
.................... void LCD_Custom_Char (uchar_t loc, uchar_t *msg); 
....................  
.................... #endif //LCD_H     
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                         
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1   
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81  
.................... #bit  PORTB_0=PORTB.0 
.................... #bit  PORTB_7=PORTB.7  
....................  
.................... // LCD PINS 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F8C                      
.................... #bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96 
.................... #byte PORTE = 0x0F84                        
.................... #bit  PORTE_RS=PORTE.0        
.................... #bit  PORTE_E=PORTE.1 
.................... #bit  PORTE_RW=PORTE.2  
....................  
....................    
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82             
.................... #bit  TRISC_6=TRISC.6  
.................... #bit  TRISC_7=TRISC.7   
....................                             
....................   
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit     
....................  
.................... //   ################   ADC CONVERTER   #################  //  
.................... #byte ADRESH = 0x0FC4     
.................... #byte ADRESL = 0x0FC3  
.................... #byte ADCON0 = 0x0FC2  
.................... #bit  ADON   = ADCON0.0 
.................... #bit  GODONE = ADCON0.1  
.................... #byte ADCON1 = 0x0FC1 
.................... #bit  PCFG0  = ADCON1.0    
.................... #bit  PCFG1  = ADCON1.1 
.................... #byte ADCON2 = 0x0FC0   
.................... #bit  ADIE   = PIE1.6   
.................... #bit  ADIF   = PIR1.6        
....................  
.................... //   ################   PWM CCP1   #################  //     
.................... #byte PR2     = 0x0FCB 
.................... #byte TMR2    = 0x0FCC                                                 
.................... #byte T2CON   = 0x0FCA  
....................  
.................... #byte CCP1CON = 0x0FBD   
.................... #byte CCPR1H  = 0x0FBF  
.................... #byte CCPR1L  = 0x0FBE  
....................                        
.................... #bit  TMR2ON  = T2CON.2   
.................... #bit  TRISC_2=TRISC.2                       
.................... #bit  PORTC_2=PORTC.2    
....................                                              
.................... //   ################   I2C - SCL/SDA   #################  //    
.................... #bit  SCL_DIR=TRISC.3         // SCL GIRIS DIRECTION                                 
.................... #bit  SDA_DIR=TRISC.4         // SDA GIRIS DIRECTION  
....................                                
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR                        
.................... #byte SSPADD  = 0x0FC8        // VERI HIZIMIZI BELIRLEMEK ICIN KULLANILIR, 8 MHz 100Kbps ICIN 19 OLMALI (8MHZ/4/100Kbps)-1=19 
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
....................                               //             0x2------------------------>8(0x28)                                                                                         
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #byte SSPCON2 = 0x0FC5        // MASTER MODDA KONTROL ILETISIMI SAGLAMAK ICIN KOMUT BITLERI BULUNMAKTADIR. 
.................... #bit  SEN     = SSPCON2.0     // SCL VE SDA PINLERI UZERINDEN START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.        *(SADECE MASTER MODE)       
.................... #bit  RSEN    = SSPCON2.1     // SCL VE SDA PINLERI UZERINDEN TEKRAR START KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE)  
.................... #bit  PEN     = SSPCON2.2     // SCL VE SDA PINLERI UZERINDEN STOP KOMUTU VERIR, SONRASINDA OTOMATIK OLARAK SIFIRLANIR.         *(SADECE MASTER MODE)  
.................... #bit  RCEN    = SSPCON2.3     // READ KOMUTU VERIR BF, BUFFER DOLU MU DIYE KONTRO EDILIR, DOLUYSA SSPBUF'DAKI VERI DOLU OLDUGU ANLASILIR VE OKUMA ISLEMI TAMAMLANIR. *(SADECE MASTER MODE)  
.................... #bit  ACKEN   = SSPCON2.4     // SCL VE SDA PINLERI UZERINDEN ACKNOWLEDGE KOMUTU VERIR,VERININ GELIP GELMEDIGINI KONTROL EDER, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)   
.................... #bit  ACKDT   = SSPCON2.5     // SCL VE SDA PINLERI UZERINDEN ACK KOMUTU VERIR,1 ise ACK, 0 ise NACK, SONRASINDA OTOMATIK OLARAK SIFIRLANIR. *(SADECE MASTER MODE OKUMA)     
.................... #bit  ACKSTAT = SSPCON2.6     // SLAVE'DEN ACK GELIP GELMEDIGININ KONTROLUNU YAPAR.                                             *(SADECE MASTER MODE GONDERME)  
....................  
.................... //   ################   D18B20  #################  //                            
.................... #byte LATC    = 0x0F8B   
.................... #bit  LATC_0  = LATC.0   
.................... #bit  TRISC_0 = TRISC.0   
.................... #bit  PORTC_0 = PORTC.0 
....................  
....................                                                                                                      
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "delayms.h"  
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................                  
....................                
.................... /*Hex Code   LCD Ekran Karsiligi  
....................  Initialize Lcd in 4-bit mode               0x02 
.................... 1   Function Set: 8-bit, 1 Line, 5×7 Dots   0x30   48                                              
.................... 2   Function Set: 8-bit, 2 Line, 5×7 Dots   0x38   56                            
.................... 3   Function Set: 4-bit, 1 Line, 5×7 Dots   0x20   32 
.................... 4   Function Set: 4-bit, 2 Line, 5×7 Dots   0x28   40  
.................... 0F   LCD acik, Imlec acik 
.................... 01   Ekrani Temizle                                 
.................... 02   Satir Basina Dön            
.................... 04   Imleci Sola Kaydir 
.................... 06   Imleci Saga Kaydir 
.................... 05   Ekrani Saga Kaydir 
.................... 07   Ekrani Sola Kaydir 
.................... 0E   Ekran Acik, Imleç Yanip Sonuyor 
.................... 80   Imleci Ilk Satirin Basinda Konumlandir 
.................... C0   Imleci Ikinci Satirin Basinda Konumlandir         
.................... 3C   Ikinci Satiri Etkinlestir                                                     
.................... 08   Ekran Kapali, Imleç Kapali              
.................... OC   Ekran Acik, Imlec Kapali*/   
....................                                             
.................... uchar_t strLCD[32]; 
.................... uint8_t countLCDChar; 
.................... uchar_t LCDW1SecFlag; 
....................                                          
.................... /*LCD (CHIP: HD44780), COMMAND MODE*/  
.................... void dis_cmd(uchar_t cmdout){  
....................    PORTD=cmdout;      //Send command to lcdport=PORTB 
*
00EA:  MOVFF  4A,F8C
....................    PORTE_RS=0;                   
00EE:  BCF    F84.0
....................    PORTE_E=1;                
00F0:  BSF    F84.1
....................    delayUsFun(1); 
00F2:  MOVLW  01
00F4:  MOVWF  4C
00F6:  RCALL  00DC
....................    PORTE_E=0;                               
00F8:  BCF    F84.1
00FA:  RETURN 0
.................... }                                   
....................  
....................  
....................  
.................... void lcdcmd(uchar_t cmd_value){          
....................    uchar_t cmd_value1;                              
....................    cmd_value1 = (cmd_value & 0xF0);      // Mask lower nibble because RB4-RB7 pins are being used    
*
04E4:  MOVF   48,W
04E6:  ANDLW  F0
04E8:  MOVWF  49
....................    dis_cmd(cmd_value1);                   // Send to LCD 
04EA:  MOVFF  49,4A
04EE:  RCALL  00EA
....................    cmd_value1 = ((cmd_value<<4) & 0xF0);  // Shift 4-bit and mask 
04F0:  SWAPF  48,W
04F2:  MOVWF  00
04F4:  MOVLW  F0
04F6:  ANDWF  00,F
04F8:  MOVF   00,W
04FA:  ANDLW  F0
04FC:  MOVWF  49
....................    dis_cmd(cmd_value1);                   // Send to LCD 
04FE:  MOVFF  49,4A
0502:  RCALL  00EA
0504:  RETURN 0
.................... } 
....................  // 2 lines are active.              
.................... void twoLinesBCDMode(){  
....................    lcdcmd(0x02); 
0506:  MOVLW  02
0508:  MOVWF  48
050A:  RCALL  04E4
050C:  GOTO   0540 (RETURN)
.................... } 
....................                         
.................... // 2 lines are active. BCD MODE 
.................... void LinesActive(){  
....................    lcdcmd(0x28);                
0510:  MOVLW  28
0512:  MOVWF  48
0514:  RCALL  04E4
0516:  GOTO   0542 (RETURN)
.................... }                          
.................... // LCD screen clear.                   
.................... void lcdClear(){ 
....................    lcdcmd(0x01);                   
*
052E:  MOVLW  01
0530:  MOVWF  48
0532:  RCALL  04E4
0534:  GOTO   0548 (RETURN)
.................... }                   
.................... // Go to first line. 
.................... void lcdGoToFirstLine(){  
....................    lcdcmd(0x80); 
*
08C2:  MOVLW  80
08C4:  MOVWF  48
08C6:  RCALL  04E4
08C8:  GOTO   0914 (RETURN)
.................... }                                  
.................... // Go to second line.                        
.................... void lcdGoToSecondLine(){ 
....................    lcdcmd(0xC0); 
08CC:  MOVLW  C0
08CE:  MOVWF  48
08D0:  RCALL  04E4
08D2:  GOTO   091C (RETURN)
.................... }                        
.................... // Shift cursor to right. 
.................... void lcdShiftRight(){   
....................    lcdcmd(0x06);                                                     
*
0524:  MOVLW  06
0526:  MOVWF  48
0528:  RCALL  04E4
052A:  GOTO   0546 (RETURN)
.................... }                                           
.................... // Display on, Cursor on              
.................... void lcdCursorOn(){                  
....................    lcdcmd(0x0E); 
.................... }                                      
.................... //Display off, Cursor off 
.................... void lcdCursorOff(){                                             
....................    lcdcmd(0x0C);                             
*
051A:  MOVLW  0C
051C:  MOVWF  48
051E:  RCALL  04E4
0520:  GOTO   0544 (RETURN)
.................... }                              
....................   
.................... void dis_data(uchar_t dataout) {  
....................    PORTD=dataout;   //Send data to lcdport=PORTB 
*
08D6:  MOVFF  4B,F8C
....................    PORTE_RS=1;                   
08DA:  BSF    F84.0
....................    PORTE_E=1;                          
08DC:  BSF    F84.1
....................    delayUsFun(1); 
08DE:  MOVLW  01
08E0:  MOVWF  4C
08E2:  CALL   00DC
....................    PORTE_E=0;   
08E6:  BCF    F84.1
08E8:  RETURN 0
....................    //PORTD=0x00; 
....................    //while(test_bit(PORTD,7));           
.................... }   
.................... /*DATA MODE*/   
.................... void lcddata(uchar_t text){  
....................    uchar_t data;                                                                 
....................    data=(text & 0xF0);         
08EA:  MOVF   49,W
08EC:  ANDLW  F0
08EE:  MOVWF  4A
....................    dis_data(data);     
08F0:  MOVFF  4A,4B
08F4:  RCALL  08D6
....................    data=((text<<4)&0xF0);      
08F6:  SWAPF  49,W
08F8:  MOVWF  00
08FA:  MOVLW  F0
08FC:  ANDWF  00,F
08FE:  MOVF   00,W
0900:  ANDLW  F0
0902:  MOVWF  4A
....................    dis_data(data);                  
0904:  MOVFF  4A,4B
0908:  RCALL  08D6
090A:  GOTO   093A (RETURN)
.................... }                                
.................... void LCD_String(){  
....................    if(countLCDChar==0)  
090E:  MOVF   39,F
0910:  BNZ   0914
....................       lcdGoToFirstLine(); 
0912:  BRA    08C2
....................    if(countLCDChar==16)   
0914:  MOVF   39,W
0916:  SUBLW  10
0918:  BNZ   091C
....................       lcdGoToSecondLine();    
091A:  BRA    08CC
....................    if(countLCDChar<=31){  
091C:  MOVF   39,W
091E:  SUBLW  1F
0920:  BNC   093E
....................       lcddata(strLCD[countLCDChar]); 
0922:  CLRF   03
0924:  MOVF   39,W
0926:  ADDLW  19
0928:  MOVWF  FE9
092A:  MOVLW  00
092C:  ADDWFC 03,W
092E:  MOVWF  FEA
0930:  MOVFF  FEF,48
0934:  MOVFF  48,49
0938:  BRA    08EA
....................       countLCDChar++;   
093A:  INCF   39,F
....................    }else{    
093C:  BRA    0942
....................       LCDW1SecFlag=0; 
093E:  CLRF   3A
....................       countLCDChar=0; 
0940:  CLRF   39
....................    }                  
0942:  GOTO   0146 (RETURN)
.................... }  
....................  
....................  
.................... void LCD_Custom_Char(uchar_t loc, uchar_t *msg){ 
....................     uchar_t i; 
....................     if(loc<8) 
....................     { 
....................      lcdcmd(0x40 + (loc*8));    /* Command 0x40 and onwards forces the device to point CGRAM address */ 
....................      for(i=0;i<8;i++)          /* Write 8 byte for generation of 1 character */ 
....................         lcddata(msg[i]);       
....................     }                        
.................... } 
....................  
....................                                           
....................  
....................       
....................  
.................... #include "delayms.c" 
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t; 
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;   
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs){  // Delay function - generates a delay of specified msecs 
....................    uint16_t i; 
....................    uint8_t j;  
....................    for(i=0;i<=msecs;i++) 
....................    for(j=0;j<205;j++); /*This count Provide delay of 1 ms for 8MHz Frequency */                              
.................... }        
....................  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
*
00DC:  CLRF   4D
00DE:  MOVF   4D,W
00E0:  SUBWF  4C,W
00E2:  BNC   00E8
00E4:  INCF   4D,F
00E6:  BRA    00DE
....................     }                                
00E8:  RETURN 0
.................... }   
....................  
....................  
.................... #include "1wire.c" 
.................... #include "1wire.h"  
.................... #ifndef ONE_WIRE_H                                  
.................... #define ONE_WIRE_H   
....................  
....................  
....................                               
....................                                                                             
....................       
.................... void onewire_reset();   
.................... void onewire_write(uchar_t);  
.................... uint8_t onewire_read();  
.................... void OneWireHigh();           
.................... void OneWireRelease();  
....................                                                   
.................... uint8_t test_bit(uint8_t, uint8_t);                        
....................  
.................... #endif ONE_WIRE_H 
....................  
.................... #ifndef ONE_WIRE_C 
.................... #define ONE_WIRE_C  
....................      
....................  
.................... #define ONE_WIRE_PIN PIN_C0 
....................                                 
.................... //  LATC_0  = LATC.0        BUSDIR  
.................... //  TRISC_0 = TRISC.0       BUSOUT                   
.................... //  PORTC_0 = PORTC.0       BUSIN  
....................  
.................... /* 
....................  * onewire_reset() 
....................  * Description: Initiates the one wire bus.         
....................  */ 
.................... // OK if just using a single permanently connected device                
....................                                            
.................... void onewire_reset() {  
....................    OneWireRelease();  
*
05A2:  RCALL  0578
....................    delay_us(500);      
05A4:  MOVLW  02
05A6:  MOVWF  4D
05A8:  MOVLW  F8
05AA:  MOVWF  4E
05AC:  RCALL  057E
05AE:  DECFSZ 4D,F
05B0:  BRA    05A8
....................    OneWireHigh();            
05B2:  RCALL  059C
....................    delay_us(500);  
05B4:  MOVLW  02
05B6:  MOVWF  4D
05B8:  MOVLW  F8
05BA:  MOVWF  4E
05BC:  RCALL  057E
05BE:  DECFSZ 4D,F
05C0:  BRA    05B8
05C2:  RETURN 0
.................... }    
....................  
....................                                          
....................  
.................... /*                                
....................  * onewire_write(int8 data) 
....................  * Arguments: a byte of data. 
....................  * Description: writes a byte of data to the device. 
....................  */                                           
.................... void onewire_write(uchar_t data) {  
....................    int8 count; 
....................  
....................     for(count = 0; count < 8; ++count) { 
05C4:  CLRF   4E
05C6:  MOVF   4E,W
05C8:  SUBLW  07
05CA:  BNC   05F2
....................         OneWireRelease(); 
05CC:  RCALL  0578
....................         delay_us(2);                // pull 1-wire low to initiate write time-slot. 
05CE:  BRA    05D0
05D0:  BRA    05D2
....................         if(data & 0x01)  
05D2:  BTFSS  4D.0
05D4:  BRA    05D8
....................           OneWireHigh();      
05D6:  RCALL  059C
....................          
....................          // output_bit(ONE_WIRE_PIN, shift_right(&data, 1, 0)); // set output bit on 1-wire 
....................         delay_us(65);               // wait until end of write slot. 
05D8:  MOVLW  2A
05DA:  MOVWF  00
05DC:  DECFSZ 00,F
05DE:  BRA    05DC
05E0:  BRA    05E2
05E2:  NOP   
....................         OneWireHigh(); // set 1-wire high again, 
05E4:  RCALL  059C
....................         delay_us(2);                // for more than 1us minimum.  
05E6:  BRA    05E8
05E8:  BRA    05EA
....................         data = (data >> 1);  
05EA:  BCF    FD8.0
05EC:  RRCF   4D,F
05EE:  INCF   4E,F
05F0:  BRA    05C6
....................     } 
05F2:  RETURN 0
.................... }                                          
....................                                         
.................... /* 
....................  * onewire_read()         
....................  * Description: reads and returns a byte of data from the device.                                                                  
....................  */                                   
.................... uint8_t onewire_read() {  
05F4:  CLRF   4E
....................     uint8_t count, data=0;                      
....................     for(count = 0; count < 8; ++count) { 
05F6:  CLRF   4D
05F8:  MOVF   4D,W
05FA:  SUBLW  07
05FC:  BNC   0638
....................         OneWireRelease(); 
05FE:  RCALL  0578
....................         delay_us(2);                // pull 1-wire low to initiate read time-slot. 
0600:  BRA    0602
0602:  BRA    0604
....................         OneWireHigh();              // now let 1-wire float high, 
0604:  RCALL  059C
....................         delay_us(4);                // let device state stabilise,  
0606:  MOVLW  02
0608:  MOVWF  00
060A:  DECFSZ 00,F
060C:  BRA    060A
060E:  NOP   
....................         if(PORTC_0)                 //ZATEN RELEASE KONUMUNA TEKRAR BIR AYARLAMAYA GEREK YOK          
0610:  BTFSS  F82.0
0612:  BRA    062A
....................            bit_set(data,count);    
0614:  MOVLW  01
0616:  MOVWF  00
0618:  MOVF   4D,W
061A:  MOVWF  01
061C:  BZ    0626
061E:  BCF    FD8.0
0620:  RLCF   00,F
0622:  DECFSZ 01,F
0624:  BRA    061E
0626:  MOVF   00,W
0628:  IORWF  4E,F
....................         delay_us(120);              // wait until end of read slot. 
062A:  MOVLW  4F
062C:  MOVWF  00
062E:  DECFSZ 00,F
0630:  BRA    062E
0632:  BRA    0634
0634:  INCF   4D,F
0636:  BRA    05F8
....................     }                          
....................     return data;     
0638:  MOVFF  4E,01
063C:  RETURN 0
.................... }                    
....................                   
....................  
.................... void OneWireHigh(){                
....................     PORTC_0 = 1; // Set as output  BUSDIR      
*
059C:  BSF    F82.0
....................     TRISC_0 = 1; // Set high       BUSOUT  
059E:  BSF    F94.0
05A0:  RETURN 0
.................... } 
....................  
.................... void OneWireRelease(){ 
....................     PORTC_0 = 0; // Set as output  BUSDIR 
*
0578:  BCF    F82.0
....................     TRISC_0 = 0; // Set low        BUSOUT 
057A:  BCF    F94.0
057C:  RETURN 0
.................... }        
....................                                                       
.................... uint8_t test_bit(uint8_t valueOfInput, uint8_t bits){  
....................    return ((valueOfInput & (1<<bits)) != 0); 
.................... }                                             
....................                       
.................... #endif /*ONE_WIRE_C*/ 
....................  
.................... #include "ds1820.c" 
.................... #ifndef DS1820_C 
.................... #define DS1820_C   
....................  
.................... #include "1wire.h"  
.................... #ifndef ONE_WIRE_H                                  
.................... #define ONE_WIRE_H   
....................  
....................  
....................                               
....................                                                                             
....................       
.................... void onewire_reset();   
.................... void onewire_write(uchar_t);  
.................... uint8_t onewire_read();  
.................... void OneWireHigh();           
.................... void OneWireRelease();  
....................                                                   
.................... uint8_t test_bit(uint8_t, uint8_t);                        
....................  
.................... #endif ONE_WIRE_H 
....................  
.................... #include "1wire.c"  
.................... #include "1wire.h"  
.................... #ifndef ONE_WIRE_H                                  
.................... #define ONE_WIRE_H   
....................  
....................  
....................                               
....................                                                                             
....................       
.................... void onewire_reset();   
.................... void onewire_write(uchar_t);  
.................... uint8_t onewire_read();  
.................... void OneWireHigh();           
.................... void OneWireRelease();  
....................                                                   
.................... uint8_t test_bit(uint8_t, uint8_t);                        
....................  
.................... #endif ONE_WIRE_H 
....................  
.................... #ifndef ONE_WIRE_C 
.................... #define ONE_WIRE_C  
....................      
....................  
.................... #define ONE_WIRE_PIN PIN_C0 
....................                                 
.................... //  LATC_0  = LATC.0        BUSDIR  
.................... //  TRISC_0 = TRISC.0       BUSOUT                   
.................... //  PORTC_0 = PORTC.0       BUSIN  
....................  
.................... /* 
....................  * onewire_reset() 
....................  * Description: Initiates the one wire bus.         
....................  */ 
.................... // OK if just using a single permanently connected device                
....................                                            
.................... void onewire_reset() {  
....................    OneWireRelease();  
....................    delay_us(500);      
....................    OneWireHigh();            
....................    delay_us(500);  
.................... }    
....................  
....................                                          
....................  
.................... /*                                
....................  * onewire_write(int8 data) 
....................  * Arguments: a byte of data. 
....................  * Description: writes a byte of data to the device. 
....................  */                                           
.................... void onewire_write(uchar_t data) {  
....................    int8 count; 
....................  
....................     for(count = 0; count < 8; ++count) { 
....................         OneWireRelease(); 
....................         delay_us(2);                // pull 1-wire low to initiate write time-slot. 
....................         if(data & 0x01)  
....................           OneWireHigh();      
....................          
....................          // output_bit(ONE_WIRE_PIN, shift_right(&data, 1, 0)); // set output bit on 1-wire 
....................         delay_us(65);               // wait until end of write slot. 
....................         OneWireHigh(); // set 1-wire high again, 
....................         delay_us(2);                // for more than 1us minimum.  
....................         data = (data >> 1);  
....................     } 
.................... }                                          
....................                                         
.................... /* 
....................  * onewire_read()         
....................  * Description: reads and returns a byte of data from the device.                                                                  
....................  */                                   
.................... uint8_t onewire_read() {  
....................     uint8_t count, data=0;                      
....................     for(count = 0; count < 8; ++count) { 
....................         OneWireRelease(); 
....................         delay_us(2);                // pull 1-wire low to initiate read time-slot. 
....................         OneWireHigh();              // now let 1-wire float high, 
....................         delay_us(4);                // let device state stabilise,  
....................         if(PORTC_0)                 //ZATEN RELEASE KONUMUNA TEKRAR BIR AYARLAMAYA GEREK YOK          
....................            bit_set(data,count);    
....................         delay_us(120);              // wait until end of read slot. 
....................     }                          
....................     return data;     
.................... }                    
....................                   
....................  
.................... void OneWireHigh(){                
....................     PORTC_0 = 1; // Set as output  BUSDIR      
....................     TRISC_0 = 1; // Set high       BUSOUT  
.................... } 
....................  
.................... void OneWireRelease(){ 
....................     PORTC_0 = 0; // Set as output  BUSDIR 
....................     TRISC_0 = 0; // Set low        BUSOUT 
.................... }        
....................                                                       
.................... uint8_t test_bit(uint8_t valueOfInput, uint8_t bits){  
....................    return ((valueOfInput & (1<<bits)) != 0); 
.................... }                                             
....................                       
.................... #endif /*ONE_WIRE_C*/ 
....................  
....................  
.................... /*#define Input           1 
.................... #define Output          0 
.................... #define ReadROM         0x33 
.................... #define MatchROM        0x55 
.................... #define SkipROM         0xCC 
.................... #define SearchROM       0xF0 
.................... #define AlarmSearch     0xEC 
.................... #define ConvertT        0x44 
.................... #define ReadScratchpad  0xBE 
.................... #define WriteScratchpad 0x4E 
.................... #define CopyScratchpad  0x48 
.................... #define RecallEE        0xB8                                  
.................... #define ReadPowerSupply 0xB4 
.................... #define DevicesNumber   1 */  
....................  
.................... void ds1820_read();  
.................... void ds1820_configure(uchar_t TH, uchar_t TL, uchar_t config); 
.................... uchar_t TEMPBF[10];   
.................... uchar_t period;   //10s period 
....................    
....................                                     
....................                                                    
.................... /* 
....................  * ds1820_read()              
....................  * Description: reads the ds18x20 device on the 1-wire bus and returns 
....................  *              the temperature                                                   
....................  */ 
....................  
.................... void ds1820_read() {                                        
*
0800:  CLRF   48
....................     uint8_t busy=0, temp1, temp2; 
....................     sint16_t temp3;  
....................                   
....................     //ds1820_configure(0x00, 0x00, 0x00);     //9 bit resolution 
....................  
....................     onewire_reset();                      
0802:  RCALL  05A2
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
0804:  MOVLW  CC
0806:  MOVWF  4D
0808:  RCALL  05C4
....................     onewire_write(0x44);            //Start temperature conversion 
080A:  MOVLW  44
080C:  MOVWF  4D
080E:  RCALL  05C4
....................  
....................     while(busy == 0)                //Wait while busy (bus is low) 
0810:  MOVF   48,F
0812:  BNZ   081C
....................         busy = onewire_read();     
0814:  RCALL  05F4
0816:  MOVFF  01,48
081A:  BRA    0810
....................                    
....................     onewire_reset(); 
081C:  RCALL  05A2
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
081E:  MOVLW  CC
0820:  MOVWF  4D
0822:  RCALL  05C4
....................     onewire_write(0xBE);            //Read scratchpad      
0824:  MOVLW  BE
0826:  MOVWF  4D
0828:  RCALL  05C4
....................      
....................        
....................     temp1 = onewire_read();          
082A:  RCALL  05F4
082C:  MOVFF  01,49
....................     temp2 = onewire_read();  
0830:  RCALL  05F4
0832:  MOVFF  01,4A
....................                          
....................     temp3 = temp2; 
0836:  CLRF   03
0838:  MOVFF  4A,4B
083C:  MOVFF  03,4C
....................     temp3 = temp1 + (temp3 << 8); 
0840:  MOVFF  4B,03
0844:  MOVLW  00
0846:  ADDWF  49,W
0848:  MOVWF  01
084A:  MOVLW  00
084C:  ADDWFC 03,F
084E:  MOVFF  01,4B
0852:  MOVFF  03,4C
....................     temp3 = (sint16_t) temp3 / 16; 
0856:  MOVFF  4C,4E
085A:  MOVFF  4B,4D
085E:  CLRF   50
0860:  MOVLW  10
0862:  MOVWF  4F
0864:  BRA    063E
0866:  MOVFF  02,4C
086A:  MOVFF  01,4B
....................     //result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
....................     sprintf(TEMPBF,"TEMP :%Ld",temp3);  
086E:  CLRF   47
0870:  MOVLW  3B
0872:  MOVWF  46
0874:  MOVLW  D2
0876:  MOVWF  FF6
0878:  MOVLW  00
087A:  MOVWF  FF7
087C:  MOVLW  06
087E:  MOVWF  4D
0880:  BRA    06D0
0882:  MOVLW  10
0884:  MOVWF  FE9
0886:  MOVFF  4C,4E
088A:  MOVFF  4B,4D
088E:  BRA    06F0
....................     memset(strLCD,0,32); 
0890:  CLRF   FEA
0892:  MOVLW  19
0894:  MOVWF  FE9
0896:  CLRF   00
0898:  CLRF   02
089A:  MOVLW  20
089C:  MOVWF  01
089E:  BRA    07E4
....................     memcpy(strLCD,TEMPBF,9);  
08A0:  CLRF   FEA
08A2:  MOVLW  19
08A4:  MOVWF  FE9
08A6:  CLRF   FE2
08A8:  MOVLW  3B
08AA:  MOVWF  FE1
08AC:  MOVLW  09
08AE:  MOVWF  01
08B0:  MOVFF  FE6,FEE
08B4:  DECFSZ 01,F
08B6:  BRA    08B0
....................     period=0;                   
08B8:  CLRF   45
08BA:  RETURN 0
.................... } 
....................      
.................... /* 
....................  * ds1820_configure(int8 TH, int8 LH, int8 config) 
....................  * Description: writes configuration data to the DS18x20 device 
....................  * Arguments: alarm trigger high, alarm trigger low, configuration 
....................  */                                                                                
....................  
.................... void ds1820_configure(int8 TH, int8 TL, int8 config) { 
....................     onewire_reset(); 
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
....................     onewire_write(0x4E);            //Write to scratchpad 
....................     onewire_write(TH); 
....................     onewire_write(TL); 
....................     onewire_write(config); 
.................... } 
....................  
....................  
.................... #endif /*DS1820_C*/                               
....................  
....................                     
....................  
....................                               
....................                                     
.................... //TIMER1 UNION STRUCTURE AND COUNT MS 
.................... tmr1_time_t tmr1_time;  
.................... uint16_t iSayac;  
....................                       
.................... void setupTimerIOSC(void){          
....................    //Setup Osilator 
....................    IRCF2 = 1;   
*
04A8:  BSF    FD3.6
....................    IRCF1 = 1; 
04AA:  BSF    FD3.5
....................    IRCF0 = 1;                    
04AC:  BSF    FD3.4
....................                          
....................    //D ve P portlari cikis olarak ayarlanip sifirlandi. 
....................    TRISB = 0x00;                  
04AE:  CLRF   F93
....................    TRISD = 0x00; 
04B0:  CLRF   F95
....................    TRISE = 0x00;       
04B2:  CLRF   F96
....................    PORTB = 0x00;                                                       
04B4:  CLRF   F81
....................    PORTD = 0x00; 
04B6:  CLRF   F8C
....................    PORTE = 0x00;   
04B8:  CLRF   F84
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
04BA:  CLRF   18
....................  
....................    // Kesmelere izin verildi 
....................    RCON_IPEN = 1;                                               
04BC:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 1; 
04BE:  BSF    FF2.7
....................    INTCON_PEIE = 1;           
04C0:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
04C2:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
04C4:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
04C6:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit 
04C8:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
04CA:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
04CC:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
04CE:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
04D0:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
04D2:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
04D4:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
04D6:  MOVLW  F8
04D8:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.   
04DA:  MOVLW  30
04DC:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit                                            
04DE:  BSF    FCD.0
04E0:  GOTO   0130 (RETURN)
.................... }           
....................                       
.................... void printOn2x16(){                   
....................    delayUsFun(40);                                                                                                                                       
*
0538:  MOVLW  28
053A:  MOVWF  4C
053C:  RCALL  00DC
....................    twoLinesBCDMode();    
053E:  BRA    0506
....................    LinesActive();   
0540:  BRA    0510
....................    lcdCursorOff(); 
0542:  BRA    051A
....................    lcdShiftRight();                      
0544:  BRA    0524
....................    lcdClear();                                                    
0546:  BRA    052E
....................    memcpy(strLCD, "INFORMELEKTRONIKAR-GE    STAJYER", 32);  
0548:  CLRF   FEA
054A:  MOVLW  19
054C:  MOVWF  FE9
054E:  MOVFF  FF2,48
0552:  BCF    FF2.7
0554:  MOVLW  20
0556:  MOVWF  01
0558:  CLRF   FF7
055A:  MOVLW  00
055C:  RCALL  0096
055E:  TBLRD*-
0560:  TBLRD*+
0562:  MOVFF  FF5,FEE
0566:  DECFSZ 01,F
0568:  BRA    0560
056A:  BTFSC  48.7
056C:  BSF    FF2.7
....................    countLCDChar=0;    
056E:  CLRF   39
....................    LCDW1SecFlag=1; 
0570:  MOVLW  01
0572:  MOVWF  3A
0574:  GOTO   0132 (RETURN)
....................    // LCD_Custom_CHAR(7, legrandLCDCharacter); 
....................    //LCD_Custom_CHAR(6, stickManLCDCharacter);                                
.................... }                           
....................                                 
.................... void I2C_Init() {     
....................    SCL_DIR = 1;     //Set as a digital input 
....................    SDA_DIR = 1;     //Set as a digital input 
....................    SSPADD  = 19;  
....................    SSPCON1 = 0x28;  // enable I2C pins SCL and SDA for serial communication 
....................    //SSPCON2 = 0x00;   
....................    SSPSTAT = 0x80;  //slew rate disabled for high speed control       
.................... }                                               
....................  
....................  
.................... #INT_TIMER1                                                            
.................... void timer1_interrupt(){  
....................    TMR1H = 0xF8; //Tasma saayci| 
*
0446:  MOVLW  F8
0448:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.   
044A:  MOVLW  30
044C:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor. 
044E:  BCF    F9E.0
....................    iSayac++; 
0450:  INCF   16,F
0452:  BTFSC  FD8.2
0454:  INCF   17,F
....................  
....................    if (iSayac % 2 == 0)  //2ms   
0456:  MOVF   16,W
0458:  ANDLW  01
045A:  MOVWF  57
045C:  CLRF   58
045E:  MOVF   57,F
0460:  BNZ   0468
0462:  MOVF   58,F
0464:  BNZ   0468
....................       tmr1_time.tmr1_flags._2ms = true;   
0466:  BSF    18.0
....................    if (iSayac % 50 == 0)//50ms 
0468:  MOVFF  17,58
046C:  MOVFF  16,57
0470:  CLRF   5A
0472:  MOVLW  32
0474:  MOVWF  59
0476:  BRA    0402
0478:  MOVFF  00,57
047C:  MOVFF  03,58
0480:  MOVF   57,F
0482:  BNZ   048A
0484:  MOVF   58,F
0486:  BNZ   048A
....................       tmr1_time.tmr1_flags._20ms = true; 
0488:  BSF    18.1
....................    if(iSayac >= 1000){    //1 Second   
048A:  MOVF   17,W
048C:  SUBLW  02
048E:  BC    04A2
0490:  XORLW  FF
0492:  BNZ   049A
0494:  MOVF   16,W
0496:  SUBLW  E7
0498:  BC    04A2
....................       tmr1_time.tmr1_flags._1000ms = true;  
049A:  BSF    18.6
....................       iSayac = 0;              
049C:  CLRF   17
049E:  CLRF   16
....................       period++; 
04A0:  INCF   45,F
....................    }                                         
.................... }                              
....................                                    
04A2:  BCF    F9E.0
04A4:  GOTO   0054
.................... #ORG 0x0100,0x0400                                                                     
.................... void main(){           
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  MOVLW  70
0108:  MOVWF  FD3
010A:  MOVF   FD3,W
010C:  BCF    FB8.3
010E:  MOVLW  0C
0110:  MOVWF  FAF
0112:  MOVLW  A2
0114:  MOVWF  FAC
0116:  MOVLW  90
0118:  MOVWF  FAB
011A:  NOP   
011C:  NOP   
011E:  CLRF   47
0120:  CLRF   46
0122:  MOVF   FC1,W
0124:  ANDLW  C0
0126:  IORLW  0F
0128:  MOVWF  FC1
012A:  MOVLW  07
012C:  MOVWF  FB4
....................    setupTimerIOSC();                                                      
012E:  BRA    04A8
....................    printOn2x16();                                                     
0130:  BRA    0538
....................    ds1820_read();   
0132:  RCALL  0800
....................    period=10;  
0134:  MOVLW  0A
0136:  MOVWF  45
....................    //I2C_Init();  
....................    //DS1307_Init();        
....................    while (TRUE){                         
....................      WDTreset();{  
0138:  BRA    08BC
....................    }          
....................      if(tmr1_time.tmr1_flags._2ms){ 
013A:  BTFSS  18.0
013C:  BRA    0146
....................         tmr1_time.tmr1_flags._2ms = false;                                                                                               
013E:  BCF    18.0
....................         if(LCDW1SecFlag){      
0140:  MOVF   3A,F
0142:  BZ    0146
....................            LCD_String();                               
0144:  BRA    090E
....................         }            
....................      }                  
....................      if(tmr1_time.tmr1_flags._20ms){ 
0146:  BTFSS  18.1
0148:  BRA    014C
....................         tmr1_time.tmr1_flags._20ms = false;      
014A:  BCF    18.1
....................         //ds1307_run(27,7,23,2,14,59,10); 
....................      }                                         
....................      if(tmr1_time.tmr1_flags._1000ms){                       
014C:  BTFSS  18.6
014E:  BRA    0160
....................         tmr1_time.tmr1_flags._1000ms = false;                                  
0150:  BCF    18.6
....................         PORTB_7=~PORTB_7;   
0152:  BTG    F81.7
....................         if(period>=1) 
0154:  MOVF   45,W
0156:  SUBLW  00
0158:  BC    015C
....................            ds1820_read(); 
015A:  RCALL  0800
....................         LCDW1SecFlag=1; 
015C:  MOVLW  01
015E:  MOVWF  3A
....................      }                  
0160:  BRA    0138
....................   }   
.................... }  
....................  
0162:  SLEEP 
.................... void WDTreset(void){          
....................    #asm                   
*
08BC:  CLRWDT
....................    CLRWDT                           
....................    #endasm                                  
08BE:  GOTO   013A (RETURN)
.................... }            
....................                                         

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 061E   PUT BROWNOUT BORV21 NOWDT WDT8
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
