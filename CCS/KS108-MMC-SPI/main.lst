CCS PCH C Compiler, Version 5.015, 5967               21-Aug-23 08:06

               Filename:   C:\18F4520\CCS\KS108-MMC-SPI\main.lst

               ROM used:   3654 bytes (11%)
                           Largest free fragment is 28676
               RAM used:   542 (35%) at main() level
                           579 (38%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   056C
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <18F4520.h>   //Kullanilan mikrodenetleyicinin surucusu derleyici uzerinde kaynak dosyasina tanimlanir.  
.................... //////////// Standard Header file for the PIC18F4520 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4520 
0096:  CLRF   01
0098:  CLRF   02
009A:  CLRF   00
009C:  CLRF   03
009E:  MOVLB  2
00A0:  MOVF   x41,W
00A2:  BNZ   00A8
00A4:  MOVF   x40,W
00A6:  BZ    00D8
00A8:  MOVLW  10
00AA:  MOVWF  x42
00AC:  BCF    FD8.0
00AE:  RLCF   x3E,F
00B0:  RLCF   x3F,F
00B2:  RLCF   00,F
00B4:  RLCF   03,F
00B6:  MOVF   x41,W
00B8:  SUBWF  03,W
00BA:  BNZ   00C0
00BC:  MOVF   x40,W
00BE:  SUBWF  00,W
00C0:  BNC   00D0
00C2:  MOVF   x40,W
00C4:  SUBWF  00,F
00C6:  BTFSS  FD8.0
00C8:  DECF   03,F
00CA:  MOVF   x41,W
00CC:  SUBWF  03,F
00CE:  BSF    FD8.0
00D0:  RLCF   01,F
00D2:  RLCF   02,F
00D4:  DECFSZ x42,F
00D6:  BRA    00AC
00D8:  MOVLB  0
00DA:  GOTO   05A2 (RETURN)
*
0302:  MOVFF  FF2,0D
0306:  BCF    FF2.7
0308:  ADDLW  1A
030A:  MOVWF  FF6
030C:  MOVLW  03
030E:  ADDWFC FF7,F
0310:  TBLRD*+
0312:  MOVF   FF5,W
0314:  BTFSC  0D.7
0316:  BSF    FF2.7
0318:  RETURN 0
031A:  DATA 00,00
031C:  DATA 00,00
031E:  DATA 00,00
0320:  DATA 00,00
0322:  DATA 5F,00
0324:  DATA 00,00
0326:  DATA 00,07
0328:  DATA 00,07
032A:  DATA 00,00
032C:  DATA 14,7F
032E:  DATA 14,7F
0330:  DATA 14,00
0332:  DATA 24,2A
0334:  DATA 7F,2A
0336:  DATA 12,00
0338:  DATA 23,13
033A:  DATA 08,64
033C:  DATA 62,00
033E:  DATA 36,49
0340:  DATA 55,22
0342:  DATA 50,00
0344:  DATA 00,05
0346:  DATA 03,00
0348:  DATA 00,00
034A:  DATA 00,1C
034C:  DATA 22,41
034E:  DATA 00,00
0350:  DATA 00,41
0352:  DATA 22,1C
0354:  DATA 00,00
0356:  DATA 08,2A
0358:  DATA 1C,2A
035A:  DATA 08,00
035C:  DATA 08,08
035E:  DATA 3E,08
0360:  DATA 08,00
0362:  DATA 00,50
0364:  DATA 30,00
0366:  DATA 00,00
0368:  DATA 08,08
036A:  DATA 08,08
036C:  DATA 08,00
036E:  DATA 00,60
0370:  DATA 60,00
0372:  DATA 00,00
0374:  DATA 20,10
0376:  DATA 08,04
0378:  DATA 02,00
037A:  DATA 3E,51
037C:  DATA 49,45
037E:  DATA 3E,00
0380:  DATA 00,42
0382:  DATA 7F,40
0384:  DATA 00,00
0386:  DATA 42,61
0388:  DATA 51,49
038A:  DATA 46,00
038C:  DATA 21,41
038E:  DATA 45,4B
0390:  DATA 31,00
0392:  DATA 18,14
0394:  DATA 12,7F
0396:  DATA 10,00
0398:  DATA 27,45
039A:  DATA 45,45
039C:  DATA 39,00
039E:  DATA 3C,4A
03A0:  DATA 49,49
03A2:  DATA 30,00
03A4:  DATA 01,71
03A6:  DATA 09,05
03A8:  DATA 03,00
03AA:  DATA 36,49
03AC:  DATA 49,49
03AE:  DATA 36,00
03B0:  DATA 06,49
03B2:  DATA 49,29
03B4:  DATA 1E,00
03B6:  DATA 00,36
03B8:  DATA 36,00
03BA:  DATA 00,00
03BC:  DATA 00,56
03BE:  DATA 36,00
03C0:  DATA 00,00
03C2:  DATA 00,08
03C4:  DATA 14,22
03C6:  DATA 41,00
03C8:  DATA 14,14
03CA:  DATA 14,14
03CC:  DATA 14,00
03CE:  DATA 41,22
03D0:  DATA 14,08
03D2:  DATA 00,00
03D4:  DATA 02,01
03D6:  DATA 51,09
03D8:  DATA 06,00
03DA:  DATA 32,49
03DC:  DATA 79,41
03DE:  DATA 3E,00
03E0:  DATA 7E,11
03E2:  DATA 11,11
03E4:  DATA 7E,00
03E6:  DATA 7F,49
03E8:  DATA 49,49
03EA:  DATA 36,00
03EC:  DATA 3E,41
03EE:  DATA 41,41
03F0:  DATA 22,00
03F2:  DATA 7F,41
03F4:  DATA 41,22
03F6:  DATA 1C,00
03F8:  DATA 7F,49
03FA:  DATA 49,49
03FC:  DATA 41,00
03FE:  DATA 7F,09
0400:  DATA 09,01
0402:  DATA 01,00
0404:  DATA 3E,41
0406:  DATA 41,51
0408:  DATA 32,00
040A:  DATA 7F,08
040C:  DATA 08,08
040E:  DATA 7F,00
0410:  DATA 00,41
0412:  DATA 7F,41
0414:  DATA 00,00
0416:  DATA 20,40
0418:  DATA 41,3F
041A:  DATA 01,00
041C:  DATA 7F,08
041E:  DATA 14,22
0420:  DATA 41,00
0422:  DATA 7F,40
0424:  DATA 40,40
0426:  DATA 40,00
0428:  DATA 7F,02
042A:  DATA 04,02
042C:  DATA 7F,00
042E:  DATA 7F,04
0430:  DATA 08,10
0432:  DATA 7F,00
0434:  DATA 3E,41
0436:  DATA 41,41
0438:  DATA 3E,00
043A:  DATA 7F,09
043C:  DATA 09,09
043E:  DATA 06,00
0440:  DATA 3E,41
0442:  DATA 51,21
0444:  DATA 5E,00
0446:  DATA 7F,09
0448:  DATA 19,29
044A:  DATA 46,00
044C:  DATA 46,49
044E:  DATA 49,49
0450:  DATA 31,00
0452:  DATA 01,01
0454:  DATA 7F,01
0456:  DATA 01,00
0458:  DATA 3F,40
045A:  DATA 40,40
045C:  DATA 3F,00
045E:  DATA 1F,20
0460:  DATA 40,20
0462:  DATA 1F,00
0464:  DATA 7F,20
0466:  DATA 18,20
0468:  DATA 7F,00
046A:  DATA 63,14
046C:  DATA 08,14
046E:  DATA 63,00
0470:  DATA 03,04
0472:  DATA 78,04
0474:  DATA 03,00
0476:  DATA 61,51
0478:  DATA 49,45
047A:  DATA 43,00
047C:  DATA 00,00
047E:  DATA 7F,41
0480:  DATA 41,00
0482:  DATA 02,04
0484:  DATA 08,10
0486:  DATA 20,00
0488:  DATA 41,41
048A:  DATA 7F,00
048C:  DATA 00,00
048E:  DATA 04,02
0490:  DATA 01,02
0492:  DATA 04,00
0494:  DATA 40,40
0496:  DATA 40,40
0498:  DATA 40,00
049A:  DATA 00,01
049C:  DATA 02,04
049E:  DATA 00,00
04A0:  DATA 20,54
04A2:  DATA 54,54
04A4:  DATA 78,00
04A6:  DATA 7F,48
04A8:  DATA 44,44
04AA:  DATA 38,00
04AC:  DATA 38,44
04AE:  DATA 44,44
04B0:  DATA 20,00
04B2:  DATA 38,44
04B4:  DATA 44,48
04B6:  DATA 7F,00
04B8:  DATA 38,54
04BA:  DATA 54,54
04BC:  DATA 18,00
04BE:  DATA 08,7E
04C0:  DATA 09,01
04C2:  DATA 02,00
04C4:  DATA 08,14
04C6:  DATA 54,54
04C8:  DATA 3C,00
04CA:  DATA 7F,08
04CC:  DATA 04,04
04CE:  DATA 78,00
04D0:  DATA 00,44
04D2:  DATA 7D,40
04D4:  DATA 00,00
04D6:  DATA 20,40
04D8:  DATA 44,3D
04DA:  DATA 00,00
04DC:  DATA 00,7F
04DE:  DATA 10,28
04E0:  DATA 44,00
04E2:  DATA 00,41
04E4:  DATA 7F,40
04E6:  DATA 00,00
04E8:  DATA 7C,04
04EA:  DATA 18,04
04EC:  DATA 78,00
04EE:  DATA 7C,08
04F0:  DATA 04,04
04F2:  DATA 78,00
04F4:  DATA 38,44
04F6:  DATA 44,44
04F8:  DATA 38,00
04FA:  DATA 7C,14
04FC:  DATA 14,14
04FE:  DATA 08,00
0500:  DATA 08,14
0502:  DATA 14,18
0504:  DATA 7C,00
0506:  DATA 7C,08
0508:  DATA 04,04
050A:  DATA 08,00
050C:  DATA 48,54
050E:  DATA 54,54
0510:  DATA 20,00
0512:  DATA 04,3F
0514:  DATA 44,40
0516:  DATA 20,00
0518:  DATA 3C,40
051A:  DATA 40,20
051C:  DATA 7C,00
051E:  DATA 1C,20
0520:  DATA 40,20
0522:  DATA 1C,00
0524:  DATA 3C,40
0526:  DATA 30,40
0528:  DATA 3C,00
052A:  DATA 44,28
052C:  DATA 10,28
052E:  DATA 44,00
0530:  DATA 0C,50
0532:  DATA 50,50
0534:  DATA 3C,00
0536:  DATA 44,64
0538:  DATA 54,4C
053A:  DATA 44,00
053C:  DATA 00,08
053E:  DATA 36,41
0540:  DATA 00,00
0542:  DATA 00,00
0544:  DATA 7F,00
0546:  DATA 00,00
0548:  DATA 00,41
054A:  DATA 36,08
054C:  DATA 00,00
054E:  DATA 08,08
0550:  DATA 2A,1C
0552:  DATA 08,00
0554:  DATA 08,1C
0556:  DATA 2A,08
0558:  DATA 08,00
055A:  DATA 48,41
055C:  DATA 54,41
055E:  DATA 20,53
0560:  DATA 45,43
0562:  DATA 54,4F
0564:  DATA 52,3A
0566:  DATA 20,25
0568:  DATA 4C,75
056A:  DATA 00,00
*
05D4:  DATA 43,61
05D6:  DATA 6C,69
05D8:  DATA 73,74
05DA:  DATA 69,2E
05DC:  DATA 2E,00
*
09F0:  TBLRD*+
09F2:  MOVF   FF5,F
09F4:  BZ    0A10
09F6:  MOVFF  FF6,21E
09FA:  MOVFF  FF7,21F
09FE:  MOVF   FF5,W
0A00:  BTFSS  F9E.4
0A02:  BRA    0A00
0A04:  MOVWF  FAD
0A06:  MOVFF  21E,FF6
0A0A:  MOVFF  21F,FF7
0A0E:  BRA    09F0
0A10:  GOTO   0A26 (RETURN)
*
0A32:  TSTFSZ 01
0A34:  BRA    0A3C
0A36:  TSTFSZ 02
0A38:  BRA    0A3E
0A3A:  BRA    0A4A
0A3C:  INCF   02,F
0A3E:  MOVFF  00,FEE
0A42:  DECFSZ 01,F
0A44:  BRA    0A3E
0A46:  DECFSZ 02,F
0A48:  BRA    0A3E
0A4A:  GOTO   0C94 (RETURN)
*
0BA2:  TBLRD*+
0BA4:  MOVFF  FF6,22A
0BA8:  MOVFF  FF7,22B
0BAC:  MOVF   FF5,W
0BAE:  BTFSS  F9E.4
0BB0:  BRA    0BAE
0BB2:  MOVWF  FAD
0BB4:  MOVFF  22A,FF6
0BB8:  MOVFF  22B,FF7
0BBC:  MOVLB  2
0BBE:  DECFSZ x29,F
0BC0:  BRA    0BC4
0BC2:  BRA    0BC8
0BC4:  MOVLB  0
0BC6:  BRA    0BA2
0BC8:  MOVLB  0
0BCA:  GOTO   0CFA (RETURN)
0BCE:  MOVFF  FEA,231
0BD2:  MOVFF  FE9,230
0BD6:  MOVLB  2
0BD8:  SWAPF  x2A,W
0BDA:  IORLW  F0
0BDC:  MOVWF  x2C
0BDE:  ADDWF  x2C,F
0BE0:  ADDLW  E2
0BE2:  MOVWF  x2D
0BE4:  ADDLW  32
0BE6:  MOVWF  x2F
0BE8:  MOVF   x2A,W
0BEA:  ANDLW  0F
0BEC:  ADDWF  x2D,F
0BEE:  ADDWF  x2D,F
0BF0:  ADDWF  x2F,F
0BF2:  ADDLW  E9
0BF4:  MOVWF  x2E
0BF6:  ADDWF  x2E,F
0BF8:  ADDWF  x2E,F
0BFA:  SWAPF  x29,W
0BFC:  ANDLW  0F
0BFE:  ADDWF  x2E,F
0C00:  ADDWF  x2F,F
0C02:  RLCF   x2E,F
0C04:  RLCF   x2F,F
0C06:  COMF   x2F,F
0C08:  RLCF   x2F,F
0C0A:  MOVF   x29,W
0C0C:  ANDLW  0F
0C0E:  ADDWF  x2F,F
0C10:  RLCF   x2C,F
0C12:  MOVLW  07
0C14:  MOVWF  x2B
0C16:  MOVLW  0A
0C18:  DECF   x2E,F
0C1A:  ADDWF  x2F,F
0C1C:  BNC   0C18
0C1E:  DECF   x2D,F
0C20:  ADDWF  x2E,F
0C22:  BNC   0C1E
0C24:  DECF   x2C,F
0C26:  ADDWF  x2D,F
0C28:  BNC   0C24
0C2A:  DECF   x2B,F
0C2C:  ADDWF  x2C,F
0C2E:  BNC   0C2A
0C30:  MOVLW  02
0C32:  MOVWF  FEA
0C34:  MOVLW  2B
0C36:  MOVWF  FE9
0C38:  MOVLW  07
0C3A:  ANDWF  x30,W
0C3C:  BCF    x30.6
0C3E:  ADDWF  FE9,F
0C40:  MOVLW  00
0C42:  ADDWFC FEA,F
0C44:  MOVF   FE9,W
0C46:  SUBLW  2F
0C48:  BNZ   0C52
0C4A:  MOVF   FEA,W
0C4C:  SUBLW  02
0C4E:  BNZ   0C52
0C50:  BSF    x30.6
0C52:  MOVF   FEF,W
0C54:  MOVWF  00
0C56:  BNZ   0C68
0C58:  BTFSC  x30.6
0C5A:  BRA    0C68
0C5C:  BTFSC  x30.4
0C5E:  BRA    0C78
0C60:  BTFSC  x30.3
0C62:  BRA    0C68
0C64:  MOVLW  20
0C66:  BRA    0C6E
0C68:  BSF    x30.3
0C6A:  BCF    x30.4
0C6C:  MOVLW  30
0C6E:  ADDWF  00,F
0C70:  MOVF   00,W
0C72:  BTFSS  F9E.4
0C74:  BRA    0C72
0C76:  MOVWF  FAD
0C78:  MOVF   FEE,W
0C7A:  BTFSS  x30.6
0C7C:  BRA    0C44
0C7E:  MOVLB  0
0C80:  GOTO   0D08 (RETURN)
*
0E96:  MOVLB  2
0E98:  MOVF   x32,W
0E9A:  MULWF  x34
0E9C:  MOVFF  FF3,01
0EA0:  MOVFF  FF4,00
0EA4:  MULWF  x35
0EA6:  MOVF   FF3,W
0EA8:  ADDWF  00,F
0EAA:  MOVF   x33,W
0EAC:  MULWF  x34
0EAE:  MOVF   FF3,W
0EB0:  ADDWFC 00,W
0EB2:  MOVWF  02
0EB4:  MOVLB  0
0EB6:  GOTO   0ED4 (RETURN)
....................  
.................... #list 
....................  
....................   
....................  
.................... /*FUSES: cihaza bagli cesitli opsiyonlari ayarlamak icin kullanilir. Mevcut ozellikleri en ustte belirtilir.  
....................        Konfigurasyon bileri vardir, bu komut ile mikrodenetleyicinin konfigurasyon pinleri ayarlanr. 
....................   Yaygin kullanilan cihaz secenekleri: 
....................       路 LP, XT, HS, RC :LP dusuk guclu kristal osilator, XT klasik kristal osilator, HS yuksek hizli kristal osilator, RC Direnc / Kondansator osilator 
....................       路 WDT, NOWDT  :Programin olasi kilitlenmelerde resetlenmesini salar. WDT dersek bu mod aktif, NOWDT dersek bu mod pasiftir.      
....................       路 PROTECT, NOPROTECT :Kod koruma, mikrokontrollerin iine ykleyecegin kodlar kopyalananaz demek, NOPROTECT ise kodlar geriye okunup kopyalanabilir demektir.  
....................       路 PUT, NOPUT (Power Up Timer) : NOPUT, zamanlayicilar kapali demek, yani timer olarak gecen zaman dongulerini kullanmayacagini belirtirsin. 
....................       路 BROWNOUT, NOBROWNOUT:Dusuk gerilimle program reset, bu ozellik gerilim seviyesi belli bir degerin altina dustugunde, mikrokontrollerin reset atmasidir, 
....................           genelde NOBROWNOUT modunda tutulur, eyer BROWNOUT olarak kullanilirsa, ani gerilim dalgalanmalarinda sistem surrekli resetlenir. 
....................       路 INTRC: Internal, dahili osilatoru kullan anlamina gelir.     
....................       路 NOMCLR: Master Clear functionality, MCLR girisi PIC'i resetlemek icin kullanilir. Bu fuse yoksa #FUSE MCLR ve MCLR pini 10k ile 5V a  
.................... Tum #FUSES ozelliklerini kapatmak icin " #FUSES none" kullanilir.                               
.................... */                                     
....................  
.................... #FUSES NOWDT, WDT8, NOLVP,NOCPD, NOWRT, NOMCLR, IESO, INTRC 
.................... #use delay (internal=8MHz)                     
*
0610:  MOVLW  02
0612:  MOVWF  FEA
0614:  MOVLW  21
0616:  MOVWF  FE9
0618:  MOVF   FEF,W
061A:  BZ    0636
061C:  MOVLW  02
061E:  MOVWF  01
0620:  CLRF   00
0622:  DECFSZ 00,F
0624:  BRA    0622
0626:  DECFSZ 01,F
0628:  BRA    0620
062A:  MOVLW  97
062C:  MOVWF  00
062E:  DECFSZ 00,F
0630:  BRA    062E
0632:  DECFSZ FEF,F
0634:  BRA    061C
0636:  RETURN 0
.................... #use rs232(baud=57600, xmit=PIN_C6,rcv=PIN_C7)  
.................... #define   SDCARD_SPI_HW   
.................... // SD Card module connections 
.................... #define   SDCARD_PIN_SDI     PIN_C4 
.................... #define   SDCARD_PIN_SDO     PIN_C5 
.................... #define   SDCARD_PIN_SCL     PIN_C3 
.................... #define   SDCARD_PIN_SELECT  PIN_C2 
.................... // End of SD card module connections   
....................                   
.................... #include "main.h"                                                                 
.................... #ifndef MAIN_H      
.................... #define MAIN_H  
.................... #define DELAY 500  
....................   
.................... //Display Video Animation 
.................... void displayVideoAnimation(); 
....................  
.................... // SD CARD MANAGMENTS  
.................... void readSectorData();               
.................... void initMMC();  
....................      
....................  
.................... // INITILAZITIONS 
.................... void timer1_interrupt(); 
.................... void setupTimerIOSC(void); 
.................... void WDTreset(void);   
....................                      
.................... #endif //MAIN_H                                 
....................  
....................                                                                                                                
....................                                
....................  
.................... #include "definitions.h"    
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;   
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;    
....................  
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t;       
....................        
.................... typedef signed int16 int16_t; 
....................      
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
....................  
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h"                                 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
.................... #include "ucregisters.h"    
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                                                        
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1           
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81   
.................... #bit  PORTB_0=PORTB.0   
.................... #bit  PORTB_7=PORTB.7    
....................  
.................... // LCD PINS 
.................... //#byte TRISD = 0x0F95                      
.................... //#byte PORTD = 0x0F8C                      
.................... //#bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96      
.................... #byte PORTE = 0x0F84                        
....................  
....................    
.................... //#byte TRISC = 0x0F94  
.................... //#byte PORTC = 0x0F82             
.................... //#bit  TRISC_6=TRISC.6  
.................... //#bit  TRISC_7=TRISC.7   
....................                             
....................                       
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit      
....................  
.................... // ############# GLCD 128x64 ################ 
.................... //DATA 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F83   
.................... #byte LCD_data = 0x0F8C   
.................... //CONTROL 
.................... #byte TRISBB = 0x0F93      
.................... #byte PORTBB = 0x0F81   
.................... #byte LATBB  = 0x0F8A  
....................                                
.................... #bit   CS1 = LATBB.0   
.................... #bit   CS2 = LATBB.1   
.................... #bit   RS  = LATBB.2   
.................... #bit   RW  = LATBB.3  
.................... #bit   EN  = LATBB.4              
.................... #bit   RST = LATBB.5                       
....................                        
.................... //################## MMC/CARD - SPI ################### 
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82         
.................... #byte LATC  = 0x0F8B                            
....................   
.................... //SPI                         
.................... #bit   CS   = PORTC.2       
.................... #bit   CLK  = PORTC.3  
.................... #bit   SDI  = PORTC.4    
.................... #bit   SDO  = PORTC.5     
.................... #bit   CS_DIR   = TRISC.2   
.................... #bit   CLK_DIR  = TRISC.3        
.................... #bit   SDI_DIR  = TRISC.4   
.................... #bit   SDO_DIR  = TRISC.5   
....................                            
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR   
....................  
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
.................... #bit  CKE     = SSPSTAT.6   
.................... #bit  SMP     = SSPSTAT.7    
....................  
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #bit  SSPM0     = SSPCON1.0    
.................... #bit  SSPM1     = SSPCON1.1   
.................... #bit  SSPM2     = SSPCON1.2   
.................... #bit  SSPM3     = SSPCON1.3   
.................... #bit  CKP       = SSPCON1.4   
.................... #bit  SSPEN     = SSPCON1.5  
....................  
....................                 
....................                       
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "init.h" 
.................... #ifndef INIT_H 
.................... #define INIT_H       
....................  
.................... extern uint16_t iSayac;  
.................... typedef union{   
....................    uint8_t  all;      // Type  kayitciya erismek icin 
....................    struct{ 
....................       uint8_t _2ms    : 1;  //bit:0, 2ms  
....................       uint8_t _20ms   : 1;  //bit:1, 20ms  
....................       uint8_t _50ms   : 1;  //bit:2, 50ms  
....................       uint8_t _100ms  : 1;  //bit:3, 100ms     
....................       uint8_t _200ms  : 1;  //bit:4, 200ms                   
....................       uint8_t _500ms  : 1;  //bit:5, 500ms  
....................       uint8_t _1000ms : 1;  //bit:6, 1000ms  
....................       uint8_t _500us  : 1;  //bit:7, 500us 
....................    }tmr1_flags;                     
.................... }tmr1_time_t;    
.................... extern tmr1_time_t tmr1_time;     
....................  
....................  
....................  
....................  
....................                                                 
.................... #endif //INIT_H                               
....................  
....................  
.................... #include "delayms.c"    
....................  
.................... #include "definitions.h"  
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;   
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;    
....................  
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t;       
....................        
.................... typedef signed int16 int16_t; 
....................      
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
....................  
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "delayms.h" 
.................... #ifndef DELAYMS_H   
.................... #define DELAYMS_H    
....................  
.................... void delayMsFun(uint16_t);  
.................... void delayUsFun(uint8_t us); 
....................  
.................... #endif //DELAYMS_H   
....................  
....................    
.................... void delayMsFun(uint16_t msecs){  // Delay function - generates a delay of specified msecs 
....................    uint16_t i; 
....................    uint8_t j;  
....................    for(i=0;i<=msecs;i++) 
....................    for(j=0;j<205;j++); /*This count Provide delay of 1 ms for 8MHz Frequency */                              
.................... }        
....................  
.................... void delayUsFun(uint8_t us)  // Delay function - generates a delay of specified msecs 
.................... {   uint8_t i; 
....................     for(i=0;i<=us;i++){               
....................     }                                
.................... }   
....................  
....................  
.................... #include "sdcard.c"   
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////    MMC/SD card driver for CCS PIC C compiler (August 2017)      //// 
.................... ////                                                                 //// 
.................... ////                        --User Functions--                       //// 
.................... ////                                                                 //// 
.................... ////  sdcard_init();                                                 //// 
.................... ////   Initializes the media. Returns 0 if OK, non-zero if error.    //// 
.................... ////                                                                 //// 
.................... ////  sdcard_read_byte(int32 addr, int8* data);                      //// 
.................... ////   Reads a byte from the MMC/SD card at address 'addr', saves to //// 
.................... ////   pointer 'data'. Returns 0 if OK, non-zero if error.           //// 
.................... ////                                                                 //// 
.................... ////  sdcard_read_sector(int32 sector_number, int8* data);           //// 
.................... ////   Reads an entire sector (block) from the SD/MMC. Returns 0 if  //// 
.................... ////   OK, non-zero if error                                         //// 
.................... ////                                                                 //// 
.................... ////  sdcard_read_data(int32 addr, int16 size, int8* data);          //// 
.................... ////   Reads data of size 'size' bytes from the MMC/SD card starting //// 
.................... ////   at address a, saves result to pointer 'data'. Returns 0 if OK,//// 
.................... ////   non-zero if error.                                            //// 
.................... ////                         ////////                                //// 
.................... ////  The following three functions are for writing data to the SD   //// 
.................... ////  card and to use them we must define 'SDCARD_WRITE' in the main //// 
.................... ////  code page. This gives us more free in RAM and to use these     //// 
.................... ////  functions the microcontroller must have RAM with more than     //// 
.................... ////  512 bytes.                                                     //// 
.................... ////                                                                 //// 
.................... ////  sdcard_write_sector(int32 sector_number, int8* data);          //// 
.................... ////   Writes an entire sector (block) from the SD/MMC. Returns 0 if //// 
.................... ////   OK, non-zero if error.                                        //// 
.................... ////                                                                 //// 
.................... ////  sdcard_write_byte(int32 addr, int8 &data);                     //// 
.................... ////   Writes byte 'data' to address 'addr'. Returns 0 if OK,        //// 
.................... ////   non-zero if error.                                            //// 
.................... ////                                                                 //// 
.................... ////  sdcard_write_data(int32 addr, int16 size, int8 *data);         //// 
.................... ////   Writes data of 'size' bytes from pointer 'data' starting at   //// 
.................... ////   address 'addr'. Returns 0 if OK, non-zero if error.           //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  http://ccspicc.blogspot.com/                                   //// 
.................... ////  electronnote@gmail.com                                         //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #include "sdcard.h"      
.................... #include "ucregisters.h"      
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                                                        
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1           
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81   
.................... #bit  PORTB_0=PORTB.0   
.................... #bit  PORTB_7=PORTB.7    
....................  
.................... // LCD PINS 
.................... //#byte TRISD = 0x0F95                      
.................... //#byte PORTD = 0x0F8C                      
.................... //#bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96      
.................... #byte PORTE = 0x0F84                        
....................  
....................    
.................... //#byte TRISC = 0x0F94  
.................... //#byte PORTC = 0x0F82             
.................... //#bit  TRISC_6=TRISC.6  
.................... //#bit  TRISC_7=TRISC.7   
....................                             
....................                       
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit      
....................  
.................... // ############# GLCD 128x64 ################ 
.................... //DATA 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F83   
.................... #byte LCD_data = 0x0F8C   
.................... //CONTROL 
.................... #byte TRISBB = 0x0F93      
.................... #byte PORTBB = 0x0F81   
.................... #byte LATBB  = 0x0F8A  
....................                                
.................... #bit   CS1 = LATBB.0   
.................... #bit   CS2 = LATBB.1   
.................... #bit   RS  = LATBB.2   
.................... #bit   RW  = LATBB.3  
.................... #bit   EN  = LATBB.4              
.................... #bit   RST = LATBB.5                       
....................                        
.................... //################## MMC/CARD - SPI ################### 
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82         
.................... #byte LATC  = 0x0F8B                            
....................   
.................... //SPI                         
.................... #bit   CS   = PORTC.2       
.................... #bit   CLK  = PORTC.3  
.................... #bit   SDI  = PORTC.4    
.................... #bit   SDO  = PORTC.5     
.................... #bit   CS_DIR   = TRISC.2   
.................... #bit   CLK_DIR  = TRISC.3        
.................... #bit   SDI_DIR  = TRISC.4   
.................... #bit   SDO_DIR  = TRISC.5   
....................                            
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR   
....................  
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
.................... #bit  CKE     = SSPSTAT.6   
.................... #bit  SMP     = SSPSTAT.7    
....................  
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #bit  SSPM0     = SSPCON1.0    
.................... #bit  SSPM1     = SSPCON1.1   
.................... #bit  SSPM2     = SSPCON1.2   
.................... #bit  SSPM3     = SSPCON1.3   
.................... #bit  CKP       = SSPCON1.4   
.................... #bit  SSPEN     = SSPCON1.5  
....................  
....................                 
....................                       
.................... #endif UCREGISTER_H                                                                          
....................  
....................  
.................... #ifndef SDCARD_H 
.................... #define SDCARD_H  
....................  
.................... uint16_t timeout; 
.................... enum _card_type{MMC, SDSC, SDHC} g_card_type; 
.................... enum sdcard_err{ 
....................   sdcard_goodec = 0, sdcard_idle = 0x01, sdcard_timeout = 0x80, 
....................   sdcard_illegal_cmd = 0x04 }; 
....................  
.................... #define GO_IDLE_STATE 0 
.................... #define SEND_IF_COND 8 
.................... #define SET_BLOCKLEN 16 
.................... #define READ_SINGLE_BLOCK 17 
.................... #define WRITE_BLOCK 24 
.................... #define SEND_APP_OP_COND 41 
.................... #define APP_CMD 55 
.................... #define READ_OCR 58 
....................  
.................... void send_sdcard_command(uint8_t command, uint32_t sd_data, uint8_t sd_crc); 
.................... sdcard_err sdcard_init();                     
.................... sdcard_err sdcard_read_byte(uint32_t addr, uint8_t* data); 
.................... sdcard_err sdcard_read_sector(uint32_t sector_number, uint8_t* data); 
.................... sdcard_err sdcard_read_data(uint32_t addr, uint16_t size, uint8_t* data); 
.................... sdcard_err sdcard_write_sector(uint32_t sector_number, uint8_t* data); 
.................... sdcard_err sdcard_write_byte(uint32_t addr, uint8_t &data); 
.................... sdcard_err sdcard_write_data(uint32_t addr, uint16_t size, uint8_t *data); 
.................... sdcard_err sdcard_get_r1(); 
.................... sdcard_err sdcard_get_r7(); 
.................... sdcard_err sdcard_go_idle_state(); 
.................... sdcard_err sdcard_send_if_cond(); 
.................... sdcard_err sdcard_send_app_cmd(); 
.................... sdcard_err sdcard_sd_send_op_cond(); 
.................... sdcard_err sdcard_read_ocr(uint8_t* _ocr_byte_3); 
.................... sdcard_err sdcard_set_blocklen(); 
.................... void sdcard_select(); 
.................... void sdcard_deselect(); 
....................  
.................... #endif  //SDCARD_H 
....................  
....................  
....................  
.................... sdcard_err sdcard_init(){ 
....................   uint8_t i, resp, ocr_byte_3; 
.................... #if defined(SDCARD_SPI_HW) 
....................   SETUP_SPI(SPI_MASTER | SPI_H_TO_L | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
*
089C:  BCF    FC6.5
089E:  BCF    F94.5
08A0:  BSF    F94.4
08A2:  BCF    F94.3
08A4:  MOVLW  32
08A6:  MOVWF  FC6
08A8:  MOVLW  00
08AA:  MOVWF  FC7
....................   #define sdcard_xfer(x)    spi_read(x) 
.................... #else 
....................   #if defined(SDCARD_PIN_SCL) 
....................    output_drive(SDCARD_PIN_SCL); 
....................   #endif 
....................   #if defined(SDCARD_PIN_SDO) 
....................    output_drive(SDCARD_PIN_SDO); 
....................   #endif 
....................   #if defined(SDCARD_PIN_SDI) 
....................    output_float(SDCARD_PIN_SDI);    
....................   #endif 
....................     #use spi(MASTER, DI=SDCARD_PIN_SDI, DO=SDCARD_PIN_SDO, CLK=SDCARD_PIN_SCL, BITS=8, MSB_FIRST, MODE=3, baud=400000) 
....................     #define sdcard_xfer(x)    spi_xfer(x)                               
.................... #endif 
....................   output_high(SDCARD_PIN_SELECT); 
08AC:  BCF    F94.2
08AE:  BSF    F8B.2
....................   output_drive(SDCARD_PIN_SELECT); 
08B0:  BCF    F94.2
....................   delay_ms(250); 
08B2:  MOVLW  FA
08B4:  MOVLB  2
08B6:  MOVWF  x21
08B8:  MOVLB  0
08BA:  RCALL  0610
....................   for(i = 0; i < 10; i++)                        // Send 80 cycles 
08BC:  MOVLB  2
08BE:  CLRF   x1E
08C0:  MOVF   x1E,W
08C2:  SUBLW  09
08C4:  BNC   08D2
....................     sdcard_xfer(0xFF); 
08C6:  MOVF   FC9,W
08C8:  SETF   FC9
08CA:  RRCF   FC7,W
08CC:  BNC   08CA
08CE:  INCF   x1E,F
08D0:  BRA    08C0
....................   sdcard_select(); 
08D2:  MOVLB  0
08D4:  RCALL  00FA
....................   resp = sdcard_go_idle_state();                 // Send CMD0 
08D6:  BRA    0722
08D8:  MOVFF  01,21F
....................   sdcard_deselect(); 
08DC:  RCALL  073E
....................   if(resp != sdcard_idle) 
08DE:  MOVLB  2
08E0:  DECFSZ x1F,W
08E2:  BRA    08E6
08E4:  BRA    08EC
....................     return resp;   
08E6:  MOVFF  21F,01
08EA:  BRA    09EA
....................   sdcard_select(); 
08EC:  MOVLB  0
08EE:  RCALL  00FA
....................   resp = sdcard_send_if_cond();                  // Send CMD8 
08F0:  BRA    079A
08F2:  MOVFF  01,21F
....................   sdcard_deselect(); 
08F6:  RCALL  073E
....................   if(resp != sdcard_idle) 
08F8:  MOVLB  2
08FA:  DECFSZ x1F,W
08FC:  BRA    0900
08FE:  BRA    0906
....................     return resp; 
0900:  MOVFF  21F,01
0904:  BRA    09EA
....................   i = 0; 
0906:  CLRF   x1E
....................   do{ 
....................     sdcard_select(); 
0908:  MOVLB  0
090A:  CALL   00FA
....................     resp = sdcard_send_app_cmd();                // Send CMD58 
090E:  BRA    07BC
0910:  MOVFF  01,21F
....................     if((resp != sdcard_idle) && (resp != sdcard_illegal_cmd) && (resp != 0)){ 
0914:  MOVLB  2
0916:  DECFSZ x1F,W
0918:  BRA    091C
091A:  BRA    0932
091C:  MOVF   x1F,W
091E:  SUBLW  04
0920:  BZ    0932
0922:  MOVF   x1F,F
0924:  BZ    0932
....................       sdcard_deselect(); return resp;} 
0926:  MOVLB  0
0928:  RCALL  073E
092A:  MOVLB  2
092C:  MOVFF  21F,01
0930:  BRA    09EA
....................     resp = sdcard_sd_send_op_cond();             // Send ACMD41 
0932:  MOVLB  0
0934:  BRA    07D8
0936:  MOVFF  01,21F
....................     sdcard_deselect(); 
093A:  RCALL  073E
....................     delay_ms(100); 
093C:  MOVLW  64
093E:  MOVLB  2
0940:  MOVWF  x21
0942:  MOVLB  0
0944:  RCALL  0610
....................     i++; 
0946:  MOVLB  2
0948:  INCF   x1E,F
....................   } while((resp == 0x01) && (i < 254)); 
094A:  DECFSZ x1F,W
094C:  BRA    0954
094E:  MOVF   x1E,W
0950:  SUBLW  FD
0952:  BC    0908
....................   sdcard_deselect(); 
0954:  MOVLB  0
0956:  RCALL  073E
....................   if((resp != 0 || i >= 254) && (resp != sdcard_illegal_cmd)) 
0958:  MOVLB  2
095A:  MOVF   x1F,F
095C:  BNZ   0964
095E:  MOVF   x1E,W
0960:  SUBLW  FD
0962:  BC    0970
0964:  MOVF   x1F,W
0966:  SUBLW  04
0968:  BZ    0970
....................     return sdcard_timeout; 
096A:  MOVLW  80
096C:  MOVWF  01
096E:  BRA    09EA
....................   if(resp == 0x04) g_card_type =  MMC;           // MMC type 
0970:  MOVF   x1F,W
0972:  SUBLW  04
0974:  BNZ   097A
0976:  CLRF   1B
0978:  BRA    097E
....................   else             g_card_type = SDSC;           // SDSC or SDHC type 
097A:  MOVLW  01
097C:  MOVWF  1B
....................   if(g_card_type == SDSC){ 
097E:  DECFSZ 1B,W
0980:  BRA    09BE
....................     sdcard_select(); 
0982:  MOVLB  0
0984:  CALL   00FA
....................     resp = sdcard_read_ocr(&ocr_byte_3); 
0988:  MOVLW  02
098A:  MOVLB  2
098C:  MOVWF  x22
098E:  MOVLW  20
0990:  MOVWF  x21
0992:  MOVLB  0
0994:  BRA    07F6
0996:  MOVFF  01,21F
....................     sdcard_deselect(); 
099A:  RCALL  073E
....................     if(resp != sdcard_idle && resp != sdcard_illegal_cmd) 
099C:  MOVLB  2
099E:  DECFSZ x1F,W
09A0:  BRA    09A4
09A2:  BRA    09B0
09A4:  MOVF   x1F,W
09A6:  SUBLW  04
09A8:  BZ    09B0
....................       return resp; 
09AA:  MOVFF  21F,01
09AE:  BRA    09EA
....................     if(resp != sdcard_illegal_cmd){ 
09B0:  MOVF   x1F,W
09B2:  SUBLW  04
09B4:  BZ    09BE
....................       if(bit_test(ocr_byte_3, 6))                  // If bit 30 of the OCR register is 1 (CCS is 1) ==> SDHC type 
09B6:  BTFSS  x20.6
09B8:  BRA    09BE
....................         g_card_type =  SDHC; 
09BA:  MOVLW  02
09BC:  MOVWF  1B
....................     } 
....................   } 
....................   sdcard_select(); 
09BE:  MOVLB  0
09C0:  CALL   00FA
....................   resp = sdcard_set_blocklen(); 
09C4:  BRA    087E
09C6:  MOVFF  01,21F
....................   sdcard_deselect(); 
09CA:  RCALL  073E
....................   if(resp != 0) 
09CC:  MOVLB  2
09CE:  MOVF   x1F,F
09D0:  BZ    09D8
....................     return sdcard_timeout; 
09D2:  MOVLW  80
09D4:  MOVWF  01
09D6:  BRA    09EA
.................... #if defined(SDCARD_SPI_HW) 
....................   // Speed up the SPI bus 
....................   SETUP_SPI(SPI_MASTER | SPI_H_TO_L | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
09D8:  BCF    FC6.5
09DA:  BCF    F94.5
09DC:  BSF    F94.4
09DE:  BCF    F94.3
09E0:  MOVLW  30
09E2:  MOVWF  FC6
09E4:  MOVLW  00
09E6:  MOVWF  FC7
.................... #else 
....................    #use spi(MASTER, DI=SDCARD_PIN_SDI, DO=SDCARD_PIN_SDO, CLK=SDCARD_PIN_SCL, BITS=8, MSB_FIRST, MODE=3) 
.................... #endif 
....................   return sdcard_goodec; 
09E8:  MOVWF  01
09EA:  MOVLB  0
09EC:  GOTO   0A18 (RETURN)
.................... } 
....................  
....................  
.................... sdcard_err sdcard_read_byte(uint32_t addr, uint8_t* data){ 
....................   uint8_t response; 
....................   uint16_t i, byte_addr; 
....................   uint32_t sector_number; 
....................   timeout = 0xFFFF; 
....................   sector_number = addr/512; 
....................   if(g_card_type != SDHC) 
....................     sector_number = sector_number << 9; 
....................   byte_addr = addr % 512; 
....................   sdcard_select(); 
....................   send_sdcard_command(17, sector_number, 0xFF); 
....................   while(timeout){ 
....................     response = sdcard_xfer(0xFF); 
....................     if(response == 0xFE){ 
....................       for(i = 0; i < byte_addr; i++) 
....................         sdcard_xfer(0xFF); 
....................       *data = sdcard_xfer(0xFF); 
....................       byte_addr++; 
....................       for(i = byte_addr; i < 512; i++) 
....................         sdcard_xfer(0xFF); 
....................       for(i = 0; i < 2; i++) 
....................         sdcard_xfer(0xFF); 
....................       sdcard_deselect(); 
....................       return sdcard_goodec; 
....................     } 
....................     timeout--; 
....................   } 
....................   sdcard_deselect(); 
....................   return sdcard_timeout;  
.................... } 
....................  
.................... sdcard_err sdcard_read_sector(uint32_t sector_number, uint8_t* data){ 
....................   uint8_t response; 
....................   uint16_t i; 
....................   timeout = 0xFFFF; 
*
0A4E:  SETF   1A
0A50:  SETF   19
....................   sdcard_select(); 
0A52:  CALL   00FA
....................   for(i = 0; i < 10; i++)  sdcard_xfer(0xFF); 
0A56:  MOVLB  2
0A58:  CLRF   x31
0A5A:  CLRF   x30
0A5C:  MOVF   x31,F
0A5E:  BNZ   0A76
0A60:  MOVF   x30,W
0A62:  SUBLW  09
0A64:  BNC   0A76
0A66:  MOVF   FC9,W
0A68:  SETF   FC9
0A6A:  RRCF   FC7,W
0A6C:  BNC   0A6A
0A6E:  INCF   x30,F
0A70:  BTFSC  FD8.2
0A72:  INCF   x31,F
0A74:  BRA    0A5C
....................   sdcard_deselect(); 
0A76:  MOVLB  0
0A78:  RCALL  073E
....................   if(g_card_type != SDHC) 
0A7A:  MOVF   1B,W
0A7C:  SUBLW  02
0A7E:  BZ    0A9A
....................     sector_number = sector_number << 9; 
0A80:  BCF    FD8.0
0A82:  MOVFF  22B,22C
0A86:  MOVFF  22A,22B
0A8A:  MOVFF  229,22A
0A8E:  MOVLB  2
0A90:  CLRF   x29
0A92:  RLCF   x2A,F
0A94:  RLCF   x2B,F
0A96:  RLCF   x2C,F
0A98:  MOVLB  0
....................   sdcard_select(); 
0A9A:  CALL   00FA
....................   send_sdcard_command(17, sector_number, 0xFF); 
0A9E:  MOVLW  11
0AA0:  MOVLB  2
0AA2:  MOVWF  x32
0AA4:  MOVFF  22C,236
0AA8:  MOVFF  22B,235
0AAC:  MOVFF  22A,234
0AB0:  MOVFF  229,233
0AB4:  SETF   x37
0AB6:  MOVLB  0
0AB8:  RCALL  0686
....................   while(timeout){ 
0ABA:  MOVF   19,W
0ABC:  IORWF  1A,W
0ABE:  BZ    0B34
....................     response = sdcard_xfer(0xFF); 
0AC0:  MOVF   FC9,W
0AC2:  SETF   FC9
0AC4:  RRCF   FC7,W
0AC6:  BNC   0AC4
0AC8:  MOVFF  FC9,22F
....................     if(response == 0xFE){ 
0ACC:  MOVLB  2
0ACE:  MOVF   x2F,W
0AD0:  SUBLW  FE
0AD2:  BNZ   0B28
....................       for(i = 0; i < 512; i++) 
0AD4:  CLRF   x31
0AD6:  CLRF   x30
0AD8:  MOVF   x31,W
0ADA:  SUBLW  01
0ADC:  BNC   0AFE
....................         data[i] = sdcard_xfer(0xFF); 
0ADE:  MOVF   x2D,W
0AE0:  ADDWF  x30,W
0AE2:  MOVWF  FE9
0AE4:  MOVF   x2E,W
0AE6:  ADDWFC x31,W
0AE8:  MOVWF  FEA
0AEA:  MOVF   FC9,W
0AEC:  SETF   FC9
0AEE:  RRCF   FC7,W
0AF0:  BNC   0AEE
0AF2:  MOVFF  FC9,FEF
0AF6:  INCF   x30,F
0AF8:  BTFSC  FD8.2
0AFA:  INCF   x31,F
0AFC:  BRA    0AD8
....................       for(i = 0; i < 2; i++) 
0AFE:  CLRF   x31
0B00:  CLRF   x30
0B02:  MOVF   x31,F
0B04:  BNZ   0B1C
0B06:  MOVF   x30,W
0B08:  SUBLW  01
0B0A:  BNC   0B1C
....................         sdcard_xfer(0xFF); 
0B0C:  MOVF   FC9,W
0B0E:  SETF   FC9
0B10:  RRCF   FC7,W
0B12:  BNC   0B10
0B14:  INCF   x30,F
0B16:  BTFSC  FD8.2
0B18:  INCF   x31,F
0B1A:  BRA    0B02
....................       sdcard_deselect(); 
0B1C:  MOVLB  0
0B1E:  RCALL  073E
....................       return sdcard_goodec; 
0B20:  MOVLW  00
0B22:  MOVWF  01
0B24:  BRA    0B3A
0B26:  MOVLB  2
....................     } 
....................     timeout--; 
0B28:  MOVF   19,W
0B2A:  BTFSC  FD8.2
0B2C:  DECF   1A,F
0B2E:  DECF   19,F
0B30:  MOVLB  0
0B32:  BRA    0ABA
....................   } 
....................   sdcard_deselect(); 
0B34:  RCALL  073E
....................   return sdcard_timeout;  
0B36:  MOVLW  80
0B38:  MOVWF  01
0B3A:  GOTO   0CBC (RETURN)
.................... } 
....................  
.................... sdcard_err sdcard_read_data(uint32_t addr, uint16_t size, uint8_t* data){ 
....................   uint8_t response = 0; 
....................   uint16_t i, byte_addr, byte_number = 0; 
....................   uint32_t sector_number; 
....................   timeout = 0xFFFF; 
....................   sector_number = addr/512; 
....................   byte_addr = addr % 512; 
....................   next_sector: 
....................   if(g_card_type != SDHC) 
....................     sector_number = sector_number << 9; 
....................   sdcard_select(); 
....................   send_sdcard_command(17, sector_number, 0xFF); 
....................   while(timeout){ 
....................     response = sdcard_xfer(0xFF); 
....................     if(response == 0xFE){ 
....................       for(i = 0; i < byte_addr; i++) 
....................         sdcard_xfer(0xFF); 
....................       if((byte_addr + size) < 512){ 
....................         size += byte_addr; 
....................         for(i = byte_addr; i < size; i++, byte_number++) 
....................           data[byte_number] = sdcard_xfer(0xFF); 
....................         for(i = size; i < 512; i++) 
....................           sdcard_xfer(0xFF); 
....................       } 
....................       else{ 
....................         for(i = byte_addr; i < 512; i++, byte_number++, size--) 
....................           data[byte_number] = sdcard_xfer(0xFF); 
....................         for(i = 0; i < 2; i++) 
....................           sdcard_xfer(0xFF); 
....................         sdcard_deselect(); 
....................         if(g_card_type != SDHC) 
....................           sector_number = sector_number >> 9; 
....................         sector_number++; 
....................         byte_addr = 0; 
....................         goto next_sector; 
....................       } 
....................       for(i = 0; i < 2; i++) 
....................         sdcard_xfer(0xFF); 
....................       sdcard_deselect(); 
....................       return sdcard_goodec; 
....................     } 
....................     timeout--; 
....................   } 
....................   sdcard_deselect(); 
....................   return sdcard_timeout;  
.................... } 
....................  
.................... #if defined(SDCARD_WRITE) 
....................  
.................... sdcard_err sdcard_write_sector(uint32_t sector_number, uint8_t *data){ 
....................   uint8_t response; 
....................   uint16_t i; 
....................   timeout = 0xFFFF; 
....................   if(g_card_type != SDHC) 
....................     sector_number = sector_number << 9; 
....................   sdcard_select(); 
....................   send_sdcard_command(24, sector_number, 0xFF); 
....................   while(timeout){ 
....................     response = sdcard_xfer(0xFF); 
....................     if(response != 0xFF){ 
....................       sdcard_xfer(0xFE); 
....................       for(i = 0; i < 512; i++)                   // Send 512 data bytes 
....................         sdcard_xfer(data[i]); 
....................       for(i = 0; i < 2; i++)                     // Send 2 CRC bytes 
....................         sdcard_xfer(0xFF); 
....................       // get the error code back from the card; "data accepted" is 0bXXX00101 
....................       response = sdcard_get_r1(); 
....................       if(response & 0x0A){ 
....................         sdcard_deselect(); 
....................         return response; 
....................       } 
....................       // wait for the line to go back high, this indicates that the write is complete 
....................       while(sdcard_xfer(0xFF) == 0); 
....................       sdcard_deselect(); 
....................       return sdcard_goodec; 
....................     } 
....................     timeout--; 
....................   } 
....................   sdcard_deselect(); 
....................   return sdcard_timeout; 
.................... } 
....................  
.................... sdcard_err sdcard_write_byte(uint32_t addr, uint8_t &data){ 
....................   uint8_t  sector_data[512]; 
....................   uint16_t byte_addr; 
....................   uint32_t sector_number; 
....................   sector_number = addr/512; 
....................   byte_addr = addr % 512; 
....................   if(sdcard_read_sector(sector_number, sector_data) != 0) 
....................     return 1; 
....................   sector_data[byte_addr] = data; 
....................   if(sdcard_write_sector(sector_number, sector_data) != 0) 
....................     return 1; 
....................   return sdcard_goodec; 
.................... } 
....................  
.................... sdcard_err sdcard_write_data(uint32_t addr, uint16_t size, uint8_t *data){ 
....................   uint8_t  sector_data[512]; 
....................   uint16_t i, byte_addr; 
....................   uint32_t sector_number; 
....................   sector_number = addr/512; 
....................   byte_addr = addr % 512; 
....................   next_sector: 
....................   if(sdcard_read_sector(sector_number, sector_data) != 0) 
....................     return 1; 
....................   if(byte_addr + size < 513){ 
....................     size += byte_addr; 
....................     for(i = byte_addr; i < size; i++)  sector_data[i] = data[i - byte_addr]; 
....................     if(sdcard_write_sector(sector_number, sector_data) != 0) 
....................       return 1; 
....................   } 
....................   else{ 
....................     for(i = byte_addr; i < 512; i++, size--)  sector_data[i] = data[i - byte_addr]; 
....................     if(sdcard_write_sector(sector_number, sector_data) != 0) 
....................       return 1; 
....................     byte_addr = 0; 
....................     sector_number++; 
....................     goto next_sector; 
....................   } 
....................   return sdcard_goodec; 
.................... } 
.................... #endif 
....................  
.................... void send_sdcard_command(uint8_t command, uint32_t sd_data, uint8_t sd_crc){ 
....................   uint8_t i; 
....................   sdcard_xfer(0x40 | command); 
*
0686:  MOVLB  2
0688:  MOVF   x32,W
068A:  IORLW  40
068C:  MOVWF  x39
068E:  MOVF   FC9,W
0690:  MOVFF  239,FC9
0694:  RRCF   FC7,W
0696:  BNC   0694
....................   for(i = 0; i < 4; i++) 
0698:  CLRF   x38
069A:  MOVF   x38,W
069C:  SUBLW  03
069E:  BNC   06DC
....................     sdcard_xfer(sd_data >> (3 - i) * 8); 
06A0:  MOVLW  03
06A2:  BSF    FD8.0
06A4:  SUBFWB x38,W
06A6:  MULLW  08
06A8:  MOVFF  FF3,239
06AC:  MOVFF  236,23D
06B0:  MOVFF  235,23C
06B4:  MOVFF  234,23B
06B8:  MOVFF  233,23A
06BC:  MOVF   x39,F
06BE:  BZ    06CE
06C0:  BCF    FD8.0
06C2:  RRCF   x3D,F
06C4:  RRCF   x3C,F
06C6:  RRCF   x3B,F
06C8:  RRCF   x3A,F
06CA:  DECFSZ x39,F
06CC:  BRA    06C0
06CE:  MOVF   FC9,W
06D0:  MOVFF  23A,FC9
06D4:  RRCF   FC7,W
06D6:  BNC   06D4
06D8:  INCF   x38,F
06DA:  BRA    069A
....................   sdcard_xfer(sd_crc); 
06DC:  MOVF   FC9,W
06DE:  MOVFF  237,FC9
06E2:  RRCF   FC7,W
06E4:  BNC   06E2
06E6:  MOVLB  0
06E8:  RETURN 0
.................... } 
....................  
.................... sdcard_err sdcard_go_idle_state(){ 
....................   send_sdcard_command(GO_IDLE_STATE, 0, 0x95); 
*
0722:  MOVLB  2
0724:  CLRF   x32
0726:  CLRF   x36
0728:  CLRF   x35
072A:  CLRF   x34
072C:  CLRF   x33
072E:  MOVLW  95
0730:  MOVWF  x37
0732:  MOVLB  0
0734:  RCALL  0686
....................   return sdcard_get_r1(); 
0736:  RCALL  06EA
0738:  MOVF   01,W
073A:  GOTO   08D8 (RETURN)
.................... } 
....................  
.................... sdcard_err sdcard_send_if_cond(){ 
....................   send_sdcard_command(SEND_IF_COND, 0x1AA, 0x87); 
*
079A:  MOVLW  08
079C:  MOVLB  2
079E:  MOVWF  x32
07A0:  CLRF   x36
07A2:  CLRF   x35
07A4:  MOVLW  01
07A6:  MOVWF  x34
07A8:  MOVLW  AA
07AA:  MOVWF  x33
07AC:  MOVLW  87
07AE:  MOVWF  x37
07B0:  MOVLB  0
07B2:  RCALL  0686
....................   return sdcard_get_r7();  
07B4:  BRA    074C
07B6:  MOVF   01,W
07B8:  GOTO   08F2 (RETURN)
.................... } 
....................  
.................... sdcard_err sdcard_send_app_cmd(){ 
....................   send_sdcard_command(APP_CMD, 0, 0xFF); 
07BC:  MOVLW  37
07BE:  MOVLB  2
07C0:  MOVWF  x32
07C2:  CLRF   x36
07C4:  CLRF   x35
07C6:  CLRF   x34
07C8:  CLRF   x33
07CA:  SETF   x37
07CC:  MOVLB  0
07CE:  RCALL  0686
....................   return sdcard_get_r1(); 
07D0:  RCALL  06EA
07D2:  MOVF   01,W
07D4:  GOTO   0910 (RETURN)
.................... } 
....................  
.................... sdcard_err sdcard_sd_send_op_cond(){ 
....................   send_sdcard_command(SEND_APP_OP_COND, 0x40000000, 0xFF); 
07D8:  MOVLW  29
07DA:  MOVLB  2
07DC:  MOVWF  x32
07DE:  MOVLW  40
07E0:  MOVWF  x36
07E2:  CLRF   x35
07E4:  CLRF   x34
07E6:  CLRF   x33
07E8:  SETF   x37
07EA:  MOVLB  0
07EC:  RCALL  0686
....................   return sdcard_get_r1(); 
07EE:  RCALL  06EA
07F0:  MOVF   01,W
07F2:  GOTO   0936 (RETURN)
.................... } 
....................  
.................... sdcard_err sdcard_read_ocr(uint8_t* _ocr_byte_3){ 
....................   uint8_t i, response; 
....................   timeout = 0xFFFF; 
07F6:  SETF   1A
07F8:  SETF   19
....................   send_sdcard_command(READ_OCR, 0, 0xFF); 
07FA:  MOVLW  3A
07FC:  MOVLB  2
07FE:  MOVWF  x32
0800:  CLRF   x36
0802:  CLRF   x35
0804:  CLRF   x34
0806:  CLRF   x33
0808:  SETF   x37
080A:  MOVLB  0
080C:  RCALL  0686
....................   while(timeout){ 
080E:  MOVF   19,W
0810:  IORWF  1A,W
0812:  BZ    0872
....................     response = sdcard_xfer(0xFF); 
0814:  MOVF   FC9,W
0816:  SETF   FC9
0818:  RRCF   FC7,W
081A:  BNC   0818
081C:  MOVFF  FC9,224
....................     if(response != 0xFF){ 
0820:  MOVLB  2
0822:  INCFSZ x24,W
0824:  BRA    0828
0826:  BRA    086E
....................       if(response == 0x04) return response; 
0828:  MOVF   x24,W
082A:  SUBLW  04
082C:  BNZ   0834
082E:  MOVFF  224,01
0832:  BRA    0878
....................       *_ocr_byte_3 = sdcard_xfer(0xFF); 
0834:  MOVFF  222,03
0838:  MOVFF  221,FE9
083C:  MOVFF  222,FEA
0840:  MOVF   FC9,W
0842:  SETF   FC9
0844:  RRCF   FC7,W
0846:  BNC   0844
0848:  MOVFF  FC9,FEF
....................       for(i = 0; i < 3; i++) 
084C:  CLRF   x23
084E:  MOVF   x23,W
0850:  SUBLW  02
0852:  BNC   0860
....................         sdcard_xfer(0xFF); 
0854:  MOVF   FC9,W
0856:  SETF   FC9
0858:  RRCF   FC7,W
085A:  BNC   0858
085C:  INCF   x23,F
085E:  BRA    084E
....................       return sdcard_idle; 
0860:  MOVLW  01
0862:  MOVWF  01
0864:  BRA    0878
....................     timeout--; 
0866:  MOVF   19,W
0868:  BTFSC  FD8.2
086A:  DECF   1A,F
086C:  DECF   19,F
....................     } 
086E:  MOVLB  0
0870:  BRA    080E
....................   } 
....................   return sdcard_timeout; 
0872:  MOVLW  80
0874:  MOVWF  01
0876:  MOVLB  2
0878:  MOVLB  0
087A:  GOTO   0996 (RETURN)
.................... } 
....................  
.................... sdcard_err sdcard_set_blocklen(){ 
....................   send_sdcard_command(SET_BLOCKLEN, 512, 0xFF); 
087E:  MOVLW  10
0880:  MOVLB  2
0882:  MOVWF  x32
0884:  CLRF   x36
0886:  CLRF   x35
0888:  MOVLW  02
088A:  MOVWF  x34
088C:  CLRF   x33
088E:  SETF   x37
0890:  MOVLB  0
0892:  RCALL  0686
....................   return sdcard_get_r1(); 
0894:  RCALL  06EA
0896:  MOVF   01,W
0898:  GOTO   09C6 (RETURN)
.................... } 
....................  
.................... sdcard_err sdcard_get_r1(){ 
*
06EA:  MOVLB  2
06EC:  CLRF   x21
....................   uint8_t response = 0; 
....................   timeout = 0xFFFF; 
06EE:  SETF   1A
06F0:  SETF   19
....................   while(timeout){ 
06F2:  MOVF   19,W
06F4:  IORWF  1A,W
06F6:  BZ    071A
....................     response = sdcard_xfer(0xFF); 
06F8:  MOVF   FC9,W
06FA:  SETF   FC9
06FC:  RRCF   FC7,W
06FE:  BNC   06FC
0700:  MOVFF  FC9,221
....................     if(response != 0xFF){ 
0704:  INCFSZ x21,W
0706:  BRA    070A
0708:  BRA    0710
....................       return response; 
070A:  MOVFF  221,01
070E:  BRA    071E
....................     } 
....................     timeout--; 
0710:  MOVF   19,W
0712:  BTFSC  FD8.2
0714:  DECF   1A,F
0716:  DECF   19,F
0718:  BRA    06F2
....................   } 
....................   return sdcard_timeout; 
071A:  MOVLW  80
071C:  MOVWF  01
071E:  MOVLB  0
0720:  RETURN 0
.................... } 
....................  
.................... sdcard_err sdcard_get_r7(){ 
*
074C:  MOVLB  2
074E:  CLRF   x22
....................   uint8_t i, response = 0; 
....................   timeout = 0xFFFF; 
0750:  SETF   1A
0752:  SETF   19
....................   while(timeout){ 
0754:  MOVF   19,W
0756:  IORWF  1A,W
0758:  BZ    0790
....................     response = sdcard_xfer(0xFF); 
075A:  MOVF   FC9,W
075C:  SETF   FC9
075E:  RRCF   FC7,W
0760:  BNC   075E
0762:  MOVFF  FC9,222
....................     if(response != 0xFF){ 
0766:  INCFSZ x22,W
0768:  BRA    076C
076A:  BRA    0786
....................       for(i = 0; i < 4; i++) 
076C:  CLRF   x21
076E:  MOVF   x21,W
0770:  SUBLW  03
0772:  BNC   0780
....................         sdcard_xfer(0xFF); 
0774:  MOVF   FC9,W
0776:  SETF   FC9
0778:  RRCF   FC7,W
077A:  BNC   0778
077C:  INCF   x21,F
077E:  BRA    076E
....................       return sdcard_idle; 
0780:  MOVLW  01
0782:  MOVWF  01
0784:  BRA    0794
....................     } 
....................     timeout--; 
0786:  MOVF   19,W
0788:  BTFSC  FD8.2
078A:  DECF   1A,F
078C:  DECF   19,F
078E:  BRA    0754
....................   } 
....................   return sdcard_timeout; 
0790:  MOVLW  80
0792:  MOVWF  01
0794:  MOVLB  0
0796:  GOTO   07B6 (RETURN)
.................... } 
....................  
.................... void sdcard_select(){ 
....................   output_low(SDCARD_PIN_SELECT); 
*
00FA:  BCF    F94.2
00FC:  BCF    F8B.2
00FE:  RETURN 0
.................... } 
....................  
.................... void sdcard_deselect(){ 
....................   output_high(SDCARD_PIN_SELECT); 
*
073E:  BCF    F94.2
0740:  BSF    F8B.2
....................   sdcard_xfer(0xFF); 
0742:  MOVF   FC9,W
0744:  SETF   FC9
0746:  RRCF   FC7,W
0748:  BNC   0746
074A:  RETURN 0
.................... } 
....................  
.................... #include "glcd.c"  
.................... #include "glcd.h"    
.................... #include "definitions.h"     
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;   
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;    
....................  
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t;       
....................        
.................... typedef signed int16 int16_t; 
....................      
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
....................  
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #include "ucregisters.h"  
.................... #ifndef UCREGISTER_H 
.................... #define UCREGISTER_H 
....................  
....................                                                        
.................... //Analog PINS            
.................... #byte TRISA = 0x0F92     
.................... #byte PORTA = 0x0F80   
.................... #bit  PORTA_DIR_0=TRISA.0  
.................... #bit  PORTA_0=PORTA.0   
.................... #bit  PORTA_DIR_1=TRISA.1  
.................... #bit  PORTA_1=PORTA.1           
....................                        
.................... //Control PINS 
.................... #byte TRISB = 0x0F93      
.................... #byte PORTB = 0x0F81   
.................... #bit  PORTB_0=PORTB.0   
.................... #bit  PORTB_7=PORTB.7    
....................  
.................... // LCD PINS 
.................... //#byte TRISD = 0x0F95                      
.................... //#byte PORTD = 0x0F8C                      
.................... //#bit  PORTD_7=PORTD.7     
....................  
.................... //LCD Control Pins 
.................... #byte TRISE = 0x0F96      
.................... #byte PORTE = 0x0F84                        
....................  
....................    
.................... //#byte TRISC = 0x0F94  
.................... //#byte PORTC = 0x0F82             
.................... //#bit  TRISC_6=TRISC.6  
.................... //#bit  TRISC_7=TRISC.7   
....................                             
....................                       
....................  
....................                           
.................... //OSILATOR - 8MHZ 
.................... #byte OSCCON = 0x0FD3        
.................... #bit  IRCF2 =OSCCON.6   
.................... #bit  IRCF1 =OSCCON.5                      
.................... #bit  IRCF0 =OSCCON.4  
....................         
.................... //TIMER1 INTERRUPT BYTE adresleri 
....................     
.................... #byte RCON = 0x0FD0    // RCON REGISTER 
.................... #byte INTCON = 0x0FF2  // INTCON REGISTER  
.................... #byte IPR1 = 0x0F9F    // Cevresel kesme onceligi                          
.................... #byte PIR1 = 0x0F9E    // Cevresel kesme istegi (Bayrak) 
.................... #byte PIE1 = 0x0F9D    // Cevresel kesme yetkisi  
.................... #byte T1CON  = 0x0FCD  // TIMER1 kontrol kayitcisi  
.................... #byte TMR1H = 0x0FCF   // TIMER1'in ta;ma sayacinin son 8 biti                                      
.................... #byte TMR1L = 0x0FCE   // TIMER1'in ta;ma sayacinin ilk 8 biti 
.................... //   #############TIMER 1########                                                            
.................... //# RCON  :: RCON REGISTER // Bit Adresleri                                     
.................... #bit RCON_IPEN = RCON.7        // Enable priority levels on interrupts                    
.................... //# INTCON  :: INTCON REGISTER // Bit Adresleri       
.................... #bit INTCON_GIE_GIEH = INTCON.7  // Global Interrupt Enable bit  
.................... #bit INTCON_PEIE = INTCON.6      // INTCON_PEIE=1, Enables all high priority interrupts 
.................... //# IPR1  :: IPR1 REGISTER // Bit Adresleri  
.................... #bit IPR1_TMR1IP = IPR1.0  // TMR1 Overflow Interrupt Priority bit                                         
.................... //# PIR1  :: PIR1 REGISTER // Bit Adresleri 
.................... #bit PIR1_TMR1IF=PIR1.0    // TMR1 Overflow Interrupt Flag bit     
.................... //# PIE1  :: PIE1 REGISTER // Bit Adresleri  
.................... #bit PIE1_TMR1IE=PIE1.0    // TMR1 Overflow Interrupt Enable bit      
.................... //#T0CON  :: TIMER0 CONTROL REGISTER // Bit Adresleri 
.................... #bit T1CON_RD16    = T1CON.7     // 16-bit Read/Write Mode Enable bit 
.................... #bit T1CON_T1RUN   = T1CON.6     // Timer1 System Clock Status bit 
.................... #bit T1CON_T1CKPS1 = T1CON.5     // Timer1 Input Clock Prescale Select bits                              
.................... #bit T1CON_T1CKPS0 = T1CON.4     // Timer1 Input Clock Prescale Select bits 
.................... #bit T1CON_T1OSCEN = T1CON.3     // Timer1 Oscillator Enable bit 
.................... #bit T1CON_T1SYNC  = T1CON.2     // Timer1 External Clock Input Synchronization Select bit 
.................... #bit T1CON_TMR1CS  = T1CON.1     // Timer1 Clock Source Select bit  
.................... #bit T1CON_TMR1ON  = T1CON.0     // Timer1 On bit          
....................                                                                  
.................... //   ################   RS232/EUSART   #################  //    
.................... #byte  RCSTA   = 0x0FAB    // RCSTA: RECEIVE STATUS AND CONTROL REGISTER 
.................... #byte  BAUDCON = 0x0FB8    // BAUDCON: BAUD RATE CONTROL REGISTER                        
.................... #byte  TXSTA   = 0x0FAC    // TXSTA: TRANSMIT STATUS AND CONTROL REGISTER  
.................... #byte  SPBRGH  = 0x0FB0    // EUSART Baud Rate Generator Register, High Byte                          
.................... #byte  SPBRG   = 0x0FAF    // EUSART Baud Rate Generator Register, Low Byte   
.................... #byte  TXREG   = 0x0FAD    // EUSART Transmit Register                             
.................... #byte  RCREG   = 0x0FAE    // EUSART Receive Register 
....................  
.................... #bit   OERR_RCSTA= RCSTA.1  // Overrun Error bit 
.................... #bit   CREN_RCSTA= RCSTA.4  // Continuous Receive Enable bit    
.................... #bit   TXIF_PIR1 = PIR1.4   // EUSART Transmit Interrupt Flag bit 
.................... #bit   RCIF_PIR1 = PIR1.5   // EUSART Receive Interrupt Flag bit  
.................... #bit   RCIE_PIE1 = PIE1.5   // EUSART Receive Interrupt Enable bit  
.................... #bit   TXIE_PIE1 = PIE1.4   // EUSART Transmit Interrupt Enable bit      
....................  
.................... // ############# GLCD 128x64 ################ 
.................... //DATA 
.................... #byte TRISD = 0x0F95                      
.................... #byte PORTD = 0x0F83   
.................... #byte LCD_data = 0x0F8C   
.................... //CONTROL 
.................... #byte TRISBB = 0x0F93      
.................... #byte PORTBB = 0x0F81   
.................... #byte LATBB  = 0x0F8A  
....................                                
.................... #bit   CS1 = LATBB.0   
.................... #bit   CS2 = LATBB.1   
.................... #bit   RS  = LATBB.2   
.................... #bit   RW  = LATBB.3  
.................... #bit   EN  = LATBB.4              
.................... #bit   RST = LATBB.5                       
....................                        
.................... //################## MMC/CARD - SPI ################### 
.................... #byte TRISC = 0x0F94  
.................... #byte PORTC = 0x0F82         
.................... #byte LATC  = 0x0F8B                            
....................   
.................... //SPI                         
.................... #bit   CS   = PORTC.2       
.................... #bit   CLK  = PORTC.3  
.................... #bit   SDI  = PORTC.4    
.................... #bit   SDO  = PORTC.5     
.................... #bit   CS_DIR   = TRISC.2   
.................... #bit   CLK_DIR  = TRISC.3        
.................... #bit   SDI_DIR  = TRISC.4   
.................... #bit   SDO_DIR  = TRISC.5   
....................                            
.................... #byte SSPBUF  = 0x0FC9        // VERI GONDERIRKEN VE ALIRKEN BU 8 BITLIK REGISTER KULLANILIR   
....................  
.................... #byte SSPSTAT = 0x0FC7        // VERI HIZI VE BF KONTROLU SAGLANIYOR                                                                  
.................... #bit  BF      = SSPSTAT.0     // BUFFER(SSPBUF REGISTER)'IN BOS VEYA DOLU OLUP OLMADIGININ KONTROLUNU YAPAR. 
.................... #bit  CKE     = SSPSTAT.6   
.................... #bit  SMP     = SSPSTAT.7    
....................  
.................... #byte SSPCON1 = 0x0FC6        // SDA VE SCL'YI AKTIF EDIYORUZ || I2C'YI MASTER MODUNA ALIYORUZ()  URETECEGIMIZ SAAT FREKANSI clock = FOSC/(4 * (SSPADD + 1))  
.................... #bit  SSPM0     = SSPCON1.0    
.................... #bit  SSPM1     = SSPCON1.1   
.................... #bit  SSPM2     = SSPCON1.2   
.................... #bit  SSPM3     = SSPCON1.3   
.................... #bit  CKP       = SSPCON1.4   
.................... #bit  SSPEN     = SSPCON1.5  
....................  
....................                 
....................                       
.................... #endif UCREGISTER_H                                                                          
....................  
.................... #include "fonts.h"   
.................... #include "definitions.h"     
.................... #ifndef DEFINITIONS_H      
.................... #define DEFINITIONS_H    
....................  
.................... typedef unsigned int32  uint32_t;                                                      
.................... typedef unsigned int16  uint16_t; 
.................... typedef signed   int16  sint16_t;  
.................... typedef unsigned int8   uint8_t;   
.................... typedef signed   int8   sint8_t; 
....................  
.................... typedef       float32   float32_t; 
.................... typedef unsigned char   uchar_t;    
....................  
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t;       
....................        
.................... typedef signed int16 int16_t; 
....................      
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
....................  
....................                              
....................                
.................... #endif //DEFINITIONS_H       
....................  
.................... #ifndef FONTS_H        
.................... #define FONTS_H    
....................  
.................... const uchar_t Font5x7[][6]  = {  
.................... {      0x00, 0x00, 0x00, 0x00, 0x00, 0x00},// (space) 
.................... {      0x00, 0x00, 0x5F, 0x00, 0x00, 0x00},// !     
.................... {      0x00, 0x07, 0x00, 0x07, 0x00, 0x00},// " 
.................... {      0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00},// # 
.................... {      0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00},// $ 
.................... {      0x23, 0x13, 0x08, 0x64, 0x62, 0x00},// % 
.................... {      0x36, 0x49, 0x55, 0x22, 0x50, 0x00},// & 
.................... {      0x00, 0x05, 0x03, 0x00, 0x00, 0x00},// ' 
.................... {      0x00, 0x1C, 0x22, 0x41, 0x00, 0x00},// ( 
.................... {      0x00, 0x41, 0x22, 0x1C, 0x00, 0x00},// ) 
.................... {      0x08, 0x2A, 0x1C, 0x2A, 0x08, 0x00},// *                
.................... {      0x08, 0x08, 0x3E, 0x08, 0x08, 0x00},// + 
.................... {      0x00, 0x50, 0x30, 0x00, 0x00, 0x00},// , 
.................... {      0x08, 0x08, 0x08, 0x08, 0x08, 0x00},// - 
.................... {      0x00, 0x60, 0x60, 0x00, 0x00, 0x00},// . 
.................... {      0x20, 0x10, 0x08, 0x04, 0x02, 0x00},// / 
.................... {      0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00},// 0 
.................... {      0x00, 0x42, 0x7F, 0x40, 0x00, 0x00},// 1 
.................... {      0x42, 0x61, 0x51, 0x49, 0x46, 0x00},// 2 
.................... {      0x21, 0x41, 0x45, 0x4B, 0x31, 0x00},// 3 
.................... {      0x18, 0x14, 0x12, 0x7F, 0x10, 0x00},// 4 
.................... {      0x27, 0x45, 0x45, 0x45, 0x39, 0x00},// 5 
.................... {      0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00},// 6 
.................... {      0x01, 0x71, 0x09, 0x05, 0x03, 0x00},// 7 
.................... {      0x36, 0x49, 0x49, 0x49, 0x36, 0x00},// 8 
.................... {      0x06, 0x49, 0x49, 0x29, 0x1E, 0x00},// 9 
.................... {      0x00, 0x36, 0x36, 0x00, 0x00, 0x00},// : 
.................... {      0x00, 0x56, 0x36, 0x00, 0x00, 0x00},// ; 
.................... {      0x00, 0x08, 0x14, 0x22, 0x41, 0x00},// < 
.................... {      0x14, 0x14, 0x14, 0x14, 0x14, 0x00},// = 
.................... {      0x41, 0x22, 0x14, 0x08, 0x00, 0x00},// > 
.................... {      0x02, 0x01, 0x51, 0x09, 0x06, 0x00},// ? 
.................... {      0x32, 0x49, 0x79, 0x41, 0x3E, 0x00},// @ 
.................... {      0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00},// A   
.................... {      0x7F, 0x49, 0x49, 0x49, 0x36, 0x00},// B 
.................... {      0x3E, 0x41, 0x41, 0x41, 0x22, 0x00},// C 
.................... {      0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00},// D 
.................... {      0x7F, 0x49, 0x49, 0x49, 0x41, 0x00},// E 
.................... {      0x7F, 0x09, 0x09, 0x01, 0x01, 0x00},// F 
.................... {      0x3E, 0x41, 0x41, 0x51, 0x32, 0x00},// G 
.................... {      0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00},// H 
.................... {      0x00, 0x41, 0x7F, 0x41, 0x00, 0x00},// I 
.................... {      0x20, 0x40, 0x41, 0x3F, 0x01, 0x00},// J 
.................... {      0x7F, 0x08, 0x14, 0x22, 0x41, 0x00},// K 
.................... {      0x7F, 0x40, 0x40, 0x40, 0x40, 0x00},// L 
.................... {      0x7F, 0x02, 0x04, 0x02, 0x7F, 0x00},// M 
.................... {      0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00},// N 
.................... {      0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00},// O 
.................... {      0x7F, 0x09, 0x09, 0x09, 0x06, 0x00},// P 
.................... {      0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00},// Q 
.................... {      0x7F, 0x09, 0x19, 0x29, 0x46, 0x00},// R 
.................... {      0x46, 0x49, 0x49, 0x49, 0x31, 0x00},// S 
.................... {      0x01, 0x01, 0x7F, 0x01, 0x01, 0x00},// T 
.................... {      0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00},// U 
.................... {      0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00},// V 
.................... {      0x7F, 0x20, 0x18, 0x20, 0x7F, 0x00},// W 
.................... {      0x63, 0x14, 0x08, 0x14, 0x63, 0x00},// X 
.................... {      0x03, 0x04, 0x78, 0x04, 0x03, 0x00},// Y 
.................... {      0x61, 0x51, 0x49, 0x45, 0x43, 0x00},// Z 
.................... {      0x00, 0x00, 0x7F, 0x41, 0x41, 0x00},// [ 
.................... {      0x02, 0x04, 0x08, 0x10, 0x20, 0x00},// "\" 
.................... {      0x41, 0x41, 0x7F, 0x00, 0x00, 0x00},// ] 
.................... {      0x04, 0x02, 0x01, 0x02, 0x04, 0x00},// ^ 
.................... {      0x40, 0x40, 0x40, 0x40, 0x40, 0x00},// _ 
.................... {      0x00, 0x01, 0x02, 0x04, 0x00, 0x00},// ` 
.................... {      0x20, 0x54, 0x54, 0x54, 0x78, 0x00},// a 
.................... {      0x7F, 0x48, 0x44, 0x44, 0x38, 0x00},// b 
.................... {      0x38, 0x44, 0x44, 0x44, 0x20, 0x00},// c 
.................... {      0x38, 0x44, 0x44, 0x48, 0x7F, 0x00},// d 
.................... {      0x38, 0x54, 0x54, 0x54, 0x18, 0x00},// e 
.................... {      0x08, 0x7E, 0x09, 0x01, 0x02, 0x00},// f 
.................... {      0x08, 0x14, 0x54, 0x54, 0x3C, 0x00},// g 
.................... {      0x7F, 0x08, 0x04, 0x04, 0x78, 0x00},// h 
.................... {      0x00, 0x44, 0x7D, 0x40, 0x00, 0x00},// i 
.................... {      0x20, 0x40, 0x44, 0x3D, 0x00, 0x00},// j 
.................... {      0x00, 0x7F, 0x10, 0x28, 0x44, 0x00},// k 
.................... {      0x00, 0x41, 0x7F, 0x40, 0x00, 0x00},// l 
.................... {      0x7C, 0x04, 0x18, 0x04, 0x78, 0x00},// m 
.................... {      0x7C, 0x08, 0x04, 0x04, 0x78, 0x00},// n 
.................... {      0x38, 0x44, 0x44, 0x44, 0x38, 0x00},// o 
.................... {      0x7C, 0x14, 0x14, 0x14, 0x08, 0x00},// p 
.................... {      0x08, 0x14, 0x14, 0x18, 0x7C, 0x00},// q 
.................... {      0x7C, 0x08, 0x04, 0x04, 0x08, 0x00},// r 
.................... {      0x48, 0x54, 0x54, 0x54, 0x20, 0x00},// s 
.................... {      0x04, 0x3F, 0x44, 0x40, 0x20, 0x00},// t 
.................... {      0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00},// u 
.................... {      0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00},// v 
.................... {      0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00},// w 
.................... {      0x44, 0x28, 0x10, 0x28, 0x44, 0x00},// x 
.................... {      0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00},// y 
.................... {      0x44, 0x64, 0x54, 0x4C, 0x44, 0x00},// z 
.................... {      0x00, 0x08, 0x36, 0x41, 0x00, 0x00},// { 
.................... {      0x00, 0x00, 0x7F, 0x00, 0x00, 0x00},// | 
.................... {      0x00, 0x41, 0x36, 0x08, 0x00, 0x00},// } 
.................... {      0x08, 0x08, 0x2A, 0x1C, 0x08, 0x00},// -> 
.................... {      0x08, 0x1C, 0x2A, 0x08, 0x08, 0x00} // <- 
.................... };       
....................      
....................  
.................... #endif // FONTS_H 
....................  
.................... #ifndef GLCD_H        
.................... #define GLCD_H    
.................... //EARTH ANIMATION SDCARD POSITION                              
.................... const uint8_t startSector = 39; 
.................... const uint16_t sectorSize = 397;  
.................... extern uint16_t sectorPosition;   
.................... // BUFFER FOR DISPLAY                                        
.................... extern uchar_t GLCD_BUFFER[512];  
....................  
....................  
.................... // DISPALY IMAGE FUNCTION                         
.................... void GLCD_DrawTop();  
.................... void GLCD_DrawBottom();  
....................  
.................... // DISPLAY CHAR 
.................... void GLCD_StringChar(uint8_t);  
....................                                      
.................... // WRITE COUNTRY NAME   
.................... void GLCD_StringCenterOfDisp(uint8_t *, uchar_t);  
....................  
.................... // CONTROL METHODS    
.................... void GLCD_Init();    
.................... void GLCD_Command(uchar_t cmd); 
.................... void GLCD_Char(uchar_t data); 
.................... void GLCD_Clear(); 
.................... void CS1FUN(); 
.................... void CS2FUN(); 
....................                   
.................... void NOP();       
.................... #endif //GLCD_H                            
....................  
....................   
....................          
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
.................... //EARTH ANIMATION SDCARD POSITION  
.................... uint16_t sectorPosition;      
....................  
.................... // BUFFER FOR DISPLAY                                 
.................... uchar_t GLCD_BUFFER[512];  
....................  
....................                               
.................... void GLCD_DrawTop(){  /* GLCD string write function */  
*
0D1E:  MOVLB  2
0D20:  CLRF   x29
0D22:  CLRF   x2A
0D24:  MOVLW  B8
0D26:  MOVWF  x2B
0D28:  CLRF   x2D
0D2A:  CLRF   x2C
....................    uchar_t x=0, y=0, pageAdd=0xB8; 
....................    uint16_t arrayPosition=0; 
....................    for(y=0;y<4;y++){  
0D2C:  CLRF   x2A
0D2E:  MOVF   x2A,W
0D30:  SUBLW  03
0D32:  BNC   0DD4
....................       CS1FUN();   
0D34:  MOVLB  0
0D36:  RCALL  0D0A
....................       GLCD_Command(pageAdd+y); 
0D38:  MOVLB  2
0D3A:  MOVF   x2A,W
0D3C:  ADDWF  x2B,W
0D3E:  MOVWF  x2E
0D40:  MOVWF  x30
0D42:  MOVLB  0
0D44:  CALL   00E2
....................       GLCD_Command(0x40);    
0D48:  MOVLW  40
0D4A:  MOVLB  2
0D4C:  MOVWF  x30
0D4E:  MOVLB  0
0D50:  CALL   00E2
....................       for(x=0;x<64;x++){   
0D54:  MOVLB  2
0D56:  CLRF   x29
0D58:  MOVF   x29,W
0D5A:  SUBLW  3F
0D5C:  BNC   0D82
....................          //if((x%16)==0) 
....................            // printf("\n\r");  
....................          GLCD_Char(GLCD_BUFFER[arrayPosition]);   
0D5E:  MOVLW  1E
0D60:  ADDWF  x2C,W
0D62:  MOVWF  FE9
0D64:  MOVLW  00
0D66:  ADDWFC x2D,W
0D68:  MOVWF  FEA
0D6A:  MOVFF  FEF,22E
0D6E:  MOVFF  22E,233
0D72:  MOVLB  0
0D74:  RCALL  0B3E
....................          arrayPosition++;                
0D76:  MOVLB  2
0D78:  INCF   x2C,F
0D7A:  BTFSC  FD8.2
0D7C:  INCF   x2D,F
0D7E:  INCF   x29,F
0D80:  BRA    0D58
....................       }                      
....................       CS2FUN();   
0D82:  MOVLB  0
0D84:  RCALL  0D14
....................       GLCD_Command(pageAdd+y); 
0D86:  MOVLB  2
0D88:  MOVF   x2A,W
0D8A:  ADDWF  x2B,W
0D8C:  MOVWF  x2E
0D8E:  MOVWF  x30
0D90:  MOVLB  0
0D92:  CALL   00E2
....................       GLCD_Command(0x40);     
0D96:  MOVLW  40
0D98:  MOVLB  2
0D9A:  MOVWF  x30
0D9C:  MOVLB  0
0D9E:  CALL   00E2
....................       for(x=0;x<64;x++){   
0DA2:  MOVLB  2
0DA4:  CLRF   x29
0DA6:  MOVF   x29,W
0DA8:  SUBLW  3F
0DAA:  BNC   0DD0
....................       //  if((x%16)==0) 
....................          //  printf("\n\r");  
....................         GLCD_Char(GLCD_BUFFER[arrayPosition]);  
0DAC:  MOVLW  1E
0DAE:  ADDWF  x2C,W
0DB0:  MOVWF  FE9
0DB2:  MOVLW  00
0DB4:  ADDWFC x2D,W
0DB6:  MOVWF  FEA
0DB8:  MOVFF  FEF,22E
0DBC:  MOVFF  22E,233
0DC0:  MOVLB  0
0DC2:  RCALL  0B3E
....................         arrayPosition++;            
0DC4:  MOVLB  2
0DC6:  INCF   x2C,F
0DC8:  BTFSC  FD8.2
0DCA:  INCF   x2D,F
0DCC:  INCF   x29,F
0DCE:  BRA    0DA6
....................       }  
0DD0:  INCF   x2A,F
0DD2:  BRA    0D2E
....................    } 
0DD4:  MOVLB  0
0DD6:  GOTO   0FB6 (RETURN)
.................... }                                                                                 
.................... void GLCD_DrawBottom(){  /* GLCD string write function */        
0DDA:  MOVLB  2
0DDC:  CLRF   x29
0DDE:  CLRF   x2A
0DE0:  MOVLW  BC
0DE2:  MOVWF  x2B
0DE4:  CLRF   x2D
0DE6:  CLRF   x2C
....................    uchar_t x=0, y=0, pageAdd=0xBC; 
....................    uint16_t arrayPosition=0; 
....................    for(y=0;y<4;y++){  
0DE8:  CLRF   x2A
0DEA:  MOVF   x2A,W
0DEC:  SUBLW  03
0DEE:  BNC   0E90
....................        CS1FUN();                          
0DF0:  MOVLB  0
0DF2:  RCALL  0D0A
....................        GLCD_Command(pageAdd+y); 
0DF4:  MOVLB  2
0DF6:  MOVF   x2A,W
0DF8:  ADDWF  x2B,W
0DFA:  MOVWF  x2E
0DFC:  MOVWF  x30
0DFE:  MOVLB  0
0E00:  CALL   00E2
....................        GLCD_Command(0x40);    
0E04:  MOVLW  40
0E06:  MOVLB  2
0E08:  MOVWF  x30
0E0A:  MOVLB  0
0E0C:  CALL   00E2
....................       for(x=0;x<64;x++){   
0E10:  MOVLB  2
0E12:  CLRF   x29
0E14:  MOVF   x29,W
0E16:  SUBLW  3F
0E18:  BNC   0E3E
....................          //if((x%16)==0) 
....................           // printf("\n\r"); 
....................          GLCD_Char(GLCD_BUFFER[arrayPosition]);   
0E1A:  MOVLW  1E
0E1C:  ADDWF  x2C,W
0E1E:  MOVWF  FE9
0E20:  MOVLW  00
0E22:  ADDWFC x2D,W
0E24:  MOVWF  FEA
0E26:  MOVFF  FEF,22E
0E2A:  MOVFF  22E,233
0E2E:  MOVLB  0
0E30:  RCALL  0B3E
....................          arrayPosition++;                
0E32:  MOVLB  2
0E34:  INCF   x2C,F
0E36:  BTFSC  FD8.2
0E38:  INCF   x2D,F
0E3A:  INCF   x29,F
0E3C:  BRA    0E14
....................       }                      
....................       CS2FUN();   
0E3E:  MOVLB  0
0E40:  RCALL  0D14
....................       GLCD_Command(pageAdd+y); 
0E42:  MOVLB  2
0E44:  MOVF   x2A,W
0E46:  ADDWF  x2B,W
0E48:  MOVWF  x2E
0E4A:  MOVWF  x30
0E4C:  MOVLB  0
0E4E:  CALL   00E2
....................       GLCD_Command(0x40);     
0E52:  MOVLW  40
0E54:  MOVLB  2
0E56:  MOVWF  x30
0E58:  MOVLB  0
0E5A:  CALL   00E2
....................       for(x=0;x<64;x++){  
0E5E:  MOVLB  2
0E60:  CLRF   x29
0E62:  MOVF   x29,W
0E64:  SUBLW  3F
0E66:  BNC   0E8C
....................        // if((x%16)==0) 
....................          //  printf("\n\r"); 
....................         GLCD_Char(GLCD_BUFFER[arrayPosition]);  
0E68:  MOVLW  1E
0E6A:  ADDWF  x2C,W
0E6C:  MOVWF  FE9
0E6E:  MOVLW  00
0E70:  ADDWFC x2D,W
0E72:  MOVWF  FEA
0E74:  MOVFF  FEF,22E
0E78:  MOVFF  22E,233
0E7C:  MOVLB  0
0E7E:  RCALL  0B3E
....................         arrayPosition++;     
0E80:  MOVLB  2
0E82:  INCF   x2C,F
0E84:  BTFSC  FD8.2
0E86:  INCF   x2D,F
0E88:  INCF   x29,F
0E8A:  BRA    0E62
....................       }  
0E8C:  INCF   x2A,F
0E8E:  BRA    0DEA
....................    } 
0E90:  MOVLB  0
0E92:  GOTO   0FBA (RETURN)
.................... }                                                                                 
....................  
.................... void GLCD_StringCenterOfDisp(uint8_t * data, uchar_t size){ 
*
0F16:  MOVLW  B8
0F18:  MOVLB  2
0F1A:  MOVWF  x2C
0F1C:  CLRF   x2E
....................    uint8_t pageAdd=0xB8;   uint8_t i, xMargin=0;  
....................    xMargin = (size/2)*6 ;         
0F1E:  BCF    FD8.0
0F20:  RRCF   x2B,W
0F22:  MULLW  06
0F24:  MOVFF  FF3,22E
....................    CS1FUN();       
0F28:  MOVLB  0
0F2A:  RCALL  0D0A
....................    GLCD_Command(pageAdd+4);   //UNITEDSTATES                 
0F2C:  MOVLW  04
0F2E:  MOVLB  2
0F30:  ADDWF  x2C,W
0F32:  MOVWF  x2F
0F34:  MOVWF  x30
0F36:  MOVLB  0
0F38:  CALL   00E2
....................    GLCD_Command((0x40+64)-xMargin);  
0F3C:  MOVLW  80
0F3E:  BSF    FD8.0
0F40:  MOVLB  2
0F42:  SUBFWB x2E,W
0F44:  MOVWF  x2F
0F46:  MOVWF  x30
0F48:  MOVLB  0
0F4A:  CALL   00E2
....................    for(i=0;i<size;i++){  
0F4E:  MOVLB  2
0F50:  CLRF   x2D
0F52:  MOVF   x2B,W
0F54:  SUBWF  x2D,W
0F56:  BC    0FAA
....................        GLCD_StringChar(data[i]-32);  
0F58:  CLRF   03
0F5A:  MOVF   x2D,W
0F5C:  ADDWF  x29,W
0F5E:  MOVWF  FE9
0F60:  MOVF   x2A,W
0F62:  ADDWFC 03,W
0F64:  MOVWF  FEA
0F66:  MOVLW  20
0F68:  SUBWF  FEF,W
0F6A:  MOVWF  x2F
0F6C:  MOVWF  x30
0F6E:  MOVLB  0
0F70:  BRA    0EBA
....................        if(i*6==(xMargin-6)){  
0F72:  MOVLB  2
0F74:  MOVF   x2D,W
0F76:  MULLW  06
0F78:  MOVFF  FF3,22F
0F7C:  MOVLW  06
0F7E:  SUBWF  x2E,W
0F80:  SUBWF  x2F,W
0F82:  BNZ   0FA6
....................           CS2FUN();   
0F84:  MOVLB  0
0F86:  RCALL  0D14
....................           GLCD_Command(pageAdd+4);                    
0F88:  MOVLW  04
0F8A:  MOVLB  2
0F8C:  ADDWF  x2C,W
0F8E:  MOVWF  x2F
0F90:  MOVWF  x30
0F92:  MOVLB  0
0F94:  CALL   00E2
....................           GLCD_Command(0x40); 
0F98:  MOVLW  40
0F9A:  MOVLB  2
0F9C:  MOVWF  x30
0F9E:  MOVLB  0
0FA0:  CALL   00E2
0FA4:  MOVLB  2
....................        }       
0FA6:  INCF   x2D,F
0FA8:  BRA    0F52
....................     }   
0FAA:  MOVLB  0
0FAC:  GOTO   0FF6 (RETURN)
.................... }                                           
.................... void GLCD_StringChar(uint8_t data){  
....................    uint8_t i;  
....................    for(i=0;i<6;i++){                 
*
0EBA:  MOVLB  2
0EBC:  CLRF   x31
0EBE:  MOVF   x31,W
0EC0:  SUBLW  05
0EC2:  BNC   0F10
....................       GLCD_Char(Font5x7[data][i]); 
0EC4:  CLRF   x33
0EC6:  MOVFF  230,232
0ECA:  CLRF   x35
0ECC:  MOVLW  06
0ECE:  MOVWF  x34
0ED0:  MOVLB  0
0ED2:  BRA    0E96
0ED4:  MOVFF  02,233
0ED8:  MOVFF  01,232
0EDC:  MOVLB  2
0EDE:  MOVF   x31,W
0EE0:  ADDWF  01,W
0EE2:  MOVWF  01
0EE4:  MOVLW  00
0EE6:  ADDWFC 02,W
0EE8:  MOVWF  03
0EEA:  MOVF   01,W
0EEC:  MOVFF  FF2,232
0EF0:  BCF    FF2.7
0EF2:  MOVFF  03,FF7
0EF6:  MOVLB  0
0EF8:  CALL   0302
0EFC:  MOVLB  2
0EFE:  BTFSC  x32.7
0F00:  BSF    FF2.7
0F02:  MOVWF  x32
0F04:  MOVWF  x33
0F06:  MOVLB  0
0F08:  RCALL  0B3E
0F0A:  MOVLB  2
0F0C:  INCF   x31,F
0F0E:  BRA    0EBE
....................    }         
0F10:  MOVLB  0
0F12:  GOTO   0F72 (RETURN)
.................... } 
....................   
.................... void GLCD_Init(){       // GLCD Initialization function 
....................     TRISBB = 0;          // Make Control pin as output  
*
0638:  CLRF   F93
....................     TRISD = 0;          // Make Data pin as output    
063A:  CLRF   F95
....................     RW=0; 
063C:  BCF    F8A.3
....................     RST = 1;            // Make reset pin High  
063E:  BSF    F8A.5
....................     RST = 0;            // Make reset pin High  
0640:  BCF    F8A.5
....................     CS1 = 1; CS2 = 1;   // Select Left half of display  
0642:  BSF    F8A.0
0644:  BSF    F8A.1
....................     delay_ms(20);      
0646:  MOVLW  14
0648:  MOVLB  2
064A:  MOVWF  x21
064C:  MOVLB  0
064E:  RCALL  0610
....................     GLCD_Command(0x3E); // Display OFF            
0650:  MOVLW  3E
0652:  MOVLB  2
0654:  MOVWF  x30
0656:  MOVLB  0
0658:  RCALL  00E2
....................     GLCD_Command(0x40); // Set X address (column=0)  
065A:  MOVLW  40
065C:  MOVLB  2
065E:  MOVWF  x30
0660:  MOVLB  0
0662:  RCALL  00E2
....................     GLCD_Command(0xB8); // Set Y address (page=0)  
0664:  MOVLW  B8
0666:  MOVLB  2
0668:  MOVWF  x30
066A:  MOVLB  0
066C:  RCALL  00E2
....................     GLCD_Command(0xC0); // Set z address (start line=0)  
066E:  MOVLW  C0
0670:  MOVLB  2
0672:  MOVWF  x30
0674:  MOVLB  0
0676:  RCALL  00E2
....................     GLCD_Command(0x3F); // Display ON  
0678:  MOVLW  3F
067A:  MOVLB  2
067C:  MOVWF  x30
067E:  MOVLB  0
0680:  RCALL  00E2
0682:  GOTO   0132 (RETURN)
.................... }                                                 
.................... void GLCD_Command(uchar_t cmd){ // GLCD Command function 
....................                                
....................     LCD_data = cmd;   // Copy command on data pin  
*
00E2:  MOVFF  230,F8C
....................     RS = 0;           // Make RS LOW for command register 
00E6:  BCF    F8A.2
....................     EN = 1;// Make HIGH-LOW transition on Enable 
00E8:  BSF    F8A.4
....................     NOP();    
00EA:  RCALL  00DE
....................     NOP();   
00EC:  RCALL  00DE
....................     NOP();     
00EE:  RCALL  00DE
....................     EN = 0;  
00F0:  BCF    F8A.4
....................     NOP(); 
00F2:  RCALL  00DE
....................     NOP();  
00F4:  RCALL  00DE
....................     NOP();  
00F6:  RCALL  00DE
00F8:  RETURN 0
.................... }                         
.................... void GLCD_Char(uchar_t data){ // GLCD Data function 
....................     LCD_data = data;       // Copy Data on data pin 
*
0B3E:  MOVFF  233,F8C
....................     RS = 1;                // Make RS HIGH for data register  
0B42:  BSF    F8A.2
....................     EN = 1;                // Make HIGH-LOW transition on Enable 
0B44:  BSF    F8A.4
....................     NOP(); 
0B46:  CALL   00DE
....................     EN = 0; 
0B4A:  BCF    F8A.4
....................     NOP();           
0B4C:  CALL   00DE
0B50:  RETURN 0
....................     //printf("%X ",data);   
.................... }                                                                              
.................... void GLCD_Clear(){ 
....................    int i,j; 
....................    CS1 = 1; CS2 = 1;                           /* Select both left & right half of display */ 
0B52:  BSF    F8A.0
0B54:  BSF    F8A.1
....................    for(i=0;i<8;i++){ 
0B56:  MOVLB  2
0B58:  CLRF   x29
0B5A:  MOVF   x29,W
0B5C:  SUBLW  07
0B5E:  BNC   0B88
....................       GLCD_Command((0xB8)+i);                     /* Increment page each time after 64 column */ 
0B60:  MOVLW  B8
0B62:  ADDWF  x29,W
0B64:  MOVWF  x2B
0B66:  MOVWF  x30
0B68:  MOVLB  0
0B6A:  CALL   00E2
....................       for(j=0;j<64;j++){ 
0B6E:  MOVLB  2
0B70:  CLRF   x2A
0B72:  MOVF   x2A,W
0B74:  SUBLW  3F
0B76:  BNC   0B84
....................          GLCD_Char(0);                        /* Write zeros to all 64 column */ 
0B78:  CLRF   x33
0B7A:  MOVLB  0
0B7C:  RCALL  0B3E
0B7E:  MOVLB  2
0B80:  INCF   x2A,F
0B82:  BRA    0B72
....................       } 
0B84:  INCF   x29,F
0B86:  BRA    0B5A
....................    } 
....................    GLCD_Command(0x40);                           /* Set Y address (column=0) */ 
0B88:  MOVLW  40
0B8A:  MOVWF  x30
0B8C:  MOVLB  0
0B8E:  CALL   00E2
....................    GLCD_Command(0xB8);                           /* Set x address (page=0) */ 
0B92:  MOVLW  B8
0B94:  MOVLB  2
0B96:  MOVWF  x30
0B98:  MOVLB  0
0B9A:  CALL   00E2
0B9E:  GOTO   0CE2 (RETURN)
.................... }       
.................... void CS1FUN(){ 
....................    CS1=1; //Selecting 1 Half 
*
0D0A:  BSF    F8A.0
....................      NOP();                  
0D0C:  CALL   00DE
....................    CS2=0; //Switch off other half 
0D10:  BCF    F8A.1
0D12:  RETURN 0
.................... }  
.................... void CS2FUN(){ 
....................    CS1=0;  //Switch off First Half 
0D14:  BCF    F8A.0
....................      NOP();  
0D16:  CALL   00DE
....................    CS2=1;  //Selecting 2nd Half 
0D1A:  BSF    F8A.1
0D1C:  RETURN 0
.................... } 
....................  
.................... void NOP(){            
....................    #asm                   
*
00DE:  NOP   
....................    NOP                           
....................    #endasm                                  
00E0:  RETURN 0
.................... } 
....................  
.................... #endif //GLCD_H 
....................  
....................                              
....................                                     
.................... //TIMER1 UNION STRUCTURE AND COUNT MS                                        
.................... tmr1_time_t tmr1_time;  
.................... uint16_t iSayac;                                  
....................  
....................                     
....................  
.................... void displayVideoAnimation(){   
....................    INTCON_GIE_GIEH = 0;  
*
0FB0:  BCF    FF2.7
....................    readSectorData(); 
0FB2:  RCALL  0C84
....................    GLCD_DrawTop(); 
0FB4:  BRA    0D1E
....................    //printf("\n\r"); 
....................    readSectorData();  
0FB6:  RCALL  0C84
....................    GLCD_DrawBottom(); 
0FB8:  BRA    0DDA
....................    //printf("\n\r");    
....................    uchar_t text[]=" .TURKIYE ";     
0FBA:  MOVLW  20
0FBC:  MOVLB  2
0FBE:  MOVWF  x1E
0FC0:  MOVLW  2E
0FC2:  MOVWF  x1F
0FC4:  MOVLW  54
0FC6:  MOVWF  x20
0FC8:  MOVLW  55
0FCA:  MOVWF  x21
0FCC:  MOVLW  52
0FCE:  MOVWF  x22
0FD0:  MOVLW  4B
0FD2:  MOVWF  x23
0FD4:  MOVLW  49
0FD6:  MOVWF  x24
0FD8:  MOVLW  59
0FDA:  MOVWF  x25
0FDC:  MOVLW  45
0FDE:  MOVWF  x26
0FE0:  MOVLW  20
0FE2:  MOVWF  x27
0FE4:  CLRF   x28
....................    GLCD_StringCenterOfDisp(text, (sizeof(text)/sizeof(text[0]))-1);    
0FE6:  MOVLW  02
0FE8:  MOVWF  x2A
0FEA:  MOVLW  1E
0FEC:  MOVWF  x29
0FEE:  MOVLW  0A
0FF0:  MOVWF  x2B
0FF2:  MOVLB  0
0FF4:  BRA    0F16
....................    INTCON_GIE_GIEH = 1; 
0FF6:  BSF    FF2.7
0FF8:  GOTO   0144 (RETURN)
.................... }  
.................... void readSectorData(){   
....................    memset(GLCD_BUFFER,0,512); 
*
0C84:  CLRF   FEA
0C86:  MOVLW  1E
0C88:  MOVWF  FE9
0C8A:  CLRF   00
0C8C:  MOVLW  02
0C8E:  MOVWF  02
0C90:  CLRF   01
0C92:  BRA    0A32
....................    if(sectorPosition<startSector) 
0C94:  MOVF   1D,F
0C96:  BNZ   0CA4
0C98:  MOVF   1C,W
0C9A:  SUBLW  26
0C9C:  BNC   0CA4
....................       sectorPosition=startSector;        
0C9E:  CLRF   1D
0CA0:  MOVLW  27
0CA2:  MOVWF  1C
....................    if(!sdcard_read_sector(sectorPosition, GLCD_BUFFER)){       
0CA4:  MOVLB  2
0CA6:  CLRF   x2C
0CA8:  CLRF   x2B
0CAA:  MOVFF  1D,22A
0CAE:  MOVFF  1C,229
0CB2:  CLRF   x2E
0CB4:  MOVLW  1E
0CB6:  MOVWF  x2D
0CB8:  MOVLB  0
0CBA:  BRA    0A4E
0CBC:  MOVF   01,F
0CBE:  BNZ   0CE0
....................       if(sectorPosition>=sectorSize+39)           
0CC0:  MOVF   1D,W
0CC2:  SUBLW  00
0CC4:  BC    0CD8
0CC6:  XORLW  FF
0CC8:  BNZ   0CD0
0CCA:  MOVF   1C,W
0CCC:  SUBLW  B3
0CCE:  BC    0CD8
....................          sectorPosition=startSector; 
0CD0:  CLRF   1D
0CD2:  MOVLW  27
0CD4:  MOVWF  1C
0CD6:  BRA    0CDE
....................       else                   
....................          sectorPosition++;            
0CD8:  INCF   1C,F
0CDA:  BTFSC  FD8.2
0CDC:  INCF   1D,F
....................       //printf("SECTOR POSITION: %Lu\r\n",sectorPosition);   
....................        //uint16_t i;     
....................        //for(i=0;i<512;i++){  
....................        //if((i%32)==0)   
....................        //printf("\r\n");                                       
....................    }else{  
0CDE:  BRA    0D08
....................       GLCD_Clear();  
0CE0:  BRA    0B52
....................       sectorPosition =startSector; 
0CE2:  CLRF   1D
0CE4:  MOVLW  27
0CE6:  MOVWF  1C
....................       printf("HATA SECTOR: %Lu",sectorPosition);   
0CE8:  MOVLW  5A
0CEA:  MOVWF  FF6
0CEC:  MOVLW  05
0CEE:  MOVWF  FF7
0CF0:  MOVLW  0D
0CF2:  MOVLB  2
0CF4:  MOVWF  x29
0CF6:  MOVLB  0
0CF8:  BRA    0BA2
0CFA:  MOVLW  10
0CFC:  MOVWF  FE9
0CFE:  MOVFF  1D,22A
0D02:  MOVFF  1C,229
0D06:  BRA    0BCE
....................    } 
0D08:  RETURN 0
.................... }                        
....................                                   
.................... #ORG 0x0100,0x0300                                                                     
.................... void main(){         
*
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  MOVLW  70
0108:  MOVWF  FD3
010A:  MOVF   FD3,W
010C:  BSF    FB8.3
010E:  MOVLW  22
0110:  MOVWF  FAF
0112:  MOVLW  00
0114:  MOVWF  FB0
0116:  MOVLW  A6
0118:  MOVWF  FAC
011A:  MOVLW  90
011C:  MOVWF  FAB
011E:  NOP   
0120:  NOP   
0122:  MOVF   FC1,W
0124:  ANDLW  C0
0126:  IORLW  0F
0128:  MOVWF  FC1
012A:  MOVLW  07
012C:  MOVWF  FB4
....................    setupTimerIOSC();               
012E:  BRA    05DE
....................    GLCD_Init(); 
0130:  BRA    0638
....................    initMMC();                                                   
0132:  GOTO   0A14
....................    while (TRUE){                                                                        
....................      WDTreset();                                        
0136:  GOTO   0A2C
....................      if(tmr1_time.tmr1_flags._2ms){      
013A:  BTFSS  18.0
013C:  BRA    0144
....................         tmr1_time.tmr1_flags._2ms = 0; 
013E:  BCF    18.0
....................         displayVideoAnimation();                            
0140:  GOTO   0FB0
....................      }                        
....................      if(tmr1_time.tmr1_flags._1000ms){                       
0144:  BTFSS  18.6
0146:  BRA    014C
....................         tmr1_time.tmr1_flags._1000ms = 0;        
0148:  BCF    18.6
....................         PORTB_7=~PORTB_7; 
014A:  BTG    F81.7
....................           
....................          
....................      }                                   
014C:  BRA    0136
....................   }                                   
.................... }  
....................                                                      
.................... #INT_TIMER1                                                            
.................... void timer1_interrupt(){  
014E:  SLEEP 
....................    TMR1H = 0xF8; //Tasma saayci| 
*
056C:  MOVLW  F8
056E:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.   
0570:  MOVLW  30
0572:  MOVWF  FCE
....................    PIR1_TMR1IF = 0; // Kesme bayragi sifirlaniyor.    
0574:  BCF    F9E.0
....................    iSayac++; 
0576:  INCF   16,F
0578:  BTFSC  FD8.2
057A:  INCF   17,F
....................                    
....................    if (iSayac % 2 == 0)  //2ms   
057C:  MOVF   16,W
057E:  ANDLW  01
0580:  MOVLB  2
0582:  MOVWF  x3E
0584:  CLRF   x3F
0586:  MOVF   x3E,F
0588:  BNZ   0590
058A:  MOVF   x3F,F
058C:  BNZ   0590
....................       tmr1_time.tmr1_flags._2ms = 1; 
058E:  BSF    18.0
....................    if (iSayac % 200 == 0)  //200ms   
0590:  MOVFF  17,23F
0594:  MOVFF  16,23E
0598:  CLRF   x41
059A:  MOVLW  C8
059C:  MOVWF  x40
059E:  MOVLB  0
05A0:  BRA    0096
05A2:  MOVFF  00,23E
05A6:  MOVLB  2
05A8:  MOVFF  03,23F
05AC:  MOVF   x3E,F
05AE:  BNZ   05B6
05B0:  MOVF   x3F,F
05B2:  BNZ   05B6
....................       tmr1_time.tmr1_flags._200ms = 1;      
05B4:  BSF    18.4
....................    if(iSayac >= 1000){    //1 Second 
05B6:  MOVF   17,W
05B8:  SUBLW  02
05BA:  BC    05CC
05BC:  XORLW  FF
05BE:  BNZ   05C6
05C0:  MOVF   16,W
05C2:  SUBLW  E7
05C4:  BC    05CC
....................       tmr1_time.tmr1_flags._1000ms = 1;  
05C6:  BSF    18.6
....................       iSayac = 0; 
05C8:  CLRF   17
05CA:  CLRF   16
....................    }                                         
05CC:  BCF    F9E.0
05CE:  MOVLB  0
05D0:  GOTO   0054
.................... }                     
....................             
.................... void setupTimerIOSC(void){          
....................    //Setup Osilator   
....................    IRCF2 = 1;   
*
05DE:  BSF    FD3.6
....................    IRCF1 = 1; 
05E0:  BSF    FD3.5
....................    IRCF0 = 1;                    
05E2:  BSF    FD3.4
....................    TRISB=0x00;                     
05E4:  CLRF   F93
....................                                                       
....................    //TMR1 etkinlik bayraklari sifirlandi 
....................    tmr1_time.all = 0; 
05E6:  CLRF   18
....................  
....................    // Kesmelere izin verildi 
....................    RCON_IPEN = 1;                                               
05E8:  BSF    FD0.7
....................    INTCON_GIE_GIEH = 1;  
05EA:  BSF    FF2.7
....................    INTCON_PEIE = 1;           
05EC:  BSF    FF2.6
....................    IPR1_TMR1IP = 1; // TMR1 Overflow Interrupt Priority bit 
05EE:  BSF    F9F.0
....................    PIE1_TMR1IE = 1; // TMR1 Overflow Interrupt Enable bit 
05F0:  BSF    F9D.0
....................    PIR1_TMR1IF = 0; // TMR1 Overflow Interrupt Flag bit 
05F2:  BCF    F9E.0
....................                                                                                        
....................    //TIMER1 Konfigurasyon //50us 
....................    T1CON_RD16 = 0; // 16 - bit Read / Write Mode Enable bit  
05F4:  BCF    FCD.7
....................    T1CON_T1RUN = 0; // Timer1 System Clock Statusbit 
05F6:  BCF    FCD.6
....................    T1CON_T1CKPS1 = 0; // Timer1 Input Clock Prescale Select bits | 1:1 Olcekleme 
05F8:  BCF    FCD.5
....................    T1CON_T1CKPS0 = 0; // Timer1 Input Clock Prescale Select bits | 
05FA:  BCF    FCD.4
....................    T1CON_T1OSCEN = 0; // Timer1 Oscillator Enable bit 
05FC:  BCF    FCD.3
....................    T1CON_T1SYNC = 0; // Timer1 External Clock Input Synchronization Select bit 
05FE:  BCF    FCD.2
....................    T1CON_TMR1CS = 0; // Timer1 Clock Source Select bit 
0600:  BCF    FCD.1
....................    TMR1H = 0xF8; //Tasma saayci| 
0602:  MOVLW  F8
0604:  MOVWF  FCF
....................    TMR1L = 0x30; // |||15536 decimal sayisina esit.     
0606:  MOVLW  30
0608:  MOVWF  FCE
....................    T1CON_TMR1ON = 1; // Timer1 On bit         
060A:  BSF    FCD.0
060C:  GOTO   0130 (RETURN)
.................... }                  
....................  
.................... void initMMC(){ 
....................     INTCON_GIE_GIEH = 0;   
*
0A14:  BCF    FF2.7
....................     if(!sdcard_init())  
0A16:  BRA    089C
0A18:  MOVF   01,F
0A1A:  BNZ   0A26
....................       printf("Calisti..");  
0A1C:  MOVLW  D4
0A1E:  MOVWF  FF6
0A20:  MOVLW  05
0A22:  MOVWF  FF7
0A24:  BRA    09F0
....................     INTCON_GIE_GIEH = 1;  
0A26:  BSF    FF2.7
0A28:  GOTO   0136 (RETURN)
.................... }                                
....................                                   
.................... void WDTreset(void){           
....................    #asm                   
0A2C:  CLRWDT
....................    CLRWDT                           
....................    #endasm                                  
0A2E:  GOTO   013A (RETURN)
.................... }            
....................                                                                                     

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 061E   PUT BROWNOUT BORV21 NOWDT WDT8
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
